/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./data/sounds/deflected_hit.json":
/*!****************************************!*\
  !*** ./data/sounds/deflected_hit.json ***!
  \****************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[400,10],[0,10],[500,15],[0,5],[400,10],[0,5],[400,10],[0,10],[100,10],[0,15],[200,5]]');

/***/ }),

/***/ "./data/sounds/descend_stairs.json":
/*!*****************************************!*\
  !*** ./data/sounds/descend_stairs.json ***!
  \*****************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[30,10],[0,5],[80,10],[0,10],[30,10],[0,175],[25,10],[0,5],[75,10],[0,10],[25,10],[0,175],[20,10],[0,5],[70,10],[0,10],[20,10],[0,175],[15,10],[0,5],[65,10],[0,10],[15,10],[0,175],[10,10],[0,5],[60,10],[0,10],[10,10]]');

/***/ }),

/***/ "./data/sounds/enemy_dies.json":
/*!*************************************!*\
  !*** ./data/sounds/enemy_dies.json ***!
  \*************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[20,20],[0,10],[30,20],[0,10],[25,20],[0,10],[25,20],[0,5],[40,20],[0,5],[35,20],[0,5],[45,20],[0,5],[25,20],[0,10],[35,20],[0,10],[25,20],[0,10],[30,20],[0,20],[40,10],[0,20],[35,10],[0,20],[45,10],[0,20],[25,5],[0,30],[35,5],[0,30],[20,5],[0,30],[30,5]]');

/***/ }),

/***/ "./data/sounds/enemy_hits_player.json":
/*!********************************************!*\
  !*** ./data/sounds/enemy_hits_player.json ***!
  \********************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[175,5],[0,5],[150,5],[0,5],[300,5],[0,5],[125,5],[0,5],[350,5],[0,10],[100,5],[0,10],[350,5],[0,10],[125,5],[0,10],[300,5],[0,15],[150,5],[0,15],[175,5],[0,20],[150,5],[0,20],[125,5],[0,25],[100,5],[1,25],[100,5]]');

/***/ }),

/***/ "./data/sounds/footstep.json":
/*!***********************************!*\
  !*** ./data/sounds/footstep.json ***!
  \***********************************/
/***/ ((module) => {

module.exports = JSON.parse('[[10,10],[0,5],[50,10],[0,10],[10,10],[0,15],[50,10],[0,20],[10,10]]');

/***/ }),

/***/ "./data/sounds/level_up.json":
/*!***********************************!*\
  !*** ./data/sounds/level_up.json ***!
  \***********************************/
/***/ ((module) => {

module.exports = JSON.parse('[[1000,50],[800,50],[600,50],[400,50],[200,100],[100,100],[50,150],[150,150],[250,200],[500,500]]');

/***/ }),

/***/ "./data/sounds/open_door.json":
/*!************************************!*\
  !*** ./data/sounds/open_door.json ***!
  \************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[25,40],[50,40],[75,60],[100,60],[125,80],[100,80]]');

/***/ }),

/***/ "./data/sounds/pick_up_item.json":
/*!***************************************!*\
  !*** ./data/sounds/pick_up_item.json ***!
  \***************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[50,50],[0,5],[100,50],[0,10],[200,50],[0,20],[400,50]]');

/***/ }),

/***/ "./data/sounds/player_dies.json":
/*!**************************************!*\
  !*** ./data/sounds/player_dies.json ***!
  \**************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[30,20],[0,10],[40,20],[0,10],[25,20],[0,10],[35,20],[0,5],[80,20],[0,5],[45,20],[0,5],[115,20],[0,5],[35,20],[0,10],[75,20],[0,10],[25,20],[0,10],[60,20],[0,20],[50,10],[0,20],[65,10],[0,20],[55,10],[0,20],[35,5],[0,30],[45,5],[0,30],[30,5],[0,30],[40,5]]');

/***/ }),

/***/ "./data/sounds/player_hits_enemy.json":
/*!********************************************!*\
  !*** ./data/sounds/player_hits_enemy.json ***!
  \********************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[175,5],[0,5],[150,5],[0,5],[300,5],[0,5],[125,5],[0,5],[350,5],[0,10],[100,5],[0,10],[350,5],[0,10],[125,5],[0,10],[300,5],[0,15],[150,5],[0,15],[175,5],[0,20],[150,5],[0,20],[125,5],[0,25],[100,5],[1,25],[100,5]]');

/***/ }),

/***/ "./data/sounds/use_potion.json":
/*!*************************************!*\
  !*** ./data/sounds/use_potion.json ***!
  \*************************************/
/***/ ((module) => {

module.exports = JSON.parse('[[150,50],[200,50],[250,50],[175,50],[225,50],[275,50],[200,50],[250,50],[300,50]]');

/***/ }),

/***/ "./data/sprites/bow.json":
/*!*******************************!*\
  !*** ./data/sprites/bow.json ***!
  \*******************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"bow","patterns":["${sprite}_${activity}_${direction}_${number}_B","${sprite}_${activity}_${direction}_${number}"],"animations":{"shooting":{"frames":[{"activity":"attacking","number":"2"}]}}}');

/***/ }),

/***/ "./data/sprites/helmet.json":
/*!**********************************!*\
  !*** ./data/sprites/helmet.json ***!
  \**********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"helmet","patterns":["${sprite}_${activity}_${direction}_${number}_B","${sprite}_${activity}_${direction}_${number}"],"animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"2"}]},"shooting":{"frames":[{"activity":"attacking","number":"2"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./data/sprites/mail.json":
/*!********************************!*\
  !*** ./data/sprites/mail.json ***!
  \********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"mail","patterns":["${sprite}_${activity}_${direction}_${number}_B","${sprite}_${activity}_${direction}_${number}"],"animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"2"}]},"shooting":{"frames":[{"activity":"attacking","number":"2"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./data/sprites/player.json":
/*!**********************************!*\
  !*** ./data/sprites/player.json ***!
  \**********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"player","pattern":"${sprite}_${activity}_${direction}_${number}","animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"2"}]},"shooting":{"frames":[{"activity":"attacking","number":"2"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./data/sprites/shield2.json":
/*!***********************************!*\
  !*** ./data/sprites/shield2.json ***!
  \***********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"shield2","patterns":["${sprite}_${activity}_${direction}_${number}_B","${sprite}_${activity}_${direction}_${number}"],"animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"2"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./data/sprites/snake.json":
/*!*********************************!*\
  !*** ./data/sprites/snake.json ***!
  \*********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"snake","pattern":"${sprite}_${activity}_${direction}_${number}","animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"1"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./data/sprites/sword.json":
/*!*********************************!*\
  !*** ./data/sprites/sword.json ***!
  \*********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"sword","patterns":["${sprite}_${activity}_${direction}_${number}_B","${sprite}_${activity}_${direction}_${number}"],"animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"2"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./data/sprites/zombie.json":
/*!**********************************!*\
  !*** ./data/sprites/zombie.json ***!
  \**********************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"zombie","pattern":"${sprite}_${activity}_${direction}_${number}","animations":{"standing":{"frames":[{"activity":"standing","number":"1"}]},"walking":{"frames":[{"activity":"walking","number":"1"}]},"attacking":{"frames":[{"activity":"attacking","number":"2"}]},"damaged":{"frames":[{"activity":"standing","number":"1"}]}}}');

/***/ }),

/***/ "./src/main/core/GameState.ts":
/*!************************************!*\
  !*** ./src/main/core/GameState.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");

/**
 * Global mutable state
 */
class GameState {
    constructor(playerUnit, maps) {
        this.screen = _types_types__WEBPACK_IMPORTED_MODULE_0__.GameScreen.TITLE;
        this.playerUnit = playerUnit;
        this.maps = maps;
        this.mapIndex = 0;
        this._map = null;
        this.messages = [];
        this.turn = 1;
        this.queuedAbility = null;
    }
    getMap() {
        if (!this._map) {
            throw 'Tried to retrieve map before map was loaded';
        }
        return this._map;
    }
    setMap(map) {
        this._map = map;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GameState);


/***/ }),

/***/ "./src/main/core/InputHandler.ts":
/*!***************************************!*\
  !*** ./src/main/core/InputHandler.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attachEvents": () => (/* binding */ attachEvents)
/* harmony export */ });
/* harmony import */ var _TurnHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TurnHandler */ "./src/main/core/TurnHandler.ts");
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _items_ItemUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../items/ItemUtils */ "./src/main/items/ItemUtils.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions */ "./src/main/core/actions.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _units_UnitAbilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../units/UnitAbilities */ "./src/main/units/UnitAbilities.ts");







var KeyCommand;
(function (KeyCommand) {
    KeyCommand["UP"] = "UP";
    KeyCommand["LEFT"] = "LEFT";
    KeyCommand["DOWN"] = "DOWN";
    KeyCommand["RIGHT"] = "RIGHT";
    KeyCommand["SHIFT_UP"] = "SHIFT_UP";
    KeyCommand["SHIFT_LEFT"] = "SHIFT_LEFT";
    KeyCommand["SHIFT_DOWN"] = "SHIFT_DOWN";
    KeyCommand["SHIFT_RIGHT"] = "SHIFT_RIGHT";
    KeyCommand["TAB"] = "TAB";
    KeyCommand["ENTER"] = "ENTER";
    KeyCommand["SPACEBAR"] = "SPACEBAR";
    KeyCommand["M"] = "M";
    KeyCommand["KEY_1"] = "1";
    KeyCommand["KEY_2"] = "2";
    KeyCommand["KEY_3"] = "3";
    KeyCommand["KEY_4"] = "4";
    KeyCommand["KEY_5"] = "5";
    KeyCommand["KEY_6"] = "6";
    KeyCommand["KEY_7"] = "7";
    KeyCommand["KEY_8"] = "8";
    KeyCommand["KEY_9"] = "9";
    KeyCommand["KEY_0"] = "0";
})(KeyCommand || (KeyCommand = {}));
function _mapToCommand(e) {
    switch (e.key) {
        case 'w':
        case 'W':
        case 'ArrowUp':
            return (e.shiftKey ? KeyCommand.SHIFT_UP : KeyCommand.UP);
        case 's':
        case 'S':
        case 'ArrowDown':
            return (e.shiftKey ? KeyCommand.SHIFT_DOWN : KeyCommand.DOWN);
        case 'a':
        case 'A':
        case 'ArrowLeft':
            return (e.shiftKey ? KeyCommand.SHIFT_LEFT : KeyCommand.LEFT);
        case 'd':
        case 'D':
        case 'ArrowRight':
            return (e.shiftKey ? KeyCommand.SHIFT_RIGHT : KeyCommand.RIGHT);
        case 'Tab':
            return KeyCommand.TAB;
        case 'Enter':
            return KeyCommand.ENTER;
        case ' ':
            return KeyCommand.SPACEBAR;
        case 'm':
        case 'M':
            return KeyCommand.M;
        case '1':
            return KeyCommand.KEY_1;
        case '2':
            return KeyCommand.KEY_2;
        case '3':
            return KeyCommand.KEY_3;
        case '4':
            return KeyCommand.KEY_4;
        case '5':
            return KeyCommand.KEY_5;
        case '6':
            return KeyCommand.KEY_6;
        case '7':
            return KeyCommand.KEY_7;
        case '8':
            return KeyCommand.KEY_8;
        case '9':
            return KeyCommand.KEY_9;
        case '0':
            return KeyCommand.KEY_0;
    }
    return null;
}
// global state
let BUSY = false;
function keyHandlerWrapper(e) {
    if (!BUSY) {
        BUSY = true;
        keyHandler(e)
            .then(() => { BUSY = false; });
    }
}
function keyHandler(e) {
    const command = _mapToCommand(e);
    switch (command) {
        case KeyCommand.UP:
        case KeyCommand.LEFT:
        case KeyCommand.DOWN:
        case KeyCommand.RIGHT:
        case KeyCommand.SHIFT_UP:
        case KeyCommand.SHIFT_DOWN:
        case KeyCommand.SHIFT_LEFT:
        case KeyCommand.SHIFT_RIGHT:
            return _handleArrowKey(command);
        case KeyCommand.SPACEBAR:
            return _TurnHandler__WEBPACK_IMPORTED_MODULE_0__.default.playTurn(null);
        case KeyCommand.ENTER:
            return _handleEnter();
        case KeyCommand.TAB:
            e.preventDefault();
            return _handleTab();
        case KeyCommand.M:
            return _handleMap();
        case KeyCommand.KEY_1:
        case KeyCommand.KEY_2:
        case KeyCommand.KEY_3:
        case KeyCommand.KEY_4:
        case KeyCommand.KEY_5:
        case KeyCommand.KEY_6:
        case KeyCommand.KEY_7:
        case KeyCommand.KEY_8:
        case KeyCommand.KEY_9:
        case KeyCommand.KEY_0:
            return _handleAbility(command);
        default:
    }
    return Promise.resolve();
}
function _handleArrowKey(command) {
    const { state } = jwb;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME:
            let dx;
            let dy;
            switch (command) {
                case KeyCommand.UP:
                case KeyCommand.SHIFT_UP:
                    [dx, dy] = [0, -1];
                    break;
                case KeyCommand.DOWN:
                case KeyCommand.SHIFT_DOWN:
                    [dx, dy] = [0, 1];
                    break;
                case KeyCommand.LEFT:
                case KeyCommand.SHIFT_LEFT:
                    [dx, dy] = [-1, 0];
                    break;
                case KeyCommand.RIGHT:
                case KeyCommand.SHIFT_RIGHT:
                    [dx, dy] = [1, 0];
                    break;
                default:
                    throw `Invalid direction command ${command}`;
            }
            const queuedOrder = (() => {
                switch (command) {
                    case KeyCommand.SHIFT_UP:
                    case KeyCommand.SHIFT_DOWN:
                    case KeyCommand.SHIFT_LEFT:
                    case KeyCommand.SHIFT_RIGHT:
                        return (u) => _units_UnitAbilities__WEBPACK_IMPORTED_MODULE_6__.default.SHOOT_ARROW.use(u, { dx, dy });
                    default:
                        if (!!jwb.state.queuedAbility) {
                            const ability = jwb.state.queuedAbility;
                            jwb.state.queuedAbility = null;
                            return (u) => ability.use(u, { dx, dy });
                        }
                        return (u) => _units_UnitAbilities__WEBPACK_IMPORTED_MODULE_6__.default.ATTACK.use(u, { dx, dy });
                }
            })();
            return _TurnHandler__WEBPACK_IMPORTED_MODULE_0__.default.playTurn(queuedOrder);
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
            const { inventory } = state.playerUnit;
            switch (command) {
                case KeyCommand.UP:
                case KeyCommand.SHIFT_UP:
                    inventory.previousItem();
                    break;
                case KeyCommand.DOWN:
                case KeyCommand.SHIFT_DOWN:
                    inventory.nextItem();
                    break;
                case KeyCommand.LEFT:
                case KeyCommand.SHIFT_LEFT:
                    inventory.previousCategory();
                    break;
                case KeyCommand.RIGHT:
                case KeyCommand.SHIFT_RIGHT:
                    inventory.nextCategory();
                    break;
            }
            return jwb.renderer.render();
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.TITLE:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.VICTORY:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME_OVER:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP:
            return Promise.resolve();
        default:
            throw `Invalid game screen ${state.screen}`;
    }
}
function _handleEnter() {
    const { state } = jwb;
    const { playerUnit } = state;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME: {
            const { mapIndex } = state;
            const map = state.getMap();
            const { x, y } = playerUnit;
            if (!map || (mapIndex === null)) {
                throw 'Map is not loaded!';
            }
            const item = map.getItem({ x, y });
            if (!!item) {
                (0,_items_ItemUtils__WEBPACK_IMPORTED_MODULE_2__.pickupItem)(playerUnit, item);
                map.removeItem({ x, y });
            }
            else if (map.getTile({ x, y }).type === _types_types__WEBPACK_IMPORTED_MODULE_5__.TileType.STAIRS_DOWN) {
                (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_3__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_1__.default.DESCEND_STAIRS);
                (0,_actions__WEBPACK_IMPORTED_MODULE_4__.loadMap)(mapIndex + 1);
            }
            return _TurnHandler__WEBPACK_IMPORTED_MODULE_0__.default.playTurn(null);
        }
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY: {
            const { playerUnit } = state;
            const { selectedItem } = playerUnit.inventory;
            if (!!selectedItem) {
                state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
                return (0,_items_ItemUtils__WEBPACK_IMPORTED_MODULE_2__.useItem)(playerUnit, selectedItem)
                    .then(() => jwb.renderer.render());
            }
            return Promise.resolve();
        }
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.TITLE:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
            return (0,_actions__WEBPACK_IMPORTED_MODULE_4__.startGame)();
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.VICTORY:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME_OVER:
            return (0,_actions__WEBPACK_IMPORTED_MODULE_4__.returnToTitle)();
        default:
            throw `Unknown game screen: ${state.screen}`;
    }
}
function _handleTab() {
    const { state, renderer } = jwb;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
            break;
        default:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY;
            break;
    }
    return renderer.render();
}
function _handleMap() {
    const { state, renderer } = jwb;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
            break;
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP;
            break;
        default:
            break;
    }
    return renderer.render();
}
function _handleAbility(command) {
    const { renderer } = jwb;
    const { playerUnit } = jwb.state;
    // sketchy - recall KEY_1 = '1', etc.
    // player abilities are indexed as (0 => attack, others => specials)
    const index = parseInt(command.toString());
    const ability = playerUnit.abilities[index];
    if (playerUnit.getCooldown(ability) <= 0) {
        jwb.state.queuedAbility = ability;
        return renderer.render();
    }
    else {
        console.log(`${ability.name} is on cooldown: ${playerUnit.getCooldown(_units_UnitAbilities__WEBPACK_IMPORTED_MODULE_6__.default.HEAVY_ATTACK)}`);
    }
    return Promise.resolve();
}
function attachEvents() {
    window.onkeydown = keyHandlerWrapper;
}



/***/ }),

/***/ "./src/main/core/TurnHandler.ts":
/*!**************************************!*\
  !*** ./src/main/core/TurnHandler.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/PromiseUtils */ "./src/main/utils/PromiseUtils.ts");

function playTurn(playerUnitOrder) {
    const { playerUnit } = jwb.state;
    const playerController = (playerUnit.controller);
    playerController.queuedOrder = !!playerUnitOrder ? (() => playerUnitOrder(playerUnit)) : null;
    return _update();
}
function _update() {
    const { state } = jwb;
    const { playerUnit } = state;
    const map = state.getMap();
    // make sure the player unit's update happens first
    const unitPromises = [];
    unitPromises.push(() => playerUnit.update());
    map.units.forEach(u => {
        if (u !== playerUnit) {
            unitPromises.push(() => u.update());
        }
    });
    return (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_0__.chainPromises)(unitPromises)
        .then(() => jwb.renderer.render())
        .then(() => {
        state.turn++;
        state.messages = [];
    });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    playTurn
});


/***/ }),

/***/ "./src/main/core/actions.ts":
/*!**********************************!*\
  !*** ./src/main/core/actions.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initialize": () => (/* binding */ initialize),
/* harmony export */   "loadMap": () => (/* binding */ loadMap),
/* harmony export */   "returnToTitle": () => (/* binding */ returnToTitle),
/* harmony export */   "revealTiles": () => (/* binding */ revealTiles),
/* harmony export */   "startGame": () => (/* binding */ startGame)
/* harmony export */ });
/* harmony import */ var _GameState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameState */ "./src/main/core/GameState.ts");
/* harmony import */ var _units_Unit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../units/Unit */ "./src/main/units/Unit.ts");
/* harmony import */ var _graphics_SpriteRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graphics/SpriteRenderer */ "./src/main/graphics/SpriteRenderer.ts");
/* harmony import */ var _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../maps/MapFactory */ "./src/main/maps/MapFactory.ts");
/* harmony import */ var _units_UnitClasses__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../units/UnitClasses */ "./src/main/units/UnitClasses.ts");
/* harmony import */ var _sounds_Music__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../sounds/Music */ "./src/main/sounds/Music.ts");
/* harmony import */ var _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../maps/TileSets */ "./src/main/maps/TileSets.ts");
/* harmony import */ var _InputHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./InputHandler */ "./src/main/core/InputHandler.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");










/*
 * This file defines functions that will be exported to the "global namespace" (window.jwb.*).
 */
function loadMap(index) {
    const { state } = jwb;
    if (index >= state.maps.length) {
        _sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.stop();
        jwb.state.screen = _types_types__WEBPACK_IMPORTED_MODULE_8__.GameScreen.VICTORY;
    }
    else {
        state.mapIndex = index;
        // TODO - this isn't memoized
        const mapBuilder = state.maps[index]();
        state.setMap(mapBuilder.build());
    }
}
function initialize() {
    // @ts-ignore
    window.jwb = window.jwb || {};
    jwb.renderer = new _graphics_SpriteRenderer__WEBPACK_IMPORTED_MODULE_2__.default();
    (0,_InputHandler__WEBPACK_IMPORTED_MODULE_7__.attachEvents)();
    _initState();
    _sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.TITLE_THEME);
    return jwb.renderer.render();
}
function _initState() {
    const playerUnit = new _units_Unit__WEBPACK_IMPORTED_MODULE_1__.default(_units_UnitClasses__WEBPACK_IMPORTED_MODULE_4__.default.PLAYER, 'player', 1, { x: 0, y: 0 });
    jwb.state = new _GameState__WEBPACK_IMPORTED_MODULE_0__.default(playerUnit, [
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.ROOMS_AND_CORRIDORS, _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__.default.DUNGEON, 1, 32, 24, 10, 5),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.ROOMS_AND_CORRIDORS, _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__.default.DUNGEON, 2, 32, 24, 11, 4),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.ROOMS_AND_CORRIDORS, _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__.default.DUNGEON, 3, 32, 24, 12, 3),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.BLOB, _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__.default.CAVE, 4, 34, 25, 12, 3),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.BLOB, _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__.default.CAVE, 5, 36, 26, 13, 3),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_3__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.BLOB, _maps_TileSets__WEBPACK_IMPORTED_MODULE_6__.default.CAVE, 6, 38, 27, 14, 3)
    ]);
}
function startGame() {
    loadMap(0);
    _sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.stop();
    // Music.playSuite(randChoice([SUITE_1, SUITE_2, SUITE_3]));
    return jwb.renderer.render();
}
function returnToTitle() {
    _initState(); // will set state.screen = TITLE
    _sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.stop();
    _sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_5__.default.TITLE_THEME);
    return jwb.renderer.render();
}
/**
 * Add any tiles the player can currently see to the map's revealed tiles list.
 */
function revealTiles() {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    map.rooms.forEach(room => {
        if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__.contains)(room, playerUnit)) {
            for (let y = room.top; y < room.top + room.height; y++) {
                for (let x = room.left; x < room.left + room.width; x++) {
                    if (!(0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__.isTileRevealed)({ x, y })) {
                        map.revealedTiles.push({ x, y });
                    }
                }
            }
        }
    });
    const radius = 2;
    for (let y = playerUnit.y - radius; y <= playerUnit.y + radius; y++) {
        for (let x = playerUnit.x - radius; x <= playerUnit.x + radius; x++) {
            if (!(0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__.isTileRevealed)({ x, y })) {
                map.revealedTiles.push({ x, y });
            }
        }
    }
}



/***/ }),

/***/ "./src/main/core/debug.ts":
/*!********************************!*\
  !*** ./src/main/core/debug.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initDebug": () => (/* binding */ initDebug),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/*
 * This file defines additional functions that will be exported to the "global namespace" (window.jwb.*)
 * that are only nitended for debugging purposes.
 */

function revealMap() {
    jwb.DEBUG = true;
    jwb.renderer.render();
}
function killEnemies() {
    const map = jwb.state.getMap();
    map.units = map.units.filter(u => u === jwb.state.playerUnit);
    jwb.renderer.render();
}
function killPlayer() {
    const map = jwb.state.getMap();
    const playerUnit = map.units.filter(u => u === jwb.state.playerUnit)[0];
    playerUnit.takeDamage(playerUnit.life);
    jwb.renderer.render();
}
function renderMinimap() {
    jwb.state.screen = _types_types__WEBPACK_IMPORTED_MODULE_0__.GameScreen.MINIMAP;
}
function initDebug() {
    // @ts-ignore
    window.jwb = window.jwb || {};
    jwb.debug = jwb.debug || {
        revealMap,
        killEnemies,
        killPlayer
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ initDebug });


/***/ }),

/***/ "./src/main/graphics/FontRenderer.ts":
/*!*******************************************!*\
  !*** ./src/main/graphics/FontRenderer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Fonts": () => (/* binding */ Fonts)
/* harmony export */ });
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/Colors */ "./src/main/types/Colors.ts");


// Fonts are partial ASCII table consisting of the "printable characters", 32 to 126
const MIN_CHARACTER_CODE = 32; // ' '
const MAX_CHARACTER_CODE = 126; // '~'
const NUM_CHARACTERS = MAX_CHARACTER_CODE - MIN_CHARACTER_CODE + 1;
const DEFAULT_CHAR = ' ';
const CHARACTERS = (() => {
    const characters = [];
    for (let c = MIN_CHARACTER_CODE; c <= MAX_CHARACTER_CODE; c++) {
        characters.push(String.fromCodePoint(c));
    }
    return characters;
})();
const Fonts = {
    PERFECT_DOS_VGA: {
        name: 'PERFECT_DOS_VGA',
        src: 'dos_perfect_vga_9x15_2',
        width: 9,
        height: 15
    }
};
class FontRenderer {
    constructor() {
        this._loadedFonts = {};
        this._imageMemos = {};
    }
    render(text, font, color) {
        const key = this._getMemoKey(text, font, color);
        if (!!this._imageMemos[key]) {
            return Promise.resolve(this._imageMemos[key]);
        }
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = text.length * font.width;
        canvas.height = font.height;
        return this._loadFont(font)
            .then(fontInstance => {
            for (let i = 0; i < text.length; i++) {
                const c = text.charAt(i);
                const x = i * font.width;
                const imageBitmap = fontInstance.imageMap[c] || fontInstance.imageMap[DEFAULT_CHAR]; // TODO hacky placeholder
                context.drawImage(imageBitmap, x, 0, font.width, font.height);
            }
            return Promise.resolve();
        })
            .then(() => Promise.resolve(context.getImageData(0, 0, canvas.width, canvas.height)))
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.replaceColors)(imageData, { [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK]: color }))
            .then(imageData => createImageBitmap(imageData))
            .then(imageBitmap => { this._imageMemos[key] = imageBitmap; return imageBitmap; });
    }
    _loadFont(definition) {
        if (this._loadedFonts[definition.name]) {
            return Promise.resolve(this._loadedFonts[definition.name]);
        }
        const width = NUM_CHARACTERS * definition.width;
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.loadImage)(`fonts/${definition.src}`)
            .then(imageData => createImageBitmap(imageData))
            .then(imageBitmap => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = definition.height;
            const context = canvas.getContext('2d');
            context.drawImage(imageBitmap, 0, 0);
            const imageMap = {};
            const promises = [];
            CHARACTERS.forEach(c => {
                promises.push(this._getCharacterData(definition, context, c.charCodeAt(0))
                    .then(imageData => createImageBitmap(imageData))
                    .then(imageBitmap => {
                    imageMap[c] = imageBitmap;
                }));
            });
            return Promise.all(promises)
                .then(() => {
                const fontInstance = Object.assign(Object.assign({}, definition), { imageMap });
                this._loadedFonts[definition.name] = fontInstance;
                return fontInstance;
            });
        });
    }
    _getCharacterData(definition, context, char) {
        const offset = this._getCharOffset(char);
        const imageData = context.getImageData(offset * definition.width, 0, definition.width, definition.height);
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.applyTransparentColor)(imageData, _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.WHITE);
    }
    _getCharOffset(char) {
        if (char >= MIN_CHARACTER_CODE && char <= MAX_CHARACTER_CODE) {
            return char - MIN_CHARACTER_CODE;
        }
        throw `invalid character code ${char}`;
    }
    _getMemoKey(text, font, color) {
        return `${font.name}_${color}_${text}`;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FontRenderer);



/***/ }),

/***/ "./src/main/graphics/ImageSupplier.ts":
/*!********************************************!*\
  !*** ./src/main/graphics/ImageSupplier.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/PromiseUtils */ "./src/main/utils/PromiseUtils.ts");


class ImageSupplier {
    /**
     * @param effects A list of custom transformations to be applied to the image, in order
     */
    constructor(filename, transparentColor, paletteSwaps = {}, effects = []) {
        const filenames = (Array.isArray(filename) ? filename : [filename]);
        this._image = this._loadFirst(filenames)
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.applyTransparentColor)(imageData, transparentColor))
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.replaceColors)(imageData, paletteSwaps))
            // @ts-ignore
            .then(imageData => (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__.chainPromises)(effects, imageData))
            .then(imageData => createImageBitmap(imageData));
    }
    get() {
        return this._image;
    }
    _loadFirst(filenames) {
        const promises = filenames.map(filename => this._loadOptional(filename));
        return Promise.all(promises)
            .then(results => {
            const imageData = results.filter(p => !!p)[0];
            if (!imageData) {
                throw `Failed to load images: ${filenames}`;
            }
            return imageData;
        });
    }
    _loadOptional(filename) {
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.loadImage)(filename)
            .catch(e => null);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageSupplier);


/***/ }),

/***/ "./src/main/graphics/ImageUtils.ts":
/*!*****************************************!*\
  !*** ./src/main/graphics/ImageUtils.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadImage": () => (/* binding */ loadImage),
/* harmony export */   "applyTransparentColor": () => (/* binding */ applyTransparentColor),
/* harmony export */   "replaceColors": () => (/* binding */ replaceColors),
/* harmony export */   "replaceAll": () => (/* binding */ replaceAll),
/* harmony export */   "hex2rgb": () => (/* binding */ hex2rgb)
/* harmony export */ });
function loadImage(filename) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.style.display = 'none';
        const img = document.createElement('img');
        img.addEventListener('load', () => {
            canvas.width = img.width;
            canvas.height = img.height;
            const context = canvas.getContext('2d');
            if (!context) {
                throw 'Couldn\'t get rendering context!';
            }
            context.drawImage(img, 0, 0);
            const imageData = context.getImageData(0, 0, img.width, img.height);
            if (img.parentElement) {
                img.parentElement.removeChild(img);
            }
            if (canvas.parentElement) {
                canvas.parentElement.removeChild(canvas);
            }
            resolve(imageData);
        });
        img.style.display = 'none';
        img.onerror = () => {
            reject(`Failed to load image ${img.src}`);
        };
        img.src = `dist/png/${filename}.png`;
    });
}
function applyTransparentColor(imageData, transparentColor) {
    return new Promise(resolve => {
        const [tr, tg, tb] = hex2rgb(transparentColor);
        const array = new Uint8ClampedArray(imageData.data.length);
        for (let i = 0; i < imageData.data.length; i += 4) {
            // @ts-ignore
            const [r, g, b, a] = imageData.data.slice(i, i + 4);
            array[i] = r;
            array[i + 1] = g;
            array[i + 2] = b;
            if (r === tr && g === tg && b === tb) {
                array[i + 3] = 0;
            }
            else {
                array[i + 3] = a;
            }
        }
        resolve(new ImageData(array, imageData.width, imageData.height));
    });
}
function replaceColors(imageData, colorMap) {
    return new Promise(resolve => {
        if (!colorMap) {
            resolve(imageData);
        }
        const array = new Uint8ClampedArray(imageData.data.length);
        const entries = Object.entries(colorMap);
        const srcRGB = {};
        const destRGB = {};
        entries.forEach(([srcColor, destColor]) => {
            srcRGB[srcColor] = hex2rgb(srcColor);
            destRGB[destColor] = hex2rgb(destColor);
        });
        for (let i = 0; i < imageData.data.length; i += 4) {
            // @ts-ignore
            const [r, g, b, a] = imageData.data.slice(i, i + 4);
            array[i] = r;
            array[i + 1] = g;
            array[i + 2] = b;
            array[i + 3] = a;
            for (let j = 0; j < entries.length; j++) {
                const [srcColor, destColor] = entries[j];
                const [sr, sg, sb] = srcRGB[srcColor];
                const [dr, dg, db] = destRGB[destColor];
                if (r === sr && g === sg && b === sb) {
                    array[i] = dr;
                    array[i + 1] = dg;
                    array[i + 2] = db;
                    break;
                }
            }
        }
        resolve(new ImageData(array, imageData.width, imageData.height));
    });
}
/**
 * Replace all non-transparent colors with the specified `color`.
 */
function replaceAll(imageData, color) {
    return new Promise(resolve => {
        const [dr, dg, db] = hex2rgb(color);
        const array = new Uint8ClampedArray(imageData.data.length);
        for (let i = 0; i < imageData.data.length; i += 4) {
            // @ts-ignore
            const [r, g, b, a] = imageData.data.slice(i, i + 4);
            array[i] = r;
            array[i + 1] = g;
            array[i + 2] = b;
            array[i + 3] = a;
            if (a > 0) {
                array[i] = dr;
                array[i + 1] = dg;
                array[i + 2] = db;
            }
        }
        resolve(new ImageData(array, imageData.width, imageData.height));
    });
}
/**
 * Convert a hex string, e.g. '#00c0ff', to its equivalent RGB values, e.g. (0, 192, 255).
 * This implementation relies on the browser automatically doing this conversion when
 * an element's `backgroundColor` value is set.
 */
function hex2rgb(hex) {
    const div = document.createElement('div');
    div.style.backgroundColor = hex;
    // @ts-ignore
    return div.style.backgroundColor
        .split(/[(),]/)
        .map(c => parseInt(c))
        .filter(c => c != null && !isNaN(c));
}



/***/ }),

/***/ "./src/main/graphics/MinimapRenderer.ts":
/*!**********************************************!*\
  !*** ./src/main/graphics/MinimapRenderer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SpriteRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpriteRenderer */ "./src/main/graphics/SpriteRenderer.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");




class MinimapRenderer {
    constructor() {
        this._canvas = document.createElement('canvas');
        this._context = this._canvas.getContext('2d');
        this._canvas.width = _SpriteRenderer__WEBPACK_IMPORTED_MODULE_0__.default.SCREEN_WIDTH;
        this._canvas.height = _SpriteRenderer__WEBPACK_IMPORTED_MODULE_0__.default.SCREEN_HEIGHT;
        this._context.imageSmoothingEnabled = false;
    }
    render() {
        this._context.fillStyle = _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK;
        this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);
        const map = jwb.state.getMap();
        const m = Math.floor(Math.min(this._canvas.width / map.width, this._canvas.height / map.height));
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                let color;
                if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.isTileRevealed)({ x, y })) {
                    const tileType = map.getTile({ x, y }).type;
                    switch (tileType) {
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.FLOOR:
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.FLOOR_HALL:
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.STAIRS_DOWN:
                            color = _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY;
                            break;
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.WALL:
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.WALL_HALL:
                            color = _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY;
                            break;
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.NONE:
                        case _types_types__WEBPACK_IMPORTED_MODULE_2__.TileType.WALL_TOP:
                        default:
                            color = _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK;
                            break;
                    }
                    if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)(jwb.state.playerUnit, { x, y })) {
                        color = _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.RED;
                    }
                }
                else {
                    color = _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK;
                }
                this._context.fillStyle = color;
                this._context.fillRect(x * m, y * m, m, m);
            }
        }
        const imageData = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
        return createImageBitmap(imageData);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MinimapRenderer);


/***/ }),

/***/ "./src/main/graphics/SpriteRenderer.ts":
/*!*********************************************!*\
  !*** ./src/main/graphics/SpriteRenderer.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _MinimapRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MinimapRenderer */ "./src/main/graphics/MinimapRenderer.ts");
/* harmony import */ var _FontRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FontRenderer */ "./src/main/graphics/FontRenderer.ts");
/* harmony import */ var _utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/PromiseUtils */ "./src/main/utils/PromiseUtils.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _core_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/actions */ "./src/main/core/actions.ts");
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ImageUtils */ "./src/main/graphics/ImageUtils.ts");








const TILE_WIDTH = 32;
const TILE_HEIGHT = 24;
const WIDTH = 20; // in tiles
const HEIGHT = 15; // in tiles
const SCREEN_WIDTH = 640;
const SCREEN_HEIGHT = 360;
const HUD_HEIGHT = 3 * TILE_HEIGHT;
const HUD_LEFT_WIDTH = 5 * TILE_WIDTH;
const HUD_RIGHT_WIDTH = 5 * TILE_WIDTH;
const HUD_MARGIN = 5;
const HUD_BORDER_MARGIN = 3;
const INVENTORY_LEFT = 2 * TILE_WIDTH;
const INVENTORY_TOP = 2 * TILE_HEIGHT;
const INVENTORY_WIDTH = 16 * TILE_WIDTH;
const INVENTORY_HEIGHT = 11 * TILE_HEIGHT;
const INVENTORY_MARGIN = 12;
const ABILITIES_PANEL_HEIGHT = 48;
const ABILITIES_OUTER_MARGIN = 13;
const ABILITIES_INNER_MARGIN = 10;
const ABILITY_ICON_WIDTH = 20;
const ABILITIES_Y_MARGIN = 4;
const LINE_HEIGHT = 16;
const GAME_OVER_FILENAME = 'gameover';
const TITLE_FILENAME = 'title';
const VICTORY_FILENAME = 'victory';
const HUD_FILENAME = 'HUD2';
const INVENTORY_BACKGROUND_FILENAME = 'inventory_background';
const SHADOW_FILENAME = 'shadow';
class SpriteRenderer {
    constructor() {
        this._container = document.getElementById('container');
        this._container.innerHTML = '';
        this._bufferCanvas = document.createElement('canvas');
        this._bufferCanvas.width = WIDTH * TILE_WIDTH;
        this._bufferCanvas.height = HEIGHT * TILE_HEIGHT;
        this._bufferContext = this._bufferCanvas.getContext('2d');
        this._bufferContext.imageSmoothingEnabled = false;
        this._fontRenderer = new _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.default();
        this._canvas = document.createElement('canvas');
        this._canvas.width = WIDTH * TILE_WIDTH;
        this._canvas.height = HEIGHT * TILE_HEIGHT;
        this._context = this._canvas.getContext('2d');
        this._bufferContext.imageSmoothingEnabled = false;
        this._container.appendChild(this._canvas);
    }
    render() {
        return this._renderScreen()
            .then(() => this._renderBuffer());
    }
    _renderScreen() {
        const { screen } = jwb.state;
        switch (screen) {
            case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.TITLE:
                return this._renderSplashScreen(TITLE_FILENAME, 'PRESS ENTER TO BEGIN');
            case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME:
                return this._renderGameScreen();
            case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
                return this._renderGameScreen()
                    .then(() => this._renderInventory());
            case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.VICTORY:
                return this._renderSplashScreen(VICTORY_FILENAME, 'PRESS ENTER TO PLAY AGAIN');
            case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME_OVER:
                return this._renderSplashScreen(GAME_OVER_FILENAME, 'PRESS ENTER TO PLAY AGAIN');
            case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP:
                return this._renderMinimap();
            default:
                throw `Invalid screen ${screen}`;
        }
    }
    _renderBuffer() {
        return createImageBitmap(this._bufferContext.getImageData(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT))
            .then(imageBitmap => this._context.drawImage(imageBitmap, 0, 0));
    }
    _renderGameScreen() {
        (0,_core_actions__WEBPACK_IMPORTED_MODULE_6__.revealTiles)();
        this._bufferContext.fillStyle = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
        this._bufferContext.fillRect(0, 0, this._bufferCanvas.width, this._bufferCanvas.height);
        // can't pass direct references to the functions because `this` won't be defined
        return (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_3__.chainPromises)([
            () => this._renderTiles(),
            () => this._renderItems(),
            () => this._renderProjectiles(),
            () => this._renderUnits(),
            () => this._renderMessages(),
            () => this._renderHUD()
        ]);
    }
    _renderTiles() {
        const promises = [];
        const map = jwb.state.getMap();
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_4__.isTileRevealed)({ x, y })) {
                    const tile = map.getTile({ x, y });
                    if (!!tile) {
                        promises.push(this._renderElement(tile, { x, y }));
                    }
                }
            }
        }
        return Promise.all(promises);
    }
    _renderItems() {
        const map = jwb.state.getMap();
        const promises = [];
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_4__.isTileRevealed)({ x, y })) {
                    const item = map.getItem({ x, y });
                    if (!!item) {
                        promises.push(this._drawEllipse({ x, y }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY)
                            .then(() => this._renderElement(item, { x, y })));
                    }
                }
            }
        }
        return Promise.all(promises);
    }
    _renderProjectiles() {
        const map = jwb.state.getMap();
        const promises = [];
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_4__.isTileRevealed)({ x, y })) {
                    const projectile = map.projectiles
                        .filter(p => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_4__.coordinatesEquals)(p, { x, y }))[0];
                    if (!!projectile) {
                        promises.push(this._renderElement(projectile, { x, y }));
                    }
                }
            }
        }
        return Promise.all(promises);
    }
    _renderUnits() {
        const { playerUnit } = jwb.state;
        const map = jwb.state.getMap();
        const promises = [];
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_4__.isTileRevealed)({ x, y })) {
                    const unit = map.getUnit({ x, y });
                    if (!!unit) {
                        let shadowColor;
                        if (unit === playerUnit) {
                            shadowColor = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.GREEN;
                        }
                        else {
                            shadowColor = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY;
                        }
                        promises.push(() => this._drawEllipse({ x, y }, shadowColor));
                        promises.push(() => this._renderElement(unit, { x, y }));
                        unit.equipment.getValues()
                            .map(item => () => this._renderElement(item, { x, y }))
                            .forEach(promise => promises.push(promise));
                    }
                }
            }
        }
        return (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_3__.chainPromises)(promises);
    }
    /**
     * TODO memoize
     * @param color (in hex form)
     */
    _drawEllipse({ x, y }, color) {
        const { x: left, y: top } = this._gridToPixel({ x, y });
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.loadImage)(SHADOW_FILENAME)
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.applyTransparentColor)(imageData, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE))
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.replaceColors)(imageData, { [_types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.BLACK]: color }))
            .then(createImageBitmap)
            .then(imageBitmap => {
            this._bufferContext.drawImage(imageBitmap, left, top);
        });
    }
    _renderInventory() {
        const { playerUnit } = jwb.state;
        const { inventory } = playerUnit;
        const { _bufferCanvas, _bufferContext } = this;
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.loadImage)(INVENTORY_BACKGROUND_FILENAME)
            .then(createImageBitmap)
            .then(imageBitmap => this._bufferContext.drawImage(imageBitmap, INVENTORY_LEFT, INVENTORY_TOP, INVENTORY_WIDTH, INVENTORY_HEIGHT))
            .then(() => {
            // draw equipment
            const equipmentLeft = INVENTORY_LEFT + INVENTORY_MARGIN;
            const itemsLeft = (_bufferCanvas.width + INVENTORY_MARGIN) / 2;
            const promises = [];
            promises.push(this._drawText('EQUIPMENT', _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: _bufferCanvas.width / 4, y: INVENTORY_TOP + INVENTORY_MARGIN }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
            promises.push(this._drawText('INVENTORY', _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: _bufferCanvas.width * 3 / 4, y: INVENTORY_TOP + INVENTORY_MARGIN }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
            // draw equipment items
            // for now, just display them all in one list
            let y = INVENTORY_TOP + 64;
            playerUnit.equipment.getEntries().forEach(([slot, equipment]) => {
                promises.push(this._drawText(`${slot} - ${equipment.name}`, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: equipmentLeft, y }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left'));
                y += LINE_HEIGHT;
            });
            // draw inventory categories
            const inventoryCategories = Object.values(_types_types__WEBPACK_IMPORTED_MODULE_5__.ItemCategory);
            const categoryWidth = 60;
            const xOffset = 4;
            for (let i = 0; i < inventoryCategories.length; i++) {
                const x = itemsLeft + i * categoryWidth + (categoryWidth / 2) + xOffset;
                const top = INVENTORY_TOP + 40;
                promises.push(this._drawText(inventoryCategories[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x, y: top }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
                if (inventoryCategories[i] === inventory.selectedCategory) {
                    _bufferContext.fillStyle = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
                    _bufferContext.fillRect(x - (categoryWidth / 2) + 4, INVENTORY_TOP + 54, categoryWidth - 8, 1);
                }
            }
            // draw inventory items
            if (inventory.selectedCategory) {
                const items = inventory.get(inventory.selectedCategory);
                const x = itemsLeft + 8;
                for (let i = 0; i < items.length; i++) {
                    const y = INVENTORY_TOP + 64 + LINE_HEIGHT * i;
                    let color;
                    if (items[i] === inventory.selectedItem) {
                        color = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.YELLOW;
                    }
                    else {
                        color = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
                    }
                    promises.push(this._drawText(items[i].name, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x, y }, color, 'left'));
                }
            }
            return Promise.all(promises);
        });
    }
    _isPixelOnScreen({ x, y }) {
        return ((x >= -TILE_WIDTH) &&
            (x <= SCREEN_WIDTH + TILE_WIDTH) &&
            (y >= -TILE_HEIGHT) &&
            (y <= SCREEN_HEIGHT + TILE_HEIGHT));
    }
    _renderElement(element, { x, y }) {
        const pixel = this._gridToPixel({ x, y });
        if (this._isPixelOnScreen(pixel)) {
            const { sprite } = element;
            if (!!sprite) {
                return this._drawSprite(sprite, pixel);
            }
        }
        return Promise.resolve();
    }
    _drawSprite(sprite, { x, y }) {
        return sprite.getImage()
            .then(image => {
            if (image) {
                this._bufferContext.drawImage(image, x + sprite.dx, y + sprite.dy);
            }
        });
    }
    _renderMessages() {
        const { _bufferContext } = this;
        const { messages } = jwb.state;
        _bufferContext.fillStyle = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
        _bufferContext.strokeStyle = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
        const left = 0;
        const top = 0;
        const promises = [];
        for (let i = 0; i < messages.length; i++) {
            let y = top + (LINE_HEIGHT * i);
            _bufferContext.fillStyle = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
            _bufferContext.fillRect(left, y, SCREEN_WIDTH, LINE_HEIGHT);
            promises.push(this._drawText(messages[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left, y }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left'));
        }
        return Promise.all(promises);
    }
    _renderHUD() {
        return this._renderHUDFrame()
            .then(() => Promise.all([
            this._renderHUDLeftPanel(),
            this._renderHUDMiddlePanel(),
            this._renderHUDRightPanel(),
        ]));
    }
    _renderHUDFrame() {
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.loadImage)(HUD_FILENAME)
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.applyTransparentColor)(imageData, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE))
            .then(createImageBitmap)
            .then(imageBitmap => this._bufferContext.drawImage(imageBitmap, 0, SCREEN_HEIGHT - HUD_HEIGHT));
    }
    /**
     * Renders the bottom-left area of the screen, showing information about the player
     */
    _renderHUDLeftPanel() {
        const { playerUnit } = jwb.state;
        const lines = [
            playerUnit.name,
            `Level ${playerUnit.level}`,
            `Life: ${playerUnit.life}/${playerUnit.maxLife}`,
            `Damage: ${playerUnit.getDamage()}`,
        ];
        const left = HUD_MARGIN;
        const top = SCREEN_HEIGHT - HUD_HEIGHT + HUD_MARGIN;
        const promises = [];
        for (let i = 0; i < lines.length; i++) {
            let y = top + (LINE_HEIGHT * i);
            promises.push(this._drawText(lines[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left, y }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left'));
        }
        return Promise.all(promises);
    }
    _renderHUDMiddlePanel() {
        let left = HUD_LEFT_WIDTH + ABILITIES_OUTER_MARGIN;
        const top = SCREEN_HEIGHT - ABILITIES_PANEL_HEIGHT + HUD_BORDER_MARGIN + ABILITIES_Y_MARGIN;
        let { playerUnit } = jwb.state;
        const promises = [];
        let keyNumber = 1;
        for (let i = 0; i < playerUnit.abilities.length; i++) {
            const ability = playerUnit.abilities[i];
            if (!!ability.icon) {
                promises.push(this._renderAbility(ability, left, top));
                promises.push(this._drawText(`${keyNumber}`, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left + 10, y: top + 24 }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
                left += ABILITIES_INNER_MARGIN + ABILITY_ICON_WIDTH;
                keyNumber++;
            }
        }
        return Promise.all(promises);
    }
    _renderHUDRightPanel() {
        const { mapIndex, playerUnit, turn } = jwb.state;
        const left = SCREEN_WIDTH - HUD_RIGHT_WIDTH + HUD_MARGIN;
        const top = SCREEN_HEIGHT - HUD_HEIGHT + HUD_MARGIN;
        const lines = [
            `Turn: ${turn}`,
            `Floor: ${(mapIndex || 0) + 1}`,
        ];
        const experienceToNextLevel = playerUnit.experienceToNextLevel();
        if (experienceToNextLevel !== null) {
            lines.push(`Experience: ${playerUnit.experience}/${experienceToNextLevel}`);
        }
        const promises = [];
        for (let i = 0; i < lines.length; i++) {
            let y = top + (LINE_HEIGHT * i);
            promises.push(this._drawText(lines[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left, y }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left'));
        }
        return Promise.all(promises);
    }
    /**
     * @return the top left pixel
     */
    _gridToPixel({ x, y }) {
        const { playerUnit } = jwb.state;
        return {
            x: ((x - playerUnit.x) * TILE_WIDTH) + (SCREEN_WIDTH - TILE_WIDTH) / 2,
            y: ((y - playerUnit.y) * TILE_HEIGHT) + (SCREEN_HEIGHT - TILE_HEIGHT) / 2
        };
    }
    _renderSplashScreen(filename, text) {
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.loadImage)(filename)
            .then(imageData => createImageBitmap(imageData))
            .then(image => this._bufferContext.drawImage(image, 0, 0, this._bufferCanvas.width, this._bufferCanvas.height))
            .then(() => this._drawText(text, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: 320, y: 300 }, _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
    }
    _drawText(text, font, { x, y }, color, textAlign) {
        return this._fontRenderer.render(text, font, color)
            .then(imageBitmap => {
            let left;
            switch (textAlign) {
                case 'left':
                    left = x;
                    break;
                case 'center':
                    left = Math.floor(x - imageBitmap.width / 2);
                    break;
                case 'right':
                    left = x + imageBitmap.width;
                    break;
                default:
                    throw 'fux';
            }
            this._bufferContext.drawImage(imageBitmap, left, y);
            return Promise.resolve();
        });
    }
    _renderMinimap() {
        const minimapRenderer = new _MinimapRenderer__WEBPACK_IMPORTED_MODULE_1__.default();
        return minimapRenderer.render()
            .then(bitmap => this._bufferContext.drawImage(bitmap, 0, 0));
    }
    _renderAbility(ability, left, top) {
        let borderColor;
        const { queuedAbility, playerUnit } = jwb.state;
        if (queuedAbility === ability) {
            borderColor = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.GREEN;
        }
        else if (playerUnit.getCooldown(ability) === 0) {
            borderColor = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
        }
        else {
            borderColor = _types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY;
        }
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.loadImage)(`abilities/${ability.icon}`)
            .then(image => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_7__.replaceColors)(image, { [_types_Colors__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY]: borderColor }))
            .then(createImageBitmap)
            .then(image => this._bufferContext.drawImage(image, left, top))
            .then(() => { left += ABILITIES_INNER_MARGIN; });
    }
}
SpriteRenderer.SCREEN_WIDTH = SCREEN_WIDTH;
SpriteRenderer.SCREEN_HEIGHT = SCREEN_HEIGHT;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpriteRenderer);


/***/ }),

/***/ "./src/main/graphics/animations/Animations.ts":
/*!****************************************************!*\
  !*** ./src/main/graphics/animations/Animations.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "playAttackingAnimation": () => (/* binding */ playAttackingAnimation),
/* harmony export */   "playArrowAnimation": () => (/* binding */ playArrowAnimation),
/* harmony export */   "playFloorFireAnimation": () => (/* binding */ playFloorFireAnimation)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/PromiseUtils */ "./src/main/utils/PromiseUtils.ts");
/* harmony import */ var _items_ProjectileFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../items/ProjectileFactory */ "./src/main/items/ProjectileFactory.ts");



const FRAME_LENGTH = 150; // milliseconds
const PROJECTILE_FRAME_LENGTH = 50; // milliseconds
function playAttackingAnimation(source, target) {
    return _playAnimation({
        frames: [
            {
                units: [
                    { unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.ATTACKING },
                    { unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.DAMAGED }
                ],
            },
            {
                units: [
                    { unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING },
                    { unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING }
                ]
            }
        ],
        delay: FRAME_LENGTH
    });
}
function playArrowAnimation(source, direction, coordinatesList, target) {
    const frames = [];
    // first frame
    {
        const frame = {
            units: [{ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.SHOOTING }]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        }
        frames.push(frame);
    }
    // arrow movement frames
    coordinatesList.forEach(({ x, y }) => {
        const projectile = (0,_items_ProjectileFactory__WEBPACK_IMPORTED_MODULE_2__.createArrow)({ x, y }, direction);
        const frame = {
            units: [{ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.SHOOTING }],
            projectiles: [projectile]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        }
        frames.push(frame);
    });
    // last frames
    {
        const frame = {
            units: [
                { unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING }
            ]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.DAMAGED });
        }
        frames.push(frame);
    }
    {
        const frame = {
            units: [{ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING }]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        }
        frames.push(frame);
    }
    return _playAnimation({
        frames,
        delay: PROJECTILE_FRAME_LENGTH
    });
}
function playFloorFireAnimation(source, targets) {
    const frames = [];
    for (let i = 0; i < targets.length; i++) {
        const frame = [];
        frame.push({ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        for (let j = 0; j < targets.length; j++) {
            const activity = (j === i) ? _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.DAMAGED : _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING;
            frame.push({ unit: targets[j], activity });
        }
        frames.push({ units: frame });
    }
    // last frame (all standing)
    const frame = [];
    frame.push({ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
    for (let i = 0; i < targets.length; i++) {
        frame.push({ unit: targets[i], activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
    }
    frames.push({ units: frame });
    return _playAnimation({
        frames,
        delay: FRAME_LENGTH
    });
}
function _playAnimation(animation) {
    const { delay, frames } = animation;
    const promises = [];
    for (let i = 0; i < frames.length; i++) {
        const frame = frames[i];
        const map = jwb.state.getMap();
        promises.push(() => {
            if (!!frame.projectiles) {
                map.projectiles.push(...frame.projectiles);
            }
            return Promise.resolve();
        });
        const updatePromise = () => {
            const updatePromises = [];
            for (let j = 0; j < frame.units.length; j++) {
                const { unit, activity } = frame.units[j];
                unit.activity = activity;
                updatePromises.push(unit.sprite.getImage());
            }
            return Promise.all(updatePromises);
        };
        promises.push(updatePromise);
        promises.push(() => {
            return jwb.renderer.render();
        });
        if (i < (frames.length - 1)) {
            promises.push(() => {
                return (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__.wait)(delay);
            });
        }
        promises.push(() => {
            if (!!frame.projectiles) {
                frame.projectiles.forEach(projectile => map.removeProjectile(projectile));
            }
            return Promise.resolve();
        });
    }
    return (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__.chainPromises)(promises);
}



/***/ }),

/***/ "./src/main/graphics/sprites/EquipmentSprite.ts":
/*!******************************************************!*\
  !*** ./src/main/graphics/sprites/EquipmentSprite.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageSupplier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageSupplier */ "./src/main/graphics/ImageSupplier.ts");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite */ "./src/main/graphics/sprites/Sprite.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/TemplateUtils */ "./src/main/utils/TemplateUtils.ts");
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _types_Directions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../types/Directions */ "./src/main/types/Directions.ts");







function _memoize(key, valueSupplier, cache) {
    if (cache[key]) {
        return cache[key];
    }
    const value = valueSupplier(key);
    cache[key] = value;
    return value;
}
class EquipmentSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_1__.default {
    constructor(equipment, spriteConfig, paletteSwaps, spriteOffsets) {
        super(spriteOffsets);
        this._equipment = equipment;
        this._spriteConfig = spriteConfig;
        this._paletteSwaps = paletteSwaps;
        this._imageCache = {};
    }
    /**
     * NOTE: This is mostly copy-pasted from {@link UnitSprite#getImage}
     *
     * @override {@link Sprite#getImage}
     */
    getImage() {
        const unit = this._equipment.unit;
        const activity = unit.activity.toLowerCase();
        const direction = _types_Directions__WEBPACK_IMPORTED_MODULE_6__.default.toLegacyDirection(unit.direction);
        return _memoize(`${activity}_${direction}`, () => this._getImage(), this._imageCache);
    }
    _getImage() {
        const unit = this._equipment.unit;
        const spriteConfig = this._spriteConfig;
        let activity = unit.activity.toLowerCase();
        const direction = _types_Directions__WEBPACK_IMPORTED_MODULE_6__.default.toLegacyDirection(unit.direction);
        const animation = spriteConfig.animations[activity];
        if (!animation) {
            return Promise.resolve(null);
        }
        const frame = animation.frames[0];
        activity = frame.activity || activity;
        const variables = {
            sprite: spriteConfig.name,
            activity,
            direction,
            number: animation.frames[0].number
        };
        const patterns = spriteConfig.patterns || [spriteConfig.pattern];
        const filenames = patterns.map(pattern => `equipment/${spriteConfig.name}/${pattern}`)
            .map(pattern => (0,_utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_4__.fillTemplate)(pattern, variables));
        const effects = (unit.activity === _types_types__WEBPACK_IMPORTED_MODULE_3__.Activity.DAMAGED)
            ? [(img) => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_5__.replaceAll)(img, _types_Colors__WEBPACK_IMPORTED_MODULE_2__.default.WHITE)]
            : [];
        return new _ImageSupplier__WEBPACK_IMPORTED_MODULE_0__.default(filenames, _types_Colors__WEBPACK_IMPORTED_MODULE_2__.default.WHITE, this._paletteSwaps, effects).get();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EquipmentSprite);


/***/ }),

/***/ "./src/main/graphics/sprites/ProjectileSprite.ts":
/*!*******************************************************!*\
  !*** ./src/main/graphics/sprites/ProjectileSprite.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageSupplier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageSupplier */ "./src/main/graphics/ImageSupplier.ts");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite */ "./src/main/graphics/sprites/Sprite.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _types_Directions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../types/Directions */ "./src/main/types/Directions.ts");
/* harmony import */ var _utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/TemplateUtils */ "./src/main/utils/TemplateUtils.ts");





var SpriteKey;
(function (SpriteKey) {
    SpriteKey["N"] = "N";
    SpriteKey["E"] = "E";
    SpriteKey["S"] = "S";
    SpriteKey["W"] = "W";
})(SpriteKey || (SpriteKey = {}));
/**
 * Projectiles have a direction but no activity or frame numbers
 */
class ProjectileSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_1__.default {
    constructor(direction, spriteName, paletteSwaps, spriteOffsets) {
        super(spriteOffsets);
        this._spriteName = spriteName;
        this._direction = direction;
        this._paletteSwaps = paletteSwaps;
    }
    getImage() {
        const variables = {
            sprite: this._spriteName,
            direction: _types_Directions__WEBPACK_IMPORTED_MODULE_3__.default.toString(this._direction),
            number: 1
        };
        const filename = (0,_utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_4__.fillTemplate)(ProjectileSprite.TEMPLATE, variables);
        return new _ImageSupplier__WEBPACK_IMPORTED_MODULE_0__.default(filename, _types_Colors__WEBPACK_IMPORTED_MODULE_2__.default.WHITE, this._paletteSwaps).get();
    }
}
ProjectileSprite.TEMPLATE = '${sprite}/${sprite}_${direction}_${number}';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProjectileSprite);


/***/ }),

/***/ "./src/main/graphics/sprites/Sprite.ts":
/*!*********************************************!*\
  !*** ./src/main/graphics/sprites/Sprite.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Note: It's expected that a separate Sprite instance will be created
 * per entity, and frame caching will be handled... somewhere else
 */
class Sprite {
    constructor({ dx, dy }) {
        this.dx = dx;
        this.dy = dy;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sprite);


/***/ }),

/***/ "./src/main/graphics/sprites/SpriteConfig.ts":
/*!***************************************************!*\
  !*** ./src/main/graphics/sprites/SpriteConfig.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteConfigs": () => (/* binding */ SpriteConfigs)
/* harmony export */ });
/* harmony import */ var _data_sprites_bow_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/sprites/bow.json */ "./data/sprites/bow.json");
/* harmony import */ var _data_sprites_helmet_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../data/sprites/helmet.json */ "./data/sprites/helmet.json");
/* harmony import */ var _data_sprites_mail_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../data/sprites/mail.json */ "./data/sprites/mail.json");
/* harmony import */ var _data_sprites_player_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/sprites/player.json */ "./data/sprites/player.json");
/* harmony import */ var _data_sprites_shield2_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../data/sprites/shield2.json */ "./data/sprites/shield2.json");
/* harmony import */ var _data_sprites_snake_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../data/sprites/snake.json */ "./data/sprites/snake.json");
/* harmony import */ var _data_sprites_sword_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../data/sprites/sword.json */ "./data/sprites/sword.json");
/* harmony import */ var _data_sprites_zombie_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../data/sprites/zombie.json */ "./data/sprites/zombie.json");








var SpriteName;
(function (SpriteName) {
    SpriteName["BOW"] = "BOW";
    SpriteName["HELMET"] = "HELMET";
    SpriteName["MAIL"] = "MAIL";
    SpriteName["SHIELD"] = "SHIELD";
    SpriteName["SNAKE"] = "SNAKE";
    SpriteName["SWORD"] = "SWORD";
    SpriteName["PLAYER"] = "PLAYER";
    SpriteName["ZOMBIE"] = "ZOMBIE";
})(SpriteName || (SpriteName = {}));
const SpriteConfigs = {
    BOW: _data_sprites_bow_json__WEBPACK_IMPORTED_MODULE_0__,
    HELMET: _data_sprites_helmet_json__WEBPACK_IMPORTED_MODULE_1__,
    MAIL: _data_sprites_mail_json__WEBPACK_IMPORTED_MODULE_2__,
    SHIELD: _data_sprites_shield2_json__WEBPACK_IMPORTED_MODULE_4__,
    SNAKE: _data_sprites_snake_json__WEBPACK_IMPORTED_MODULE_5__,
    SWORD: _data_sprites_sword_json__WEBPACK_IMPORTED_MODULE_6__,
    PLAYER: _data_sprites_player_json__WEBPACK_IMPORTED_MODULE_3__,
    ZOMBIE: _data_sprites_zombie_json__WEBPACK_IMPORTED_MODULE_7__
};



/***/ }),

/***/ "./src/main/graphics/sprites/SpriteFactory.ts":
/*!****************************************************!*\
  !*** ./src/main/graphics/sprites/SpriteFactory.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _StaticSprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StaticSprite */ "./src/main/graphics/sprites/StaticSprite.ts");
/* harmony import */ var _UnitSprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UnitSprite */ "./src/main/graphics/sprites/UnitSprite.ts");
/* harmony import */ var _ProjectileSprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProjectileSprite */ "./src/main/graphics/sprites/ProjectileSprite.ts");
/* harmony import */ var _EquipmentSprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EquipmentSprite */ "./src/main/graphics/sprites/EquipmentSprite.ts");
/* harmony import */ var _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SpriteConfig */ "./src/main/graphics/sprites/SpriteConfig.ts");





const StaticSprites = {
    MAP_SWORD: paletteSwaps => new _StaticSprite__WEBPACK_IMPORTED_MODULE_0__.default('equipment/sword/sword_icon_small', { dx: 8, dy: 0 }, paletteSwaps),
    MAP_POTION: paletteSwaps => new _StaticSprite__WEBPACK_IMPORTED_MODULE_0__.default('potion_icon', { dx: 0, dy: -8 }, paletteSwaps),
    MAP_SCROLL: paletteSwaps => new _StaticSprite__WEBPACK_IMPORTED_MODULE_0__.default('scroll_icon', { dx: 0, dy: 0 }, paletteSwaps),
    MAP_BOW: paletteSwaps => new _StaticSprite__WEBPACK_IMPORTED_MODULE_0__.default('bow_icon', { dx: 0, dy: 0 }, paletteSwaps),
    MAP_MAIL: paletteSwaps => new _StaticSprite__WEBPACK_IMPORTED_MODULE_0__.default('equipment/mail/mail_icon_small', { dx: 8, dy: 0 }, paletteSwaps),
    MAP_HELMET: paletteSwaps => new _StaticSprite__WEBPACK_IMPORTED_MODULE_0__.default('equipment/helmet/helmet_icon_small', { dx: 8, dy: 0 }, paletteSwaps)
};
const UnitSprites = {
    PLAYER: (unit, paletteSwaps) => new _UnitSprite__WEBPACK_IMPORTED_MODULE_1__.default(unit, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.PLAYER, paletteSwaps, { dx: -4, dy: -20 }),
    GOLEM: (unit, paletteSwaps) => new _UnitSprite__WEBPACK_IMPORTED_MODULE_1__.default(unit, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.ZOMBIE, paletteSwaps, { dx: -4, dy: -20 }),
    GRUNT: (unit, paletteSwaps) => new _UnitSprite__WEBPACK_IMPORTED_MODULE_1__.default(unit, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.PLAYER, paletteSwaps, { dx: -4, dy: -20 }),
    SNAKE: (unit, paletteSwaps) => new _UnitSprite__WEBPACK_IMPORTED_MODULE_1__.default(unit, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.SNAKE, paletteSwaps, { dx: 0, dy: 0 }),
    SOLDIER: (unit, paletteSwaps) => new _UnitSprite__WEBPACK_IMPORTED_MODULE_1__.default(unit, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.PLAYER, paletteSwaps, { dx: -4, dy: -20 }),
};
// TODO - check offsets
const EquipmentSprites = {
    SWORD: (equipment, paletteSwaps) => new _EquipmentSprite__WEBPACK_IMPORTED_MODULE_3__.default(equipment, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.SWORD, paletteSwaps, { dx: -4, dy: -20 }),
    BOW: (equipment, paletteSwaps) => new _EquipmentSprite__WEBPACK_IMPORTED_MODULE_3__.default(equipment, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.BOW, paletteSwaps, { dx: -4, dy: -20 }),
    MAIL: (equipment, paletteSwaps) => new _EquipmentSprite__WEBPACK_IMPORTED_MODULE_3__.default(equipment, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.MAIL, paletteSwaps, { dx: -4, dy: -20 }),
    HELMET: (equipment, paletteSwaps) => new _EquipmentSprite__WEBPACK_IMPORTED_MODULE_3__.default(equipment, _SpriteConfig__WEBPACK_IMPORTED_MODULE_4__.SpriteConfigs.HELMET, paletteSwaps, { dx: -4, dy: -20 })
};
const ProjectileSprites = {
    ARROW: (direction, paletteSwaps) => new _ProjectileSprite__WEBPACK_IMPORTED_MODULE_2__.default(direction, 'arrow', paletteSwaps, { dx: 0, dy: -8 })
};
// the following does not work: { ...StaticSprites, ...UnitSprites }
// :(
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    MAP_SWORD: StaticSprites.MAP_SWORD,
    MAP_POTION: StaticSprites.MAP_POTION,
    MAP_SCROLL: StaticSprites.MAP_SCROLL,
    MAP_BOW: StaticSprites.MAP_BOW,
    MAP_MAIL: StaticSprites.MAP_MAIL,
    MAP_HELMET: StaticSprites.MAP_HELMET,
    PLAYER: UnitSprites.PLAYER,
    GOLEM: UnitSprites.GOLEM,
    GRUNT: UnitSprites.GRUNT,
    SNAKE: UnitSprites.SNAKE,
    SOLDIER: UnitSprites.SOLDIER,
    SWORD: EquipmentSprites.SWORD,
    BOW: EquipmentSprites.BOW,
    ARROW: ProjectileSprites.ARROW,
    MAIL: EquipmentSprites.MAIL,
    HELMET: EquipmentSprites.HELMET
});


/***/ }),

/***/ "./src/main/graphics/sprites/StaticSprite.ts":
/*!***************************************************!*\
  !*** ./src/main/graphics/sprites/StaticSprite.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./src/main/graphics/sprites/Sprite.ts");
/* harmony import */ var _ImageSupplier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageSupplier */ "./src/main/graphics/ImageSupplier.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/Colors */ "./src/main/types/Colors.ts");



class StaticSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(filename, offsets, paletteSwaps) {
        super(offsets);
        this._image = new _ImageSupplier__WEBPACK_IMPORTED_MODULE_1__.default(filename, _types_Colors__WEBPACK_IMPORTED_MODULE_2__.default.WHITE, paletteSwaps);
    }
    /**
     * @override {@link Sprite#getImage}
     */
    getImage() {
        return this._image.get();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StaticSprite);


/***/ }),

/***/ "./src/main/graphics/sprites/UnitSprite.ts":
/*!*************************************************!*\
  !*** ./src/main/graphics/sprites/UnitSprite.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageSupplier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageSupplier */ "./src/main/graphics/ImageSupplier.ts");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite */ "./src/main/graphics/sprites/Sprite.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/TemplateUtils */ "./src/main/utils/TemplateUtils.ts");
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _types_Directions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../types/Directions */ "./src/main/types/Directions.ts");







function _memoize(key, valueSupplier, cache) {
    if (cache[key]) {
        return cache[key];
    }
    const value = valueSupplier(key);
    cache[key] = value;
    return value;
}
class UnitSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_1__.default {
    constructor(unit, spriteConfig, paletteSwaps, spriteOffsets) {
        super(spriteOffsets);
        this._unit = unit;
        this._spriteConfig = spriteConfig;
        this._paletteSwaps = paletteSwaps;
        this._imageCache = {};
    }
    /**
     * @override {@link Sprite#getImage}
     */
    getImage() {
        const unit = this._unit;
        const activity = unit.activity.toLowerCase();
        const direction = _types_Directions__WEBPACK_IMPORTED_MODULE_6__.default.toLegacyDirection(unit.direction);
        return _memoize(`${activity}_${direction}`, () => this._getImage(), this._imageCache);
    }
    _getImage() {
        const unit = this._unit;
        const spriteConfig = this._spriteConfig;
        let activity = unit.activity.toLowerCase();
        const direction = _types_Directions__WEBPACK_IMPORTED_MODULE_6__.default.toLegacyDirection(unit.direction);
        const animation = spriteConfig.animations[activity];
        const frame = animation.frames[0];
        activity = frame.activity || activity;
        const variables = {
            sprite: spriteConfig.name,
            activity,
            direction,
            number: animation.frames[0].number
        };
        const patterns = spriteConfig.patterns || [spriteConfig.pattern];
        const filenames = patterns.map(pattern => `units/${spriteConfig.name}/${pattern}`)
            .map(pattern => (0,_utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_4__.fillTemplate)(pattern, variables));
        const effects = (unit.activity === _types_types__WEBPACK_IMPORTED_MODULE_3__.Activity.DAMAGED)
            ? [(img) => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_5__.replaceAll)(img, _types_Colors__WEBPACK_IMPORTED_MODULE_2__.default.WHITE)]
            : [];
        return new _ImageSupplier__WEBPACK_IMPORTED_MODULE_0__.default(filenames, _types_Colors__WEBPACK_IMPORTED_MODULE_2__.default.WHITE, this._paletteSwaps, effects).get();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnitSprite);


/***/ }),

/***/ "./src/main/items/InventoryItem.ts":
/*!*****************************************!*\
  !*** ./src/main/items/InventoryItem.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class InventoryItem {
    constructor(name, category, onUse) {
        this.name = name;
        this.category = category;
        this._onUse = (unit) => onUse(this, unit);
    }
    use(unit) {
        return this._onUse(unit);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InventoryItem);


/***/ }),

/***/ "./src/main/items/InventoryMap.ts":
/*!****************************************!*\
  !*** ./src/main/items/InventoryMap.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");

const categories = Object.values(_types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory);
/**
 * Contains information about all items held by a particular unit, grouped by category,
 * as well as data about the selected item/category in the inventory menu
 * (although this is only applicable to the player unit)
 */
class InventoryMap {
    constructor() {
        // @ts-ignore
        this._map = {};
        for (const category of categories) {
            this._map[category] = [];
        }
        this.selectedCategory = categories[0];
        this.selectedItem = null;
    }
    add(item) {
        this._map[item.category].push(item);
        if (this.selectedCategory === item.category && this.selectedItem === null) {
            this.selectedItem = item;
        }
    }
    remove(item) {
        const items = this._map[item.category];
        const index = items.indexOf(item);
        items.splice(index, 1);
        if (this.selectedItem === item) {
            this.selectedItem = items[index % items.length] || null;
        }
    }
    nextCategory() {
        const index = categories.indexOf(this.selectedCategory);
        this.selectedCategory = categories[(index + 1) % categories.length];
        this.selectedItem = this._map[this.selectedCategory][0] || null;
    }
    previousCategory() {
        const index = categories.indexOf(this.selectedCategory);
        this.selectedCategory = categories[(index - 1 + categories.length) % categories.length];
        this.selectedItem = this._map[this.selectedCategory][0] || null;
    }
    get(category) {
        return [...this._map[category]];
    }
    nextItem() {
        const items = this._map[this.selectedCategory];
        if (items.length > 0 && this.selectedItem !== null) {
            const index = items.indexOf(this.selectedItem);
            this.selectedItem = items[(index + 1) % items.length];
        }
    }
    previousItem() {
        const items = this._map[this.selectedCategory];
        if (items.length > 0 && this.selectedItem !== null) {
            const index = items.indexOf(this.selectedItem);
            this.selectedItem = items[(index - 1 + items.length) % items.length];
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InventoryMap);


/***/ }),

/***/ "./src/main/items/ItemFactory.ts":
/*!***************************************!*\
  !*** ./src/main/items/ItemFactory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _InventoryItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InventoryItem */ "./src/main/items/InventoryItem.ts");
/* harmony import */ var _MapItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MapItem */ "./src/main/items/MapItem.ts");
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");
/* harmony import */ var _utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/PromiseUtils */ "./src/main/utils/PromiseUtils.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");
/* harmony import */ var _equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./equipment/EquipmentClasses */ "./src/main/items/equipment/EquipmentClasses.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../graphics/animations/Animations */ "./src/main/graphics/animations/Animations.ts");
/* harmony import */ var _ItemUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ItemUtils */ "./src/main/items/ItemUtils.ts");











function createPotion(lifeRestored) {
    const onUse = (item, unit) => {
        return new Promise(resolve => {
            (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_8__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.USE_POTION);
            const prevLife = unit.life;
            unit.life = Math.min(unit.life + lifeRestored, unit.maxLife);
            jwb.state.messages.push(`${unit.name} used ${item.name} and gained ${(unit.life - prevLife)} life.`);
            resolve();
        });
    };
    return new _InventoryItem__WEBPACK_IMPORTED_MODULE_1__.default('Potion', _types_types__WEBPACK_IMPORTED_MODULE_7__.ItemCategory.POTION, onUse);
}
function createScrollOfFloorFire(damage) {
    const onUse = (item, unit) => {
        const map = jwb.state.getMap();
        const promises = [];
        const adjacentUnits = map.units.filter(u => {
            const dx = unit.x - u.x;
            const dy = unit.y - u.y;
            return ([-1, 0, 1].indexOf(dx) > -1)
                && ([-1, 0, 1].indexOf(dy) > -1)
                && !(dx === 0 && dy === 0);
        });
        promises.push(() => (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_9__.playFloorFireAnimation)(unit, adjacentUnits));
        adjacentUnits.forEach(u => {
            promises.push(() => u.takeDamage(damage, unit));
        });
        return (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_4__.chainPromises)(promises);
    };
    return new _InventoryItem__WEBPACK_IMPORTED_MODULE_1__.default('Scroll of Floor Fire', _types_types__WEBPACK_IMPORTED_MODULE_7__.ItemCategory.SCROLL, onUse);
}
function _createMapEquipment(equipmentClass, { x, y }) {
    const sprite = equipmentClass.mapIcon(equipmentClass.paletteSwaps);
    const inventoryItem = _createInventoryWeapon(equipmentClass);
    return new _MapItem__WEBPACK_IMPORTED_MODULE_2__.default({ x, y }, equipmentClass.char, sprite, inventoryItem);
}
function _createInventoryWeapon(equipmentClass) {
    const onUse = (item, unit) => {
        return (0,_ItemUtils__WEBPACK_IMPORTED_MODULE_10__.equipItem)(item, equipmentClass, unit);
    };
    return new _InventoryItem__WEBPACK_IMPORTED_MODULE_1__.default(equipmentClass.name, equipmentClass.itemCategory, onUse);
}
function _getItemSuppliers(level) {
    const createMapPotion = ({ x, y }) => {
        const sprite = _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_3__.default.MAP_POTION();
        const inventoryItem = createPotion(40);
        return new _MapItem__WEBPACK_IMPORTED_MODULE_2__.default({ x, y }, 'K', sprite, inventoryItem);
    };
    const createFloorFireScroll = ({ x, y }) => {
        const sprite = _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_3__.default.MAP_SCROLL();
        const inventoryItem = createScrollOfFloorFire(80);
        return new _MapItem__WEBPACK_IMPORTED_MODULE_2__.default({ x, y }, 'K', sprite, inventoryItem);
    };
    return [createMapPotion, createFloorFireScroll];
}
function _getEquipmentSuppliers(level) {
    return Object.values(_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_6__.EquipmentClasses)
        .filter(equipmentClass => level >= equipmentClass.minLevel)
        .filter(equipmentClass => level <= equipmentClass.maxLevel)
        .map(equipmentClass => ({ x, y }) => _createMapEquipment(equipmentClass, { x, y }));
}
function createRandomItem({ x, y }, level) {
    let supplier;
    if ((0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_5__.randInt)(0, 2) == 0) {
        supplier = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_5__.randChoice)(_getItemSuppliers(level));
    }
    else {
        supplier = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_5__.randChoice)(_getEquipmentSuppliers(level));
    }
    return supplier({ x, y });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    createRandomItem
});


/***/ }),

/***/ "./src/main/items/ItemUtils.ts":
/*!*************************************!*\
  !*** ./src/main/items/ItemUtils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pickupItem": () => (/* binding */ pickupItem),
/* harmony export */   "useItem": () => (/* binding */ useItem),
/* harmony export */   "equipItem": () => (/* binding */ equipItem)
/* harmony export */ });
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _equipment_Equipment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equipment/Equipment */ "./src/main/items/equipment/Equipment.ts");



function pickupItem(unit, mapItem) {
    const { state } = jwb;
    const { inventoryItem } = mapItem;
    unit.inventory.add(inventoryItem);
    state.messages.push(`Picked up a ${inventoryItem.name}.`);
    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_0__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_1__.default.PICK_UP_ITEM);
}
function useItem(unit, item) {
    return item.use(unit)
        .then(() => unit.inventory.remove(item));
}
function equipItem(item, equipmentClass, unit) {
    return new Promise(resolve => {
        const equipment = new _equipment_Equipment__WEBPACK_IMPORTED_MODULE_2__.default(equipmentClass, item);
        unit.equipment.add(equipment);
        equipment.attach(unit);
        resolve();
    });
}



/***/ }),

/***/ "./src/main/items/MapItem.ts":
/*!***********************************!*\
  !*** ./src/main/items/MapItem.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class MapItem {
    constructor({ x, y }, char, sprite, inventoryItem) {
        this.x = x;
        this.y = y;
        this.char = char;
        this.sprite = sprite;
        this.inventoryItem = inventoryItem;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapItem);


/***/ }),

/***/ "./src/main/items/ProjectileFactory.ts":
/*!*********************************************!*\
  !*** ./src/main/items/ProjectileFactory.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createArrow": () => (/* binding */ createArrow)
/* harmony export */ });
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");

function createArrow({ x, y }, direction) {
    return {
        x,
        y,
        direction,
        sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.ARROW(direction, {}),
        char: 'x'
    };
}



/***/ }),

/***/ "./src/main/items/equipment/Equipment.ts":
/*!***********************************************!*\
  !*** ./src/main/items/equipment/Equipment.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class Equipment {
    constructor(equipmentClass, inventoryItem) {
        this.name = equipmentClass.name;
        this.slot = equipmentClass.slot;
        this.inventoryItem = inventoryItem;
        this.damage = equipmentClass.damage;
        this.sprite = equipmentClass.sprite(this, equipmentClass.paletteSwaps);
    }
    attach(unit) {
        this.unit = unit;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Equipment);


/***/ }),

/***/ "./src/main/items/equipment/EquipmentClasses.ts":
/*!******************************************************!*\
  !*** ./src/main/items/equipment/EquipmentClasses.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EquipmentClasses": () => (/* binding */ EquipmentClasses)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");



const BRONZE_SWORD = {
    name: 'Bronze Sword',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.SWORD,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_SWORD,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.WEAPON,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.MELEE_WEAPON,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_BROWN
    },
    damage: 2,
    minLevel: 1,
    maxLevel: 2
};
const IRON_SWORD = {
    name: 'Iron Sword',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.SWORD,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_SWORD,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.WEAPON,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.MELEE_WEAPON,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY
    },
    damage: 4,
    minLevel: 3,
    maxLevel: 4
};
const STEEL_SWORD = {
    name: 'Steel Sword',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.SWORD,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_SWORD,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.WEAPON,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.MELEE_WEAPON,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY
    },
    damage: 6,
    minLevel: 4,
    maxLevel: 6
};
const FIRE_SWORD = {
    name: 'Fire Sword',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.SWORD,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_SWORD,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.WEAPON,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.MELEE_WEAPON,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.YELLOW,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.RED,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_RED
    },
    damage: 8,
    minLevel: 5,
    maxLevel: 6
};
const SHORT_BOW = {
    name: 'Short Bow',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.BOW,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_BOW,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.WEAPON,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.RANGED_WEAPON,
    paletteSwaps: {},
    damage: 2,
    minLevel: 2,
    maxLevel: 4
};
const LONG_BOW = {
    name: 'Long Bow',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.BOW,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_BOW,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.WEAPON,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.RANGED_WEAPON,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_RED,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.RED,
    },
    damage: 4,
    minLevel: 5,
    maxLevel: 6
};
const BRONZE_CHAIN_MAIL = {
    name: 'Bronze Chain Mail',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAIL,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_MAIL,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.ARMOR,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.CHEST,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN
    },
    minLevel: 1,
    maxLevel: 2
};
const IRON_CHAIN_MAIL = {
    name: 'Iron Chain Mail',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAIL,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_MAIL,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.ARMOR,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.CHEST,
    paletteSwaps: {},
    minLevel: 3,
    maxLevel: 6
};
const IRON_HELMET = {
    name: 'Iron Helmet',
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.HELMET,
    mapIcon: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_2__.default.MAP_HELMET,
    char: 'S',
    itemCategory: _types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory.ARMOR,
    slot: _types_types__WEBPACK_IMPORTED_MODULE_0__.EquipmentSlot.HEAD,
    paletteSwaps: {},
    minLevel: 1,
    maxLevel: 6
};
const EquipmentClasses = {
    BRONZE_SWORD,
    IRON_SWORD,
    STEEL_SWORD,
    FIRE_SWORD,
    SHORT_BOW,
    LONG_BOW,
    BRONZE_CHAIN_MAIL,
    IRON_CHAIN_MAIL,
    IRON_HELMET
};



/***/ }),

/***/ "./src/main/items/equipment/EquipmentMap.ts":
/*!**************************************************!*\
  !*** ./src/main/items/equipment/EquipmentMap.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Represent's a unit's equipment, mapped by slot.
 */
class EquipmentMap {
    constructor() {
        this._map = {};
    }
    add(item) {
        this._map[item.slot] = item;
    }
    remove(item) {
        this._map[item.slot] = undefined;
    }
    get(category) {
        return this._map[category] || null;
    }
    getEntries() {
        return [...Object.entries(this._map)];
    }
    getValues() {
        return [...Object.values(this._map)];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EquipmentMap);


/***/ }),

/***/ "./src/main/maps/MapBuilder.ts":
/*!*************************************!*\
  !*** ./src/main/maps/MapBuilder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapInstance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapInstance */ "./src/main/maps/MapInstance.ts");

class MapBuilder {
    constructor(level, width, height, tiles, rooms, playerUnitLocation, enemyUnitLocations, enemyUnitSupplier, itemLocations, itemSupplier) {
        this._level = level;
        this._width = width;
        this._height = height;
        this._tiles = tiles;
        this._rooms = rooms;
        this._playerUnitLocation = playerUnitLocation;
        this._enemyUnitLocations = enemyUnitLocations;
        this._itemLocations = itemLocations;
        this._enemyUnitSupplier = enemyUnitSupplier;
        this._itemSupplier = itemSupplier;
    }
    build() {
        const { playerUnit } = jwb.state;
        const units = [playerUnit];
        [playerUnit.x, playerUnit.y] = [this._playerUnitLocation.x, this._playerUnitLocation.y];
        units.push(...this._enemyUnitLocations.map(({ x, y }) => this._enemyUnitSupplier({ x, y }, this._level)));
        const items = this._itemLocations.map(({ x, y }) => this._itemSupplier({ x, y }, this._level));
        return new _MapInstance__WEBPACK_IMPORTED_MODULE_0__.default(this._width, this._height, this._tiles, this._rooms, units, items);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapBuilder);


/***/ }),

/***/ "./src/main/maps/MapFactory.ts":
/*!*************************************!*\
  !*** ./src/main/maps/MapFactory.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _items_ItemFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../items/ItemFactory */ "./src/main/items/ItemFactory.ts");
/* harmony import */ var _units_UnitFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../units/UnitFactory */ "./src/main/units/UnitFactory.ts");
/* harmony import */ var _generation_BlobDungeonGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generation/BlobDungeonGenerator */ "./src/main/maps/generation/BlobDungeonGenerator.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _generation_RoomCorridorDungeonGenerator2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generation/RoomCorridorDungeonGenerator2 */ "./src/main/maps/generation/RoomCorridorDungeonGenerator2.ts");





function createRandomMap(mapLayout, tileSet, level, width, height, numEnemies, numItems) {
    const dungeonGenerator = _getDungeonGenerator(mapLayout, tileSet);
    return dungeonGenerator.generateDungeon(level, width, height, numEnemies, _units_UnitFactory__WEBPACK_IMPORTED_MODULE_1__.default.createRandomEnemy, numItems, _items_ItemFactory__WEBPACK_IMPORTED_MODULE_0__.default.createRandomItem);
}
function _getDungeonGenerator(mapLayout, tileSet) {
    switch (mapLayout) {
        case _types_types__WEBPACK_IMPORTED_MODULE_3__.MapLayout.ROOMS_AND_CORRIDORS: {
            const minRoomDimension = 3;
            const maxRoomDimension = 7;
            // return new RoomCorridorDungeonGenerator(
            return new _generation_RoomCorridorDungeonGenerator2__WEBPACK_IMPORTED_MODULE_4__.default(tileSet, minRoomDimension, maxRoomDimension);
        }
        case _types_types__WEBPACK_IMPORTED_MODULE_3__.MapLayout.BLOB:
            return new _generation_BlobDungeonGenerator__WEBPACK_IMPORTED_MODULE_2__.default(tileSet);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ createRandomMap });


/***/ }),

/***/ "./src/main/maps/MapInstance.ts":
/*!**************************************!*\
  !*** ./src/main/maps/MapInstance.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");

class MapInstance {
    constructor(width, height, tiles, rooms, units, items) {
        this.width = width;
        this.height = height;
        this._tiles = tiles;
        this.rooms = rooms;
        this.units = units;
        this.items = items;
        this.projectiles = [];
        this.revealedTiles = [];
    }
    getTile({ x, y }) {
        if (x < this.width && y < this.height) {
            return (this._tiles[y] || [])[x] || _types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.NONE;
        }
        throw `Illegal coordinates ${x}, ${y}`;
    }
    getUnit({ x, y }) {
        return this.units.filter(u => u.x === x && u.y === y)[0] || null;
    }
    getItem({ x, y }) {
        return this.items.filter(i => i.x === x && i.y === y)[0] || null;
    }
    getProjectile({ x, y }) {
        return this.projectiles.filter(p => p.x === x && p.y === y)[0] || null;
    }
    contains({ x, y }) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height;
    }
    isBlocked({ x, y }) {
        if (!this.contains({ x, y })) {
            throw `(${x}, ${y}) is not on the map`;
        }
        return !!this.getUnit({ x, y }) || this.getTile({ x, y }).isBlocking;
    }
    removeUnit({ x, y }) {
        const index = this.units.findIndex(u => (u.x === x && u.y === y));
        if (index >= 0) {
            this.units.splice(index, 1);
        }
    }
    removeItem({ x, y }) {
        const index = this.items.findIndex(i => (i.x === x && i.y === y));
        if (index >= 0) {
            this.items.splice(index, 1);
        }
    }
    removeProjectile({ x, y }) {
        const index = this.projectiles.findIndex(i => (i.x === x && i.y === y));
        if (index >= 0) {
            this.projectiles.splice(index, 1);
        }
    }
    getRect() {
        return {
            left: 0,
            top: 0,
            width: this.width,
            height: this.height
        };
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapInstance);


/***/ }),

/***/ "./src/main/maps/MapUtils.ts":
/*!***********************************!*\
  !*** ./src/main/maps/MapUtils.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areAdjacent": () => (/* binding */ areAdjacent),
/* harmony export */   "civDistance": () => (/* binding */ civDistance),
/* harmony export */   "contains": () => (/* binding */ contains),
/* harmony export */   "coordinatesEquals": () => (/* binding */ coordinatesEquals),
/* harmony export */   "createTile": () => (/* binding */ createTile),
/* harmony export */   "hypotenuse": () => (/* binding */ hypotenuse),
/* harmony export */   "isAdjacent": () => (/* binding */ isAdjacent),
/* harmony export */   "isBlocking": () => (/* binding */ isBlocking),
/* harmony export */   "isTileRevealed": () => (/* binding */ isTileRevealed),
/* harmony export */   "manhattanDistance": () => (/* binding */ manhattanDistance),
/* harmony export */   "pickUnoccupiedLocations": () => (/* binding */ pickUnoccupiedLocations)
/* harmony export */ });
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");



/**
 * @return `numToChoose` random points from `tiles`, whose tile is in `allowedTileTypes`,
 *         which do not collide with `occupiedLocations`
 */
function pickUnoccupiedLocations(tiles, allowedTileTypes, occupiedLocations, numToChoose) {
    const unoccupiedLocations = [];
    for (let y = 0; y < tiles.length; y++) {
        for (let x = 0; x < tiles[y].length; x++) {
            if (allowedTileTypes.indexOf(tiles[y][x]) !== -1) {
                if (occupiedLocations.filter(loc => coordinatesEquals(loc, { x, y })).length === 0) {
                    unoccupiedLocations.push({ x, y });
                }
            }
        }
    }
    const chosenLocations = [];
    for (let i = 0; i < numToChoose; i++) {
        if (unoccupiedLocations.length > 0) {
            (0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_0__.sortBy)(unoccupiedLocations, ({ x, y }) => -1 * Math.min(...chosenLocations.map(loc => hypotenuse(loc, { x, y }))));
            const index = 0;
            const { x, y } = unoccupiedLocations[index];
            chosenLocations.push({ x, y });
            occupiedLocations.push({ x, y });
            unoccupiedLocations.splice(index, 1);
        }
    }
    return chosenLocations;
}
function coordinatesEquals(first, second) {
    return (first.x === second.x && first.y === second.y);
}
function contains(rect, coordinates) {
    return coordinates.x >= rect.left
        && coordinates.x < (rect.left + rect.width)
        && coordinates.y >= rect.top
        && coordinates.y < (rect.top + rect.height);
}
function manhattanDistance(first, second) {
    return Math.abs(first.x - second.x) + Math.abs(first.y - second.y);
}
function hypotenuse(first, second) {
    const dx = second.x - first.x;
    const dy = second.y - first.y;
    return Math.pow(((dx * dx) + (dy * dy)), 0.5);
}
function civDistance(first, second) {
    const dx = Math.abs(first.x - second.x);
    const dy = Math.abs(first.y - second.y);
    return Math.max(dx, dy) + Math.min(dx, dy) / 2;
}
function isAdjacent(first, second) {
    const dx = Math.abs(first.x - second.x);
    const dy = Math.abs(first.y - second.y);
    return (dx === 0 && (dy === -1 || dy === 1)) || (dy === 0 && (dx === -1 || dx === 1));
}
function isTileRevealed({ x, y }) {
    if (jwb.DEBUG) {
        return true;
    }
    return jwb.state.getMap().revealedTiles.some(tile => coordinatesEquals({ x, y }, tile));
}
function isBlocking(tileType) {
    switch (tileType) {
        case _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR:
        case _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL:
        case _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.STAIRS_DOWN:
            return false;
        default:
            return true;
    }
}
function createTile(type, tileSet) {
    return {
        type,
        sprite: (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randChoice)(tileSet[type]),
        isBlocking: isBlocking(type)
    };
}
function areAdjacent(first, second, minBorderLength) {
    // right-left
    if (first.left + first.width === second.left) {
        const top = Math.max(first.top, second.top);
        const bottom = Math.min(first.top + first.height, second.top + second.height); // exclusive
        return (bottom - top) >= minBorderLength;
    }
    // bottom-top
    if (first.top + first.height === second.top) {
        const left = Math.max(first.left, second.left);
        const right = Math.min(first.left + first.width, second.left + second.width); // exclusive
        return (right - left) >= minBorderLength;
    }
    // left-right
    if (first.left === second.left + second.width) {
        const top = Math.max(first.top, second.top);
        const bottom = Math.min(first.top + first.height, second.top + second.height); // exclusive
        return (bottom - top) >= minBorderLength;
    }
    // top-bottom
    if (first.top === second.top + second.height) {
        const left = Math.max(first.left, second.left);
        const right = Math.min(first.left + first.width, second.left + second.width); // exclusive
        return (right - left) >= minBorderLength;
    }
    return false;
}



/***/ }),

/***/ "./src/main/maps/TileSets.ts":
/*!***********************************!*\
  !*** ./src/main/maps/TileSets.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _graphics_sprites_StaticSprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graphics/sprites/StaticSprite */ "./src/main/graphics/sprites/StaticSprite.ts");


function _getTileSprite(filename) {
    return new _graphics_sprites_StaticSprite__WEBPACK_IMPORTED_MODULE_1__.default(filename, { dx: 0, dy: 0 }, {});
}
/**
 * TODO: learn to TypeScript
 */
function _mapFilenames(filenames) {
    // @ts-ignore
    const tileSet = {};
    Object.entries(filenames).forEach(([tileType, filenames]) => {
        // @ts-ignore
        tileSet[tileType] = [];
        filenames.forEach(filename => {
            const sprite = !!filename ? _getTileSprite(filename) : null;
            // @ts-ignore
            tileSet[tileType].push(sprite);
        });
    });
    return tileSet;
}
const dungeonFilenames = {
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.FLOOR]: ['dungeon/tile_floor', 'dungeon/tile_floor_2'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.FLOOR_HALL]: ['dungeon/tile_floor_hall', 'dungeon/tile_floor_hall_2'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL_TOP]: [null],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL_HALL]: ['dungeon/tile_wall_hall'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL]: ['dungeon/tile_wall'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.STAIRS_DOWN]: ['stairs_down2'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.NONE]: [null]
};
const caveFilenames = {
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.FLOOR]: ['cave/tile_floor', 'cave/tile_floor_2'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.FLOOR_HALL]: ['cave/tile_floor', 'cave/tile_floor_2'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL_TOP]: [],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL_HALL]: ['cave/tile_wall'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL]: ['cave/tile_wall'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.STAIRS_DOWN]: ['stairs_down2'],
    [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.NONE]: [null]
};
const TileSets = {
    DUNGEON: _mapFilenames(dungeonFilenames),
    CAVE: _mapFilenames(caveFilenames),
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileSets);


/***/ }),

/***/ "./src/main/maps/generation/BlobDungeonGenerator.ts":
/*!**********************************************************!*\
  !*** ./src/main/maps/generation/BlobDungeonGenerator.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DungeonGenerator */ "./src/main/maps/generation/DungeonGenerator.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");





class BlobDungeonGenerator extends _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(tileSet) {
        super(tileSet);
    }
    /**
     * Strategy:
     * Add a floor tile near the middle of the map.
     * Until the map is half-full, continue adding new tiles adjacent to existing tiles.
     * New tile placement should be random - but aim for a certain level of "snakiness",
     * where snakiness is defined as the number of tiles within N units
     * (more adjacent tiles - less snaky).
     */
    generateTiles(width, height) {
        const tiles = this._initTiles(width, height);
        this._placeInitialTile(width, height, tiles);
        const targetNumFloorTiles = this._getTargetNumFloorTiles(width * height);
        while (this._getFloorTiles(tiles).length < targetNumFloorTiles) {
            if (!this._addFloorTile(tiles)) {
                break;
            }
        }
        this._addWalls(tiles);
        return {
            tiles,
            width,
            height,
            rooms: []
        };
    }
    _initTiles(width, height) {
        const tiles = [];
        for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
                row.push(_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE);
            }
            tiles.push(row);
        }
        return tiles;
    }
    _placeInitialTile(width, height, tiles) {
        const x = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(width * 3 / 8, width * 5 / 8);
        const y = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(height * 3 / 8, height * 5 / 8);
        tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR;
    }
    _getTargetNumFloorTiles(max) {
        const minRatio = 0.4;
        const maxRatio = 0.7;
        return (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(Math.round(max * minRatio), Math.round(max * maxRatio));
    }
    _getFloorTiles(tiles) {
        const floorTiles = [];
        for (let y = 0; y < tiles.length; y++) {
            for (let x = 0; x < tiles[y].length; x++) {
                if (tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR) {
                    floorTiles.push({ x, y });
                }
            }
        }
        return floorTiles;
    }
    _getEmptyTiles(tiles) {
        const floorTiles = [];
        for (let y = 0; y < tiles.length; y++) {
            for (let x = 0; x < tiles[y].length; x++) {
                if (tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE) {
                    floorTiles.push({ x, y });
                }
            }
        }
        return floorTiles;
    }
    /**
     * @return whether a tile was successfully added
     */
    _addFloorTile(tiles) {
        const floorTiles = this._getFloorTiles(tiles);
        const candidates = this._getCandidates(tiles, floorTiles)
            .sort((0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_4__.comparing)(tile => this._getSnakeScore(tile, tiles)));
        if (candidates.length === 0) {
            return false;
        }
        // change these ratios to adjust the "snakiness"
        const minIndex = Math.floor((candidates.length - 1) * 0.6);
        const maxIndex = Math.floor((candidates.length - 1) * 0.8);
        const index = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(minIndex, maxIndex);
        const { x, y } = candidates[index];
        tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR;
        return true;
    }
    _getCandidates(tiles, floorTiles) {
        return this._getEmptyTiles(tiles)
            .filter(({ x, y }) => y > 0)
            .filter(({ x, y }) => this._isLegalWallCoordinates({ x, y }, tiles))
            .filter(({ x, y }) => floorTiles.some(floorTile => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_3__.isAdjacent)({ x, y }, floorTile)));
    }
    _isLegalWallCoordinates({ x, y }, tiles) {
        // To facilitate wall generation, disallow some specific cases:
        // 1. can't add a floor tile if there's a wall right above it, AND a floor tile right above that
        const height = tiles.length;
        const m = 3; // number of consecutive wall tiles required
        for (let n = 2; n <= m; n++) {
            if (y >= n) {
                if (this._range(y - (n - 1), y - 1).every(y2 => tiles[y2][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE)
                    && (tiles[y - n][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR)) {
                    return false;
                }
            }
            // 2. can't add a floor tile if there's a wall right below it, AND a floor tile right below that
            if (y <= (height - 1 - n)) {
                if (this._range(y + 1, y + (n - 1)).every(y2 => tiles[y2][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE)
                    && (tiles[y + n][x] == _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR)) {
                    return false;
                }
            }
            // 3. check for kitty corner floor tiles
            if (this._hasKittyCornerFloorTile({ x, y }, tiles)) {
                return false;
            }
        }
        return true;
    }
    _hasKittyCornerFloorTile({ x, y }, tiles) {
        const height = tiles.length;
        const width = tiles[0].length;
        // one tile apart vertically
        for (let [dx, dy] of [[-1, -1], [1, -1], [-1, 1], [1, 1]]) {
            const [x2, y2] = [x + dx, y + dy];
            if (x2 < 0 || x2 >= width || y2 < 0 || y2 >= height) {
                // out of bounds
            }
            else if (tiles[y2][x2] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR) {
                if (tiles[y2][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE && tiles[y][x2] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE) {
                    return true;
                }
            }
        }
        // two tiles apart vertically
        // @X        ab
        // XX        cd
        //  F        ef
        for (let [dx, dy] of [[-1, -2], [1, -2], [-1, 2], [1, 2]]) {
            const a = { x, y };
            const b = { x: x + dx, y };
            const c = { x, y: y + (dy / 2) };
            const d = { x: x + dx, y: y + (dy / 2) };
            const e = { x, y: y + dy };
            const f = { x: x + dx, y: y + dy };
            if (f.x < 0 || f.x >= width || f.y < 0 || f.y >= height) {
                // out of bounds
            }
            else {
                if (tiles[b.y][b.x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE
                    && tiles[c.y][c.x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE
                    && tiles[d.y][d.x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE
                    && tiles[f.y][f.x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR) {
                    return true;
                }
            }
        }
        return false;
    }
    _addWalls(tiles) {
        const height = tiles.length;
        const width = tiles[0].length;
        for (let y = 0; y < (height - 1); y++) {
            for (let x = 0; x < width; x++) {
                if (tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE && tiles[y + 1][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL_TOP;
                }
            }
        }
    }
    /**
     * @param end inclusive
     */
    _range(start, end) {
        const range = [];
        for (let i = start; i <= end; i++) {
            range.push(i);
        }
        return range;
    }
    /**
     * @return the number of nearby tiles
     */
    _getSnakeScore(tile, tiles) {
        let score = 0;
        const offset = 1;
        const height = tiles.length;
        const width = tiles[0].length;
        const minY = Math.max(0, tile.y - offset);
        const maxY = Math.min(tile.y + offset, height - 1);
        const minX = Math.max(0, tile.x - offset);
        const maxX = Math.min(tile.x + offset, width - 1);
        for (let y = minY; y <= maxY; y++) {
            for (let x = minX; x <= maxX; x++) {
                if ((0,_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)(tile, { x, y })) {
                    continue;
                }
                if (tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR) {
                    score++;
                }
            }
        }
        return score;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlobDungeonGenerator);


/***/ }),

/***/ "./src/main/maps/generation/DungeonGenerator.ts":
/*!******************************************************!*\
  !*** ./src/main/maps/generation/DungeonGenerator.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBuilder */ "./src/main/maps/MapBuilder.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");
/* harmony import */ var _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/Pathfinder */ "./src/main/utils/Pathfinder.ts");
/* harmony import */ var _TileEligibilityChecker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TileEligibilityChecker */ "./src/main/maps/generation/TileEligibilityChecker.ts");






class DungeonGenerator {
    constructor(tileSet) {
        this._tileSet = tileSet;
    }
    generateDungeon(level, width, height, numEnemies, enemyUnitSupplier, numItems, itemSupplier) {
        let section;
        let isValid = false;
        let iterations = 0;
        do {
            const t1 = new Date().getTime();
            section = this.generateTiles(width, height);
            isValid = this._validateSection(section);
            const t2 = new Date().getTime();
            console.log(`Generated dungeon tiles for level ${level} in ${t2 - t1} ms`);
            if (!isValid) {
                console.error(`Generated invalid tiles for level ${level}, regenerating`);
            }
            iterations++;
        } while (!isValid && (iterations < 100));
        const tileTypes = section.tiles;
        const [stairsLocation] = (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.pickUnoccupiedLocations)(tileTypes, [_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR], [], 1);
        tileTypes[stairsLocation.y][stairsLocation.x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.STAIRS_DOWN;
        const enemyUnitLocations = (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.pickUnoccupiedLocations)(tileTypes, [_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR], [stairsLocation], numEnemies);
        const [playerUnitLocation] = this._pickPlayerLocation(tileTypes, [stairsLocation, ...enemyUnitLocations]);
        const itemLocations = (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.pickUnoccupiedLocations)(tileTypes, [_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR], [stairsLocation, playerUnitLocation, ...enemyUnitLocations], numItems);
        const tiles = tileTypes.map((row) => {
            return row.map(tileType => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.createTile)(tileType, this._tileSet));
        });
        return new _MapBuilder__WEBPACK_IMPORTED_MODULE_0__.default(level, width, height, tiles, section.rooms, playerUnitLocation, enemyUnitLocations, enemyUnitSupplier, itemLocations, itemSupplier);
    }
    /**
     * Spawn the player at the tile that maximizes average distance from enemies and the level exit.
     */
    _pickPlayerLocation(tiles, blockedTiles) {
        const candidates = [];
        for (let y = 0; y < tiles.length; y++) {
            for (let x = 0; x < tiles[y].length; x++) {
                if (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.isBlocking)(tiles[y][x]) && !blockedTiles.some(tile => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)(tile, { x, y }))) {
                    const tileDistances = blockedTiles.map(blockedTile => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)({ x, y }, blockedTile));
                    candidates.push([{ x, y }, (0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_3__.average)(tileDistances)]);
                }
            }
        }
        console.assert(candidates.length > 0);
        return candidates.sort((a, b) => (b[1] - a[1]))[0];
    }
    /**
     * Verify that:
     * - all rooms can be connected
     * - wall placement is correct
     *   (all floor tiles have either another floor tile, or a wall + wall top directly above them)
     *
     * Frankly, this is a hack and it would be far better to have an algorithm which is mathematically provable
     * to generate the characteristics we want on a consistent basis.  But this is easier and should prevent regressions
     *
     * @return true if the provided `section` is valid
     */
    _validateSection(section) {
        return this._validateRoomConnectivity(section) && this._validateWallPlacement(section);
    }
    _validateRoomConnectivity(section) {
        const { rooms } = section;
        const roomCenters = rooms.map(room => ({
            x: Math.round(room.left + room.width) / 2,
            y: Math.round(room.top + room.height) / 2
        }));
        const tileChecker = new _TileEligibilityChecker__WEBPACK_IMPORTED_MODULE_5__.default();
        const unblockedTiles = [];
        for (let y = 0; y < section.height; y++) {
            for (let x = 0; x < section.width; x++) {
                if (!tileChecker.isBlocked({ x, y }, section, [])) {
                    unblockedTiles.push({ x, y });
                }
            }
        }
        const pathfinder = new _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_4__.default(() => 1);
        for (let i = 0; i < rooms.length; i++) {
            for (let j = i + 1; j < rooms.length; j++) {
                const path = pathfinder.findPath(roomCenters[i], roomCenters[j], unblockedTiles);
                if (path.length === 0) {
                    return false;
                }
            }
        }
        return true;
    }
    _validateWallPlacement(section) {
        const floorTypes = [_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR, _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL];
        const wallTypes = [_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL, _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL_HALL];
        for (let y = 0; y < section.height; y++) {
            for (let x = 0; x < section.width; x++) {
                const tileType = section.tiles[y][x];
                if (floorTypes.indexOf(tileType) > -1) {
                    if (y < 2) {
                        return false;
                    }
                    const oneUp = section.tiles[y - 1][x];
                    const twoUp = section.tiles[y - 2][x];
                    if (floorTypes.indexOf(oneUp) > -1) {
                        // continue
                    }
                    else if (wallTypes.indexOf(oneUp) > -1) {
                        if (twoUp !== _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL_TOP) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DungeonGenerator);


/***/ }),

/***/ "./src/main/maps/generation/RoomCorridorDungeonGenerator2.ts":
/*!*******************************************************************!*\
  !*** ./src/main/maps/generation/RoomCorridorDungeonGenerator2.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DungeonGenerator */ "./src/main/maps/generation/DungeonGenerator.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");




const ROOM_PADDING = [2, 3, 1, 1]; // left, top, right, bottom
const MIN_ROOM_FRACTION = 0.4;
const MAX_ROOM_FRACTION = 0.8;
class RoomCorridorDungeonGenerator2 extends _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__.default {
    /**
     * @param minRoomDimension inner width, not including wall
     * @param maxRoomDimension inner width, not including wall
     */
    constructor(tileSet, minRoomDimension, maxRoomDimension) {
        super(tileSet);
        this._minRoomDimension = minRoomDimension;
        this._maxRoomDimension = maxRoomDimension;
    }
    generateTiles(width, height) {
        // 1. Recursively subdivide the map into sections.
        //    Each section must fall within the max dimensions.
        // 2. Add rooms within sections, with appropriate padding.
        //    (Don't add a room for every section; approximately half.  Rules TBD.)
        const sections = this._generateSections(0, 0, width, height);
        this._removeRooms(sections);
        // 3. Construct a minimal spanning tree between sections (including those without rooms).
        const minimalSpanningTree = this._generateMinimalSpanningTree(sections);
        // 4.  Add all optional connections between sections.
        const optionalConnections = this._generateOptionalConnections(sections, minimalSpanningTree);
        // 5. Add "red-red" connections in empty rooms.
        // 6. Add "red-green" connections in empty rooms only if:
        //    - both edges connect to a room
        //    - there is no red-red connection in the section
        const internalConnections = this._addInternalConnections(sections, minimalSpanningTree, optionalConnections);
        const externalConnections = [...minimalSpanningTree, ...optionalConnections];
        this._stripOrphanedConnections(externalConnections, internalConnections);
        // TODO
        const debugOutput = `
      Sections: ${sections.map(section => this._sectionToString(section)).join('; ')}
      MST: ${minimalSpanningTree.map(this._connectionToString).join('; ')}
      opt: ${optionalConnections.map(this._connectionToString).join('; ')}
      external: ${externalConnections.map(this._connectionToString).join('; ')}
      Internal: ${internalConnections.map(connection => `${this._sectionToString(connection.section)}, ${connection.neighbors.length}`).join('; ')}
    `;
        console.log(debugOutput);
        // END TODO
        // Compute the actual tiles based on section/connection specifications.
        const tiles = this._generateTiles(width, height, sections, externalConnections, internalConnections);
        // 7. Add walls.
        this._addWalls(tiles);
        return {
            tiles,
            rooms: [],
            width,
            height
        };
    }
    _sectionToString(section) {
        return `(${section.rect.left}, ${section.rect.top}, ${section.rect.width}, ${section.rect.height})`;
    }
    /**
     * Generate a rectangular area of tiles with the specified dimensions, consisting of any number of rooms connected
     * by corridors.  To do so, split the area into two sub-areas and call this method recursively.  If this area is
     * not large enough to form two sub-regions, just return a single section.
     */
    _generateSections(left, top, width, height) {
        const splitDirection = this._getSplitDirection(width, height);
        if (splitDirection === 'HORIZONTAL') {
            const splitX = this._getSplitPoint(left, width, splitDirection);
            const leftWidth = splitX - left;
            const leftSections = this._generateSections(left, top, leftWidth, height);
            const rightWidth = width - leftWidth;
            const rightSections = this._generateSections(splitX, top, rightWidth, height);
            return [...leftSections, ...rightSections];
        }
        else if (splitDirection === 'VERTICAL') {
            const splitY = this._getSplitPoint(top, height, splitDirection);
            const topHeight = splitY - top;
            const bottomHeight = height - topHeight;
            const topSections = this._generateSections(left, top, width, topHeight);
            const bottomSections = this._generateSections(left, splitY, width, bottomHeight);
            return [...topSections, ...bottomSections];
        }
        else {
            // base case: generate single section
            const rect = {
                left,
                top,
                width,
                height
            };
            const padding = 1;
            const leftPadding = 2;
            const topPadding = 2;
            const roomRect = {
                left: left + leftPadding,
                top: top + topPadding,
                width: width - padding - leftPadding,
                height: height - padding - topPadding
            };
            return [{ rect, roomRect }];
        }
    }
    _getSplitDirection(width, height) {
        // First, make sure the area is large enough to support two sections; if not, we're done
        const minWidth = this._minRoomDimension + ROOM_PADDING[0] + ROOM_PADDING[2];
        const minHeight = this._minRoomDimension + ROOM_PADDING[1] + ROOM_PADDING[3];
        const canSplitHorizontally = (width >= (2 * minWidth));
        const canSplitVertically = (height >= (2 * minHeight));
        if (canSplitHorizontally) {
            return 'HORIZONTAL';
        }
        else if (canSplitVertically) {
            return 'VERTICAL';
        }
        else {
            return null;
        }
    }
    /**
     * @param start left or top
     * @param dimension width or height
     * @returns the min X/Y coordinate of the *second* room
     */
    _getSplitPoint(start, dimension, direction) {
        const minWidth = this._minRoomDimension + ROOM_PADDING[0] + ROOM_PADDING[2];
        const minHeight = this._minRoomDimension + ROOM_PADDING[1] + ROOM_PADDING[3];
        const minSectionDimension = (direction === 'HORIZONTAL' ? minWidth : minHeight);
        const minSplitPoint = start + minSectionDimension;
        const maxSplitPoint = start + dimension - minSectionDimension;
        return (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(minSplitPoint, maxSplitPoint);
    }
    _removeRooms(sections) {
        const minRooms = Math.max(3, Math.round(sections.length * MIN_ROOM_FRACTION));
        const maxRooms = Math.max(minRooms, sections.length * MAX_ROOM_FRACTION);
        if (sections.length < minRooms) {
            throw 'Not enough sections';
        }
        const numRooms = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(minRooms, maxRooms);
        const shuffledSections = [...sections];
        (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.shuffle)(shuffledSections);
        for (let i = numRooms; i < shuffledSections.length; i++) {
            shuffledSections[i].roomRect = null;
        }
    }
    _generateMinimalSpanningTree(sections) {
        const connectedSection = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randChoice)(sections);
        const connectedSections = [connectedSection];
        const unconnectedSections = [...sections].filter(section => section !== connectedSection);
        (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.shuffle)(unconnectedSections);
        const connections = [];
        while (unconnectedSections.length > 0) {
            (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.shuffle)(connectedSections);
            let connectedAny = false;
            for (let i = 0; i < connectedSections.length; i++) {
                const connectedSection = connectedSections[i];
                for (let j = 0; j < unconnectedSections.length; j++) {
                    const unconnectedSection = unconnectedSections[j];
                    if (this._canConnect(connectedSection, unconnectedSection)) {
                        unconnectedSections.splice(j, 1);
                        connectedSections.push(unconnectedSection);
                        connections.push(this._buildConnection(connectedSection, unconnectedSection));
                        connectedAny = true;
                        break;
                    }
                }
            }
            if (!connectedAny) {
                console.log('connected:');
                connectedSections.forEach(x => console.log(x));
                console.log('unconnected:');
                unconnectedSections.forEach(x => console.log(x));
                throw 'Failed to generate minimal spanning tree';
            }
        }
        return connections;
    }
    _generateOptionalConnections(sections, spanningConnections) {
        const optionalConnections = [];
        for (let i = 0; i < sections.length; i++) {
            const first = sections[i];
            for (let j = i + 1; j < sections.length; j++) {
                const second = sections[j];
                if (this._canConnect(first, second)) {
                    if (!spanningConnections.some(connection => this._connectionMatches(connection, first, second))) {
                        optionalConnections.push(this._buildConnection(first, second));
                    }
                }
            }
        }
        return optionalConnections;
    }
    _addInternalConnections(sections, spanningConnections, optionalConnections) {
        const internalConnections = [];
        sections.forEach(section => {
            if (!section.roomRect) {
                const connectedSections = [];
                const neighbors = sections.filter(s => s !== section).filter(s => this._canConnect(section, s));
                neighbors.forEach(neighbor => {
                    if (spanningConnections.some(connection => this._connectionMatches(connection, section, neighbor))) {
                        connectedSections.push(neighbor);
                    }
                });
                if (connectedSections.length === 1) {
                    (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.shuffle)(neighbors);
                    for (let neighbor of neighbors) {
                        if (optionalConnections.some(connection => this._connectionMatches(connection, section, neighbor))) {
                            connectedSections.push(neighbor);
                            break;
                        }
                    }
                }
                if (connectedSections.length > 0) {
                    internalConnections.push({ section, neighbors: connectedSections });
                }
            }
        });
        return internalConnections;
    }
    _generateTiles(width, height, sections, connections, internalConnections) {
        const tiles = [];
        for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
                row.push(_types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE);
            }
            tiles.push(row);
        }
        // add floor tiles for rooms
        sections.forEach(section => {
            if (!!section.roomRect) {
                for (let y = section.roomRect.top; y < section.roomRect.top + section.roomRect.height; y++) {
                    for (let x = section.roomRect.left; x < section.roomRect.left + section.roomRect.width; x++) {
                        tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR;
                    }
                }
            }
        });
        // add floor tiles for connections
        connections.forEach(connection => {
            const dx = Math.sign(connection.endCoordinates.x - connection.startCoordinates.x);
            const dy = Math.sign(connection.endCoordinates.y - connection.startCoordinates.y);
            let { x, y } = connection.startCoordinates;
            while (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)({ x, y }, connection.endCoordinates)) {
                tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                x += dx;
                y += dy;
            }
            tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
        });
        this._addTilesForInternalConnections(tiles, internalConnections, connections);
        return tiles;
    }
    _addWalls(tiles) {
        const height = tiles.length;
        const width = tiles[0].length;
        for (let y = 0; y < height - 2; y++) {
            for (let x = 0; x < width; x++) {
                if (tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE
                    && tiles[y + 1][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.NONE
                    && (tiles[y + 2][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR || tiles[y + 2][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL)) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL_TOP;
                    tiles[y + 1][x] = (tiles[y + 2][x] === _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR) ? _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL : _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.WALL_HALL;
                }
            }
        }
    }
    _canConnect(first, second) {
        return (0,_MapUtils__WEBPACK_IMPORTED_MODULE_3__.areAdjacent)(first.rect, second.rect, 5);
    }
    _connectionMatches(connection, first, second) {
        // ref. equality should be fine
        if (connection.start === first && connection.end === second) {
            return true;
        }
        else if (connection.start === second && connection.end === first) {
            return true;
        }
        else {
            return false;
        }
    }
    _buildConnection(first, second) {
        let connectionPoint; // on the starting edge of `second`
        let firstCoordinates;
        let secondCoordinates;
        // right-left
        if (first.rect.left + first.rect.width === second.rect.left) {
            const top = Math.max(first.rect.top, second.rect.top);
            const bottom = Math.min(first.rect.top + first.rect.height, second.rect.top + second.rect.height); // exclusive
            connectionPoint = {
                x: second.rect.left,
                y: (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(top + 2, bottom - 2) // should be in range since we checked _canConnect already
            };
            firstCoordinates = { x: connectionPoint.x - 1, y: connectionPoint.y };
            secondCoordinates = { x: connectionPoint.x + 1, y: connectionPoint.y };
        }
        // bottom-top
        else if (first.rect.top + first.rect.height === second.rect.top) {
            const left = Math.max(first.rect.left, second.rect.left);
            const right = Math.min(first.rect.left + first.rect.width, second.rect.left + second.rect.width); // exclusive
            connectionPoint = {
                x: (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(left + 2, right - 2),
                y: second.rect.top
            };
            firstCoordinates = { x: connectionPoint.x, y: connectionPoint.y - 1 };
            secondCoordinates = { x: connectionPoint.x, y: connectionPoint.y + 1 };
        }
        // left-right
        else if (first.rect.left === second.rect.left + second.rect.width) {
            const top = Math.max(first.rect.top, second.rect.top);
            const bottom = Math.min(first.rect.top + first.rect.height, second.rect.top + second.rect.height); // exclusive
            connectionPoint = {
                x: first.rect.left,
                y: (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(top + 2, bottom - 2) // should be in range since we checked _canConnect already
            };
            firstCoordinates = { x: connectionPoint.x + 1, y: connectionPoint.y };
            secondCoordinates = { x: connectionPoint.x - 1, y: connectionPoint.y };
        }
        // top-bottom
        else if (first.rect.top === second.rect.top + second.rect.height) {
            const left = Math.max(first.rect.left, second.rect.left);
            const right = Math.min(first.rect.left + first.rect.width, second.rect.left + second.rect.width); // exclusive
            connectionPoint = {
                x: (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(left + 2, right - 2),
                y: first.rect.top
            };
            firstCoordinates = { x: connectionPoint.x, y: connectionPoint.y + 1 };
            secondCoordinates = { x: connectionPoint.x, y: connectionPoint.y - 1 };
        }
        else {
            throw 'Failed to build connection';
        }
        const direction = (firstCoordinates.x === secondCoordinates.x) ? 'VERTICAL' : 'HORIZONTAL';
        const middleCoordinates = {
            x: (firstCoordinates.x + secondCoordinates.x) / 2,
            y: (firstCoordinates.y + secondCoordinates.y) / 2
        };
        return {
            start: first,
            end: second,
            startCoordinates: firstCoordinates,
            endCoordinates: secondCoordinates,
            middleCoordinates,
            direction
        };
    }
    _connectionToString(connection) {
        return `[(${connection.startCoordinates.x}, ${connection.startCoordinates.y})-(${connection.endCoordinates.x}, ${connection.endCoordinates.y})]`;
    }
    _addTilesForInternalConnections(tiles, internalConnections, connections) {
        internalConnections.forEach(internalConnection => {
            const neighbors = [...internalConnection.neighbors];
            (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.shuffle)(neighbors);
            for (let i = 0; i < neighbors.length - 1; i++) {
                const firstNeighbor = internalConnection.neighbors[i];
                const secondNeighbor = internalConnection.neighbors[i + 1];
                const firstConnection = connections.filter(c => this._connectionMatches(c, internalConnection.section, firstNeighbor))[0];
                const secondConnection = connections.filter(c => this._connectionMatches(c, internalConnection.section, secondNeighbor))[0];
                if (!firstConnection || !secondConnection) {
                    console.error('fux3');
                    console.log(connections.map(this._connectionToString).join(', '));
                    console.log(neighbors.join(' '));
                    console.log(firstNeighbor.rect);
                    console.log(secondNeighbor.rect);
                    return;
                }
                if (firstConnection.direction !== secondConnection.direction) {
                    // join perpendicularly
                    this._joinPerpendicularly(tiles, firstConnection, secondConnection);
                }
                else {
                    // join parallel connections
                    // TODO: This will also try to join U-shaped connections, and doesn't do it correctly!
                    // For now, we're just going to run a validation step and regenerate if it fails.
                    this._joinParallelConnections(tiles, internalConnection, firstConnection, secondConnection);
                }
            }
        });
    }
    _joinPerpendicularly(tiles, firstConnection, secondConnection) {
        const start = firstConnection.middleCoordinates;
        const end = secondConnection.middleCoordinates;
        const middle = {
            x: ((firstConnection.direction === 'VERTICAL') ? start : end).x,
            y: ((firstConnection.direction === 'HORIZONTAL') ? start : end).y
        };
        let dx = Math.sign(middle.x - start.x);
        let dy = Math.sign(middle.y - start.y);
        let { x, y } = start;
        while (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)({ x, y }, middle)) {
            tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
            x += dx;
            y += dy;
        }
        dx = Math.sign(end.x - middle.x);
        dy = Math.sign(end.y - middle.y);
        while (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)({ x, y }, end)) {
            tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
            x += dx;
            y += dy;
        }
    }
    _joinParallelConnections(tiles, internalConnection, firstConnection, secondConnection) {
        const start = firstConnection.middleCoordinates;
        const end = secondConnection.middleCoordinates;
        const middle = {
            x: Math.round((start.x + end.x) / 2),
            y: Math.round((start.y + end.y) / 2)
        };
        const xDistance = end.x - start.x;
        const yDistance = end.y - start.y;
        const dx = Math.sign(xDistance);
        const dy = Math.sign(yDistance);
        const majorDirection = (Math.abs(xDistance) >= Math.abs(yDistance)) ? 'HORIZONTAL' : 'VERTICAL';
        let { x, y } = start;
        switch (majorDirection) {
            case 'HORIZONTAL':
                while (x !== middle.x) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                    x += dx;
                }
                while (y !== end.y) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                    y += dy;
                }
                while (x !== end.x) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                    x += dx;
                }
                break;
            case 'VERTICAL':
                while (y !== middle.y) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                    y += dy;
                }
                while (x !== end.x) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                    x += dx;
                }
                while (y !== end.y) {
                    tiles[y][x] = _types_types__WEBPACK_IMPORTED_MODULE_1__.TileType.FLOOR_HALL;
                    y += dy;
                }
                break;
        }
    }
    /**
     * A connection is orphaned if, for either of its endpoints, there is neither a room nor a connected
     * internal connection that connects to that endpoint.
     *
     * @return a copy of `externalConnections` with the desired elements removed
     */
    _stripOrphanedConnections(externalConnections, internalConnections) {
        let removedAnyConnections = false;
        do {
            const orphanedConnections = externalConnections.filter(connection => {
                return this._isOrphanedConnection(connection, internalConnections);
            });
            this._subtract(externalConnections, orphanedConnections);
            internalConnections.forEach(internalConnection => {
                this._pruneInternalConnection(internalConnection, orphanedConnections);
            });
            const orphanedInternalConnections = internalConnections.filter(internalConnection => {
                return this._isOrphanedInternalConnection(internalConnection, internalConnections);
            });
            this._subtract(internalConnections, orphanedInternalConnections);
            removedAnyConnections = (orphanedConnections.length > 0 || orphanedInternalConnections.length > 0);
            console.log(`stripping: ${orphanedConnections.length}, ${orphanedInternalConnections.length}`);
        } while (removedAnyConnections);
    }
    _isOrphanedConnection(connection, internalConnections) {
        const { start, end } = connection;
        let startHasInternalConnection = false;
        let endHasInternalConnection = false;
        for (let internalConnection of internalConnections) {
            if (internalConnection.section === start && internalConnection.neighbors.indexOf(end) > -1) {
                startHasInternalConnection = true;
            }
            if (internalConnection.section === end && internalConnection.neighbors.indexOf(start) > -1) {
                endHasInternalConnection = true;
            }
        }
        return !((!!start.roomRect || startHasInternalConnection)
            && (!!end.roomRect || endHasInternalConnection));
    }
    _pruneInternalConnection(internalConnection, orphanedConnections) {
        for (let connection of orphanedConnections) {
            const { section, neighbors } = internalConnection;
            const { start, end } = connection;
            const updatedNeighbors = neighbors.filter(neighbor => {
                if (section === start && neighbor === end) {
                    return false;
                }
                if (section === end && neighbor === start) {
                    return false;
                }
                return true;
            });
            this._replace(neighbors, updatedNeighbors);
        }
    }
    /**
     * An internal connection is orphaned if at most one of its neighbors has either a room or another
     * internal connection
     */
    _isOrphanedInternalConnection(internalConnection, internalConnections) {
        let connectedNeighbors = 0;
        const { section, neighbors } = internalConnection;
        neighbors.forEach(neighbor => {
            const neighborHasInternalConnection = internalConnections.find(other => other.section === neighbor && other.neighbors.indexOf(section) > -1);
            if (!!neighbor.roomRect || neighborHasInternalConnection) {
                connectedNeighbors++;
            }
        });
        return connectedNeighbors <= 1;
    }
    _replace(array, contents) {
        array.splice(0, array.length);
        array.push(...contents);
    }
    _subtract(array, toRemove) {
        const updated = array.filter(element => toRemove.indexOf(element) === -1);
        this._replace(array, updated);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoomCorridorDungeonGenerator2);


/***/ }),

/***/ "./src/main/maps/generation/TileEligibilityChecker.ts":
/*!************************************************************!*\
  !*** ./src/main/maps/generation/TileEligibilityChecker.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");


class TileEligibilityChecker {
    isBlocked({ x, y }, section, exits) {
        // can't draw a path through an existing room or a wall
        const blockedTileTypes = [_types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.FLOOR, /*TileType.FLOOR_HALL,*/ _types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL, _types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL_HALL, _types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.WALL_TOP];
        if (exits.some(exit => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_1__.coordinatesEquals)({ x, y }, exit))) {
            return false;
        }
        else if (section.tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.NONE || section.tiles[y][x] === _types_types__WEBPACK_IMPORTED_MODULE_0__.TileType.FLOOR_HALL) {
            // skip the check if we're within 1 tile vertically of an exit
            const isNextToExit = [-2, -1, 1, 2].some(dy => (exits.some(exit => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_1__.coordinatesEquals)(exit, { x, y: y + dy }))));
            if (isNextToExit) {
                return false;
            }
            // can't draw tiles within 2 tiles vertically of a wall tile, or a room floor tile
            for (let dy of [-2, -1, 1, 2]) {
                if ((y + dy >= 0) && (y + dy < section.height)) {
                    const tile = section.tiles[y + dy][x];
                    if (blockedTileTypes.indexOf(tile) > -1) {
                        return true;
                    }
                }
            }
            return false;
        }
        else if (blockedTileTypes.indexOf(section.tiles[y][x]) > -1) {
            return true;
        }
        console.error('how\'d we get here?');
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileEligibilityChecker);


/***/ }),

/***/ "./src/main/sounds/AudioUtils.ts":
/*!***************************************!*\
  !*** ./src/main/sounds/AudioUtils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transpose8va": () => (/* binding */ transpose8va),
/* harmony export */   "transpose8vb": () => (/* binding */ transpose8vb)
/* harmony export */ });
function transpose8va([freq, ms]) {
    return [freq * 2, ms];
}
function transpose8vb([freq, ms]) {
    return [freq / 2, ms];
}



/***/ }),

/***/ "./src/main/sounds/CustomOscillator.ts":
/*!*********************************************!*\
  !*** ./src/main/sounds/CustomOscillator.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class CustomOscillator {
    constructor(context, gainNode, repeating) {
        this._delegate = context.createOscillator();
        this._delegate.type = 'square';
        this._delegate.connect(gainNode);
        this._isComplete = false;
        this._isRepeating = repeating;
    }
    play(samples, context) {
        if (samples.length) {
            const startTime = context.currentTime;
            let nextStartTime = startTime;
            for (let i = 0; i < samples.length; i++) {
                const [freq, ms] = samples[i];
                this._delegate.frequency.setValueAtTime(freq, nextStartTime);
                nextStartTime += ms / 1000;
            }
            const runtime = samples.map(([freq, ms]) => ms).reduce((a, b) => a + b);
            this._delegate.start();
            this._delegate.onended = () => {
                if (this._isRepeating && !this._isComplete) {
                    this.play(samples, context);
                }
                else {
                    this._isComplete = true;
                }
            };
            this._delegate.stop(startTime + runtime / 1000);
        }
    }
    isComplete() {
        return this._isComplete;
    }
    stop() {
        this._delegate.stop(0);
        this._isComplete = true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CustomOscillator);


/***/ }),

/***/ "./src/main/sounds/Music.ts":
/*!**********************************!*\
  !*** ./src/main/sounds/Music.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SoundPlayer */ "./src/main/sounds/SoundPlayer.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");
/* harmony import */ var _AudioUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioUtils */ "./src/main/sounds/AudioUtils.ts");



// TODO very hacky memoizing
let PLAYER = null;
let ACTIVE_SUITE = null;
const TITLE_THEME = [[600, 500], [300, 250], [150, 250], [900, 500], [450, 250], [300, 250], [500, 500], [300, 250], [200, 250], [200, 500], [300, 125], [600, 125], [900, 125], [1200, 125], [1500, 250]];
const GAME_OVER = [[400, 150], [300, 150], [238, 150], [200, 150], [300, 160], [238, 160], [200, 160], [150, 160], [238, 200], [200, 200], [150, 240], [100, 280], [75, 1000]];
const _getMusicPlayer = () => new _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__.default(4, 0.12);
function playSuite(suite) {
    ACTIVE_SUITE = suite;
    const sections = Object.values(suite.sections);
    const numRepeats = 4;
    for (let i = 0; i < sections.length; i++) {
        let section = sections[i];
        const bass = (!!section.bass) ? (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__.randChoice)(section.bass) : null;
        let lead;
        if (!!section.lead) {
            do {
                lead = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__.randChoice)(section.lead);
            } while (lead === bass);
        }
        for (let j = 0; j < numRepeats; j++) {
            setTimeout(() => {
                if (suite === ACTIVE_SUITE) {
                    const figures = [
                        ...(!!bass ? [bass.map(_AudioUtils__WEBPACK_IMPORTED_MODULE_2__.transpose8vb)] : []),
                        ...(!!lead ? [lead] : [])
                    ];
                    figures.forEach(figure => playFigure(figure));
                }
            }, ((numRepeats * i) + j) * suite.length);
        }
    }
    setTimeout(() => {
        if (suite === ACTIVE_SUITE) {
            playSuite(suite);
        }
    }, sections.length * suite.length * numRepeats);
}
function playFigure(samples) {
    if (!PLAYER) {
        PLAYER = _getMusicPlayer();
    }
    PLAYER.playSound(samples, false);
}
function stopMusic() {
    if (PLAYER) {
        PLAYER.stop();
    }
}
function stop() {
    stopMusic();
    ACTIVE_SUITE = null;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    TITLE_THEME,
    GAME_OVER,
    playFigure,
    playSuite,
    stop
});


/***/ }),

/***/ "./src/main/sounds/SoundFX.ts":
/*!************************************!*\
  !*** ./src/main/sounds/SoundFX.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "playSound": () => (/* binding */ playSound)
/* harmony export */ });
/* harmony import */ var _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SoundPlayer */ "./src/main/sounds/SoundPlayer.ts");

let PLAYER = null;
function _getSoundPlayer() {
    return new _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__.default(4, 0.20);
}
function playSound(samples) {
    if (!PLAYER) {
        PLAYER = _getSoundPlayer();
    }
    PLAYER.playSound(samples, false);
}



/***/ }),

/***/ "./src/main/sounds/SoundPlayer.ts":
/*!****************************************!*\
  !*** ./src/main/sounds/SoundPlayer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CustomOscillator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomOscillator */ "./src/main/sounds/CustomOscillator.ts");

class SoundPlayer {
    constructor(maxPolyphony, gain) {
        this._context = new AudioContext();
        this._gainNode = this._context.createGain();
        this._gainNode.gain.value = gain * 0.2; // sounds can be VERY loud
        this._gainNode.connect(this._context.destination);
        this._oscillators = [];
    }
    stop() {
        try {
            this._oscillators.forEach(oscillator => oscillator.stop());
        }
        catch (e) {
            console.error(e);
        }
    }
    ;
    playSound(samples, repeating = false) {
        const oscillator = new _CustomOscillator__WEBPACK_IMPORTED_MODULE_0__.default(this._context, this._gainNode, repeating);
        oscillator.play(samples, this._context);
        this._oscillators.push(oscillator);
        this._cleanup();
    }
    ;
    _cleanup() {
        this._oscillators = this._oscillators.filter(o => !o.isComplete());
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SoundPlayer);


/***/ }),

/***/ "./src/main/sounds/Sounds.ts":
/*!***********************************!*\
  !*** ./src/main/sounds/Sounds.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_sounds_player_hits_enemy_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/sounds/player_hits_enemy.json */ "./data/sounds/player_hits_enemy.json");
/* harmony import */ var _data_sounds_enemy_hits_player_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../data/sounds/enemy_hits_player.json */ "./data/sounds/enemy_hits_player.json");
/* harmony import */ var _data_sounds_enemy_dies_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../data/sounds/enemy_dies.json */ "./data/sounds/enemy_dies.json");
/* harmony import */ var _data_sounds_player_dies_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../data/sounds/player_dies.json */ "./data/sounds/player_dies.json");
/* harmony import */ var _data_sounds_level_up_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../data/sounds/level_up.json */ "./data/sounds/level_up.json");
/* harmony import */ var _data_sounds_deflected_hit_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../data/sounds/deflected_hit.json */ "./data/sounds/deflected_hit.json");
/* harmony import */ var _data_sounds_pick_up_item_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../data/sounds/pick_up_item.json */ "./data/sounds/pick_up_item.json");
/* harmony import */ var _data_sounds_use_potion_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../data/sounds/use_potion.json */ "./data/sounds/use_potion.json");
/* harmony import */ var _data_sounds_open_door_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../data/sounds/open_door.json */ "./data/sounds/open_door.json");
/* harmony import */ var _data_sounds_footstep_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../data/sounds/footstep.json */ "./data/sounds/footstep.json");
/* harmony import */ var _data_sounds_descend_stairs_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../data/sounds/descend_stairs.json */ "./data/sounds/descend_stairs.json");











const Sounds = {
    PLAYER_HITS_ENEMY: _data_sounds_player_hits_enemy_json__WEBPACK_IMPORTED_MODULE_0__,
    ENEMY_HITS_PLAYER: _data_sounds_enemy_hits_player_json__WEBPACK_IMPORTED_MODULE_1__,
    ENEMY_DIES: _data_sounds_enemy_dies_json__WEBPACK_IMPORTED_MODULE_2__,
    PLAYER_DIES: _data_sounds_player_dies_json__WEBPACK_IMPORTED_MODULE_3__,
    LEVEL_UP: _data_sounds_level_up_json__WEBPACK_IMPORTED_MODULE_4__,
    DEFLECTED_HIT: _data_sounds_deflected_hit_json__WEBPACK_IMPORTED_MODULE_5__,
    PICK_UP_ITEM: _data_sounds_pick_up_item_json__WEBPACK_IMPORTED_MODULE_6__,
    USE_POTION: _data_sounds_use_potion_json__WEBPACK_IMPORTED_MODULE_7__,
    OPEN_DOOR: _data_sounds_open_door_json__WEBPACK_IMPORTED_MODULE_8__,
    FOOTSTEP: _data_sounds_footstep_json__WEBPACK_IMPORTED_MODULE_9__,
    DESCEND_STAIRS: _data_sounds_descend_stairs_json__WEBPACK_IMPORTED_MODULE_10__,
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sounds);


/***/ }),

/***/ "./src/main/types/Colors.ts":
/*!**********************************!*\
  !*** ./src/main/types/Colors.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Colors;
(function (Colors) {
    // Original 16 MS Paint colors from Will
    Colors["BLACK"] = "#000000";
    Colors["WHITE"] = "#FFFFFF";
    Colors["DARK_GRAY"] = "#808080";
    Colors["LIGHT_GRAY"] = "#C0C0C0";
    Colors["DARK_RED"] = "#800000";
    Colors["RED"] = "#FF0000";
    Colors["DARK_YELLOW"] = "#808000";
    Colors["YELLOW"] = "#FFFF00";
    Colors["DARK_GREEN"] = "#008000";
    Colors["GREEN"] = "#00FF00";
    Colors["DARK_TEAL"] = "#004040";
    Colors["CYAN"] = "#00FFFF";
    Colors["DARK_BLUE"] = "#000080";
    Colors["BLUE"] = "#0000FF";
    Colors["DARK_PURPLE"] = "#800080";
    Colors["MAGENTA"] = "#FF00FF";
    // some extended colors
    Colors["DARK_BROWN"] = "#804000";
    Colors["LIGHT_BROWN"] = "#c08040";
    Colors["ORANGE"] = "#ff8040";
    Colors["LIGHT_PINK"] = "#ffc0c0";
    Colors["MEDIUM_RED"] = "#c00000";
    Colors["MEDIUM_BLUE"] = "#0000c0";
    Colors["DARKER_GRAY"] = "#404040";
    Colors["TEAL"] = "#008080";
})(Colors || (Colors = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Colors);


/***/ }),

/***/ "./src/main/types/Directions.ts":
/*!**************************************!*\
  !*** ./src/main/types/Directions.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Directions = {
    N: { dx: 0, dy: -1 },
    E: { dx: 1, dy: 0 },
    S: { dx: 0, dy: 1 },
    W: { dx: -1, dy: 0 }
};
function _equals(first, second) {
    return first.dx === second.dx && first.dy === second.dy;
}
function _directionToString(direction) {
    if (_equals(direction, Directions.N)) {
        return 'N';
    }
    else if (_equals(direction, Directions.E)) {
        return 'E';
    }
    else if (_equals(direction, Directions.S)) {
        return 'S';
    }
    else if (_equals(direction, Directions.W)) {
        return 'W';
    }
    throw `Invalid direction ${direction}`;
}
function _toLegacyDirection(direction) {
    const lookup = {
        'N': 'NW',
        'E': 'NE',
        'S': 'SE',
        'W': 'SW'
    };
    return Object.entries(lookup)
        // @ts-ignore
        .filter(([from, to]) => _equals(direction, Directions[from]))
        .map(([from, to]) => to)[0];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    N: Directions.N,
    E: Directions.E,
    S: Directions.S,
    W: Directions.W,
    values: () => [Directions.N, Directions.E, Directions.S, Directions.W],
    toString: _directionToString,
    toLegacyDirection: _toLegacyDirection
});


/***/ }),

/***/ "./src/main/types/types.ts":
/*!*********************************!*\
  !*** ./src/main/types/types.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Activity": () => (/* binding */ Activity),
/* harmony export */   "EquipmentSlot": () => (/* binding */ EquipmentSlot),
/* harmony export */   "GameScreen": () => (/* binding */ GameScreen),
/* harmony export */   "ItemCategory": () => (/* binding */ ItemCategory),
/* harmony export */   "MapLayout": () => (/* binding */ MapLayout),
/* harmony export */   "TileType": () => (/* binding */ TileType),
/* harmony export */   "UnitType": () => (/* binding */ UnitType)
/* harmony export */ });
var Activity;
(function (Activity) {
    Activity["STANDING"] = "STANDING";
    Activity["WALKING"] = "WALKING";
    Activity["ATTACKING"] = "ATTACKING";
    Activity["SHOOTING"] = "SHOOTING";
    Activity["DAMAGED"] = "DAMAGED";
})(Activity || (Activity = {}));
var EquipmentSlot;
(function (EquipmentSlot) {
    EquipmentSlot["MELEE_WEAPON"] = "MELEE_WEAPON";
    EquipmentSlot["RANGED_WEAPON"] = "RANGED_WEAPON";
    EquipmentSlot["CHEST"] = "CHEST";
    EquipmentSlot["HEAD"] = "HEAD";
})(EquipmentSlot || (EquipmentSlot = {}));
var GameScreen;
(function (GameScreen) {
    GameScreen["GAME"] = "GAME";
    GameScreen["INVENTORY"] = "INVENTORY";
    GameScreen["TITLE"] = "TITLE";
    GameScreen["VICTORY"] = "VICTORY";
    GameScreen["GAME_OVER"] = "GAME_OVER";
    GameScreen["MINIMAP"] = "MINIMAP";
})(GameScreen || (GameScreen = {}));
var ItemCategory;
(function (ItemCategory) {
    ItemCategory["POTION"] = "POTION";
    ItemCategory["SCROLL"] = "SCROLL";
    ItemCategory["WEAPON"] = "WEAPON";
    ItemCategory["ARMOR"] = "ARMOR";
})(ItemCategory || (ItemCategory = {}));
var MapLayout;
(function (MapLayout) {
    MapLayout["ROOMS_AND_CORRIDORS"] = "ROOMS_AND_CORRIDORS";
    MapLayout["BLOB"] = "BLOB";
})(MapLayout || (MapLayout = {}));
var TileType;
(function (TileType) {
    TileType[TileType["FLOOR"] = 0] = "FLOOR";
    TileType[TileType["FLOOR_HALL"] = 1] = "FLOOR_HALL";
    TileType[TileType["WALL_TOP"] = 2] = "WALL_TOP";
    TileType[TileType["WALL_HALL"] = 3] = "WALL_HALL";
    TileType[TileType["WALL"] = 4] = "WALL";
    TileType[TileType["NONE"] = 5] = "NONE";
    TileType[TileType["STAIRS_DOWN"] = 6] = "STAIRS_DOWN";
})(TileType || (TileType = {}));
var UnitType;
(function (UnitType) {
    UnitType["HUMAN"] = "HUMAN";
    UnitType["ELEMENTAL"] = "ELEMENTAL";
    UnitType["GHOST"] = "GHOST";
    UnitType["GOLEM"] = "GOLEM";
    UnitType["WIZARD"] = "WIZARD";
    UnitType["ANIMAL"] = "ANIMAL";
})(UnitType || (UnitType = {}));



/***/ }),

/***/ "./src/main/units/Unit.ts":
/*!********************************!*\
  !*** ./src/main/units/Unit.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _items_InventoryMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../items/InventoryMap */ "./src/main/items/InventoryMap.ts");
/* harmony import */ var _items_equipment_EquipmentMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../items/equipment/EquipmentMap */ "./src/main/items/equipment/EquipmentMap.ts");
/* harmony import */ var _sounds_Music__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sounds/Music */ "./src/main/sounds/Music.ts");
/* harmony import */ var _UnitAbilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UnitAbilities */ "./src/main/units/UnitAbilities.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _types_Directions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../types/Directions */ "./src/main/types/Directions.ts");








// Regenerate 1% of life every 50 turns
const LIFE_PER_TURN_MULTIPLIER = 0.0002;
class Unit {
    constructor(unitClass, name, level, { x, y }) {
        var _a;
        this.char = '@';
        this.unitClass = unitClass;
        this.sprite = unitClass.sprite(this, unitClass.paletteSwaps);
        this.inventory = new _items_InventoryMap__WEBPACK_IMPORTED_MODULE_1__.default();
        this.equipment = new _items_equipment_EquipmentMap__WEBPACK_IMPORTED_MODULE_2__.default();
        this.x = x;
        this.y = y;
        this.name = name;
        this.level = 1;
        this.experience = 0;
        this.life = unitClass.startingLife;
        this.maxLife = unitClass.startingLife;
        this.mana = unitClass.startingMana;
        this.maxMana = unitClass.startingMana;
        this.lifeRemainder = 0;
        this._damage = unitClass.startingDamage;
        this.controller = unitClass.controller;
        this.activity = _types_types__WEBPACK_IMPORTED_MODULE_5__.Activity.STANDING;
        this.direction = _types_Directions__WEBPACK_IMPORTED_MODULE_7__.default.S;
        this.remainingCooldowns = new Map();
        // TODO: this needs to be specific to the player unit
        this.abilities = [_UnitAbilities__WEBPACK_IMPORTED_MODULE_4__.default.ATTACK, _UnitAbilities__WEBPACK_IMPORTED_MODULE_4__.default.HEAVY_ATTACK, _UnitAbilities__WEBPACK_IMPORTED_MODULE_4__.default.KNOCKBACK_ATTACK, _UnitAbilities__WEBPACK_IMPORTED_MODULE_4__.default.STUN_ATTACK];
        this.stunDuration = 0;
        (_a = unitClass.equipment) === null || _a === void 0 ? void 0 : _a.forEach(supplier => {
            const equipment = supplier();
            this.equipment.add(equipment);
            equipment.attach(this);
        });
        while (this.level < level) {
            this._levelUp(false);
        }
    }
    _upkeep() {
        // life regeneration
        const lifePerTurn = this.maxLife * LIFE_PER_TURN_MULTIPLIER;
        this.lifeRemainder += lifePerTurn;
        const deltaLife = Math.floor(this.lifeRemainder);
        this.lifeRemainder -= deltaLife;
        this.life = Math.min(this.life + deltaLife, this.maxLife);
        // I hate javascript, wtf is this callback signature
        this.remainingCooldowns.forEach((cooldown, ability, map) => {
            map.set(ability, Math.max(cooldown - 1, 0));
        });
    }
    _endOfTurn() {
        // decrement stun duration
        this.stunDuration = Math.max(this.stunDuration - 1, 0);
    }
    update() {
        return new Promise(resolve => {
            this._upkeep();
            return resolve();
        })
            .then(() => {
            if (this.stunDuration === 0) {
                return this.controller.issueOrder(this);
            }
            return Promise.resolve();
        })
            .then(() => this.sprite.getImage())
            .then(() => this._endOfTurn());
    }
    getDamage() {
        let damage = this._damage;
        this.equipment.getEntries()
            .filter(([slot, item]) => (slot !== _types_types__WEBPACK_IMPORTED_MODULE_5__.EquipmentSlot.RANGED_WEAPON))
            .forEach(([slot, item]) => {
            damage += (item.damage || 0);
        });
        return damage;
    }
    getRangedDamage() {
        let damage = this._damage;
        this.equipment.getEntries()
            .filter(([slot, item]) => (slot !== _types_types__WEBPACK_IMPORTED_MODULE_5__.EquipmentSlot.MELEE_WEAPON))
            .forEach(([slot, item]) => {
            if (slot === _types_types__WEBPACK_IMPORTED_MODULE_5__.EquipmentSlot.RANGED_WEAPON) {
                damage += (item.damage || 0);
            }
            else {
                damage += (item.damage || 0) / 2;
            }
        });
        return Math.round(damage);
    }
    _levelUp(withSound) {
        this.level++;
        const lifePerLevel = this.unitClass.lifePerLevel(this.level);
        this.maxLife += lifePerLevel;
        this.life += lifePerLevel;
        this._damage += this.unitClass.damagePerLevel(this.level);
        if (withSound) {
            (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_6__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.LEVEL_UP);
        }
    }
    gainExperience(experience) {
        this.experience += experience;
        const experienceToNextLevel = this.experienceToNextLevel();
        while (!!experienceToNextLevel && this.experience >= experienceToNextLevel) {
            this.experience -= experienceToNextLevel;
            this._levelUp(true);
        }
    }
    experienceToNextLevel() {
        const { unitClass } = this;
        if (unitClass.experienceToNextLevel && (this.level < unitClass.maxLevel)) {
            return unitClass.experienceToNextLevel(this.level);
        }
        return null;
    }
    takeDamage(damage, sourceUnit) {
        const { playerUnit } = jwb.state;
        const map = jwb.state.getMap();
        return new Promise(resolve => {
            this.life = Math.max(this.life - damage, 0);
            if (this.life === 0) {
                map.removeUnit(this);
                if (this === playerUnit) {
                    jwb.state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME_OVER;
                    _sounds_Music__WEBPACK_IMPORTED_MODULE_3__.default.stop();
                    _sounds_Music__WEBPACK_IMPORTED_MODULE_3__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_3__.default.GAME_OVER);
                }
                else {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_6__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.ENEMY_DIES);
                }
                if (sourceUnit) {
                    sourceUnit.gainExperience(1);
                }
            }
            else {
                if (this === playerUnit) {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_6__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.PLAYER_HITS_ENEMY);
                }
                else {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_6__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.ENEMY_HITS_PLAYER);
                }
            }
            resolve();
        });
    }
    ;
    getCooldown(ability) {
        return this.remainingCooldowns.get(ability) || 0;
    }
    useAbility(ability) {
        this.remainingCooldowns.set(ability, ability.cooldown);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Unit);


/***/ }),

/***/ "./src/main/units/UnitAbilities.ts":
/*!*****************************************!*\
  !*** ./src/main/units/UnitAbilities.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Ability": () => (/* binding */ Ability)
/* harmony export */ });
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _UnitUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UnitUtils */ "./src/main/units/UnitUtils.ts");
/* harmony import */ var _graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphics/animations/Animations */ "./src/main/graphics/animations/Animations.ts");





class Ability {
    constructor(name, cooldown, icon = null) {
        this.name = name;
        this.cooldown = cooldown;
        this.icon = icon;
    }
}
class NormalAttack extends Ability {
    constructor() {
        super('ATTACK', 0);
    }
    use(unit, direction) {
        if (!direction) {
            throw 'NormalAttack requires a direction!';
        }
        const { dx, dy } = direction;
        const { x, y } = { x: unit.x + dx, y: unit.y + dy };
        const { playerUnit } = jwb.state;
        const map = jwb.state.getMap();
        unit.direction = { dx: x - unit.x, dy: y - unit.y };
        return new Promise(resolve => {
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
                resolve();
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    (0,_UnitUtils__WEBPACK_IMPORTED_MODULE_3__.attack)(unit, targetUnit)
                        .then(resolve);
                }
                else {
                    resolve();
                }
            }
        });
    }
}
class HeavyAttack extends Ability {
    constructor() {
        super('HEAVY_ATTACK', 15, 'strong_icon');
    }
    use(unit, direction) {
        if (!direction) {
            throw 'HeavyAttack requires a direction!';
        }
        const { dx, dy } = direction;
        const { x, y } = { x: unit.x + dx, y: unit.y + dy };
        const { playerUnit } = jwb.state;
        const map = jwb.state.getMap();
        unit.direction = { dx: x - unit.x, dy: y - unit.y };
        return new Promise(resolve => {
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
                resolve();
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    unit.useAbility(this);
                    (0,_UnitUtils__WEBPACK_IMPORTED_MODULE_3__.heavyAttack)(unit, targetUnit)
                        .then(resolve);
                }
                else {
                    resolve();
                }
            }
        });
    }
}
class KnockbackAttack extends Ability {
    constructor() {
        super('KNOCKBACK_ATTACK', 15, 'knockback_icon');
    }
    use(unit, direction) {
        if (!direction) {
            throw 'KnockbackAttack requires a direction!';
        }
        const { dx, dy } = direction;
        const { x, y } = { x: unit.x + dx, y: unit.y + dy };
        const { playerUnit } = jwb.state;
        const map = jwb.state.getMap();
        unit.direction = { dx: x - unit.x, dy: y - unit.y };
        return new Promise(resolve => {
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
                resolve();
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    unit.useAbility(this);
                    (0,_UnitUtils__WEBPACK_IMPORTED_MODULE_3__.attack)(unit, targetUnit)
                        .then(() => {
                        let targetCoordinates = { x, y };
                        // knockback by one tile
                        const oneTileBack = { x: targetCoordinates.x + dx, y: targetCoordinates.y + dy };
                        if (map.contains(oneTileBack) && !map.isBlocked(oneTileBack)) {
                            targetCoordinates = oneTileBack;
                        }
                        [targetUnit.x, targetUnit.y] = [targetCoordinates.x, targetCoordinates.y];
                        // stun for 1 turn (if they're already stunned, just leave it)
                        targetUnit.stunDuration = Math.max(targetUnit.stunDuration, 1);
                    })
                        .then(resolve);
                }
                else {
                    resolve();
                }
            }
        });
    }
}
class StunAttack extends Ability {
    constructor() {
        super('STUN_ATTACK', 15, 'knockback_icon');
    }
    use(unit, direction) {
        if (!direction) {
            throw 'StunAttack requires a direction!';
        }
        const { dx, dy } = direction;
        const { x, y } = { x: unit.x + dx, y: unit.y + dy };
        const { playerUnit } = jwb.state;
        const map = jwb.state.getMap();
        unit.direction = { dx: x - unit.x, dy: y - unit.y };
        return new Promise(resolve => {
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
                resolve();
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    unit.useAbility(this);
                    (0,_UnitUtils__WEBPACK_IMPORTED_MODULE_3__.attack)(unit, targetUnit)
                        .then(() => {
                        // stun for 2 turns (if they're already stunned, just leave it)
                        targetUnit.stunDuration = Math.max(targetUnit.stunDuration, 2);
                    })
                        .then(resolve);
                }
                else {
                    resolve();
                }
            }
        });
    }
}
class ShootArrow extends Ability {
    constructor() {
        super('SHOOT_ARROW', 0);
    }
    use(unit, direction) {
        if (!direction) {
            throw 'ShootArrow requires a direction!';
        }
        const { dx, dy } = direction;
        unit.direction = { dx, dy };
        return unit.sprite.getImage()
            .then(() => jwb.renderer.render())
            .then(() => new Promise(resolve => {
            if (!unit.equipment.get(_types_types__WEBPACK_IMPORTED_MODULE_1__.EquipmentSlot.RANGED_WEAPON)) {
                // change direction and re-render, but don't do anything (don't spend a turn)
                resolve();
                return;
            }
            const map = jwb.state.getMap();
            const coordinatesList = [];
            let { x, y } = { x: unit.x + dx, y: unit.y + dy };
            while (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                coordinatesList.push({ x, y });
                x += dx;
                y += dy;
            }
            const targetUnit = map.getUnit({ x, y });
            if (!!targetUnit) {
                const { messages } = jwb.state;
                const damage = unit.getRangedDamage();
                messages.push(`${unit.name} hit ${targetUnit.name} for ${damage} damage!`);
                (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_4__.playArrowAnimation)(unit, { dx, dy }, coordinatesList, targetUnit)
                    .then(() => targetUnit.takeDamage(damage, unit))
                    .then(() => resolve());
            }
            else {
                (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_4__.playArrowAnimation)(unit, { dx, dy }, coordinatesList, null)
                    .then(() => resolve());
            }
        }));
    }
}
const UnitAbilities = {
    ATTACK: new NormalAttack(),
    HEAVY_ATTACK: new HeavyAttack(),
    KNOCKBACK_ATTACK: new KnockbackAttack(),
    STUN_ATTACK: new StunAttack(),
    SHOOT_ARROW: new ShootArrow()
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnitAbilities);



/***/ }),

/***/ "./src/main/units/UnitBehaviors.ts":
/*!*****************************************!*\
  !*** ./src/main/units/UnitBehaviors.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Pathfinder */ "./src/main/utils/Pathfinder.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _types_Directions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/Directions */ "./src/main/types/Directions.ts");
/* harmony import */ var _UnitAbilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UnitAbilities */ "./src/main/units/UnitAbilities.ts");






function _wanderAndAttack(unit) {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    const tiles = [];
    _types_Directions__WEBPACK_IMPORTED_MODULE_4__.default.values().forEach(({ dx, dy }) => {
        const [x, y] = [unit.x + dx, unit.y + dy];
        if (map.contains({ x, y })) {
            if (!map.isBlocked({ x, y })) {
                tiles.push({ x, y });
            }
            else if (map.getUnit({ x, y })) {
                if (map.getUnit({ x, y }) === playerUnit) {
                    tiles.push({ x, y });
                }
            }
        }
    });
    if (tiles.length > 0) {
        const { x, y } = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__.randChoice)(tiles);
        const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
        return _UnitAbilities__WEBPACK_IMPORTED_MODULE_5__.default.ATTACK.use(unit, { dx, dy });
    }
    return Promise.resolve();
}
function _wander(unit) {
    const map = jwb.state.getMap();
    const tiles = [];
    _types_Directions__WEBPACK_IMPORTED_MODULE_4__.default.values().forEach(({ dx, dy }) => {
        const [x, y] = [unit.x + dx, unit.y + dy];
        if (map.contains({ x, y })) {
            if (!map.isBlocked({ x, y })) {
                tiles.push({ x, y });
            }
        }
    });
    if (tiles.length > 0) {
        const { x, y } = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__.randChoice)(tiles);
        const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
        return _UnitAbilities__WEBPACK_IMPORTED_MODULE_5__.default.ATTACK.use(unit, { dx, dy });
    }
    return Promise.resolve();
}
function _attackPlayerUnit_withPath(unit) {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    const mapRect = map.getRect();
    const unblockedTiles = [];
    for (let y = 0; y < mapRect.height; y++) {
        for (let x = 0; x < mapRect.width; x++) {
            if (!map.getTile({ x, y }).isBlocking) {
                unblockedTiles.push({ x, y });
            }
            else if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)({ x, y }, playerUnit)) {
                unblockedTiles.push({ x, y });
            }
            else {
                // blocked
            }
        }
    }
    const path = new _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_0__.default(() => 1).findPath(unit, playerUnit, unblockedTiles);
    if (path.length > 1) {
        const { x, y } = path[1]; // first tile is the unit's own tile
        const unitAtPoint = map.getUnit({ x, y });
        if (!unitAtPoint || unitAtPoint === playerUnit) {
            const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
            return _UnitAbilities__WEBPACK_IMPORTED_MODULE_5__.default.ATTACK.use(unit, { dx, dy });
        }
    }
    return Promise.resolve();
}
function _fleeFromPlayerUnit(unit) {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    const tiles = [];
    _types_Directions__WEBPACK_IMPORTED_MODULE_4__.default.values().forEach(({ dx, dy }) => {
        const [x, y] = [unit.x + dx, unit.y + dy];
        if (map.contains({ x, y })) {
            if (!map.isBlocked({ x, y })) {
                tiles.push({ x, y });
            }
            else if (map.getUnit({ x, y })) {
                if (map.getUnit({ x, y }) === playerUnit) {
                    tiles.push({ x, y });
                }
            }
        }
    });
    if (tiles.length > 0) {
        const orderedTiles = tiles.sort((0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_2__.comparingReversed)(coordinates => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.manhattanDistance)(coordinates, playerUnit)));
        const { x, y } = orderedTiles[0];
        const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
        return _UnitAbilities__WEBPACK_IMPORTED_MODULE_5__.default.ATTACK.use(unit, { dx, dy });
    }
    return Promise.resolve();
}
const UnitBehaviors = {
    WANDER: _wander,
    ATTACK_PLAYER: _attackPlayerUnit_withPath,
    FLEE_FROM_PLAYER: _fleeFromPlayerUnit,
    STAY: () => Promise.resolve()
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnitBehaviors);


/***/ }),

/***/ "./src/main/units/UnitClasses.ts":
/*!***************************************!*\
  !*** ./src/main/units/UnitClasses.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");
/* harmony import */ var _types_Colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/Colors */ "./src/main/types/Colors.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controllers/AIUnitControllers */ "./src/main/units/controllers/AIUnitControllers.ts");
/* harmony import */ var _controllers_PlayerUnitController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controllers/PlayerUnitController */ "./src/main/units/controllers/PlayerUnitController.ts");
/* harmony import */ var _items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../items/equipment/EquipmentClasses */ "./src/main/items/equipment/EquipmentClasses.ts");
/* harmony import */ var _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../items/equipment/Equipment */ "./src/main/items/equipment/Equipment.ts");







const PLAYER = {
    name: 'PLAYER',
    type: _types_types__WEBPACK_IMPORTED_MODULE_2__.UnitType.HUMAN,
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.PLAYER,
    // Green/brown colors
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_PURPLE]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.MAGENTA]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GREEN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BLUE]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GREEN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.CYAN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_PINK,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.BLACK,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.ORANGE]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_PINK // Face
    },
    startingLife: 100,
    startingMana: 100,
    startingDamage: 10,
    minLevel: 1,
    maxLevel: 20,
    lifePerLevel: level => 10,
    manaPerLevel: level => 0,
    damagePerLevel: level => 1,
    experienceToNextLevel: currentLevel => (currentLevel < 10) ? 2 * currentLevel + 2 : null,
    controller: new _controllers_PlayerUnitController__WEBPACK_IMPORTED_MODULE_4__.default()
};
const ENEMY_SNAKE = {
    name: 'ENEMY_SNAKE',
    type: _types_types__WEBPACK_IMPORTED_MODULE_2__.UnitType.ANIMAL,
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.SNAKE,
    paletteSwaps: {},
    startingLife: 40,
    startingMana: null,
    startingDamage: 4,
    minLevel: 1,
    maxLevel: 2,
    lifePerLevel: () => 15,
    manaPerLevel: () => null,
    damagePerLevel: () => 1,
    controller: _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_3__.HUMAN_DETERMINISTIC,
    aiParams: {
        speed: 0.98,
        visionRange: 10,
        fleeThreshold: 0.2
    }
};
const ENEMY_GRUNT = {
    name: 'ENEMY_GRUNT',
    type: _types_types__WEBPACK_IMPORTED_MODULE_2__.UnitType.HUMAN,
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.GRUNT,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_BROWN,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.CYAN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.ORANGE // Hands
    },
    startingLife: 50,
    startingMana: null,
    startingDamage: 3,
    minLevel: 1,
    maxLevel: 4,
    lifePerLevel: () => 20,
    manaPerLevel: () => null,
    damagePerLevel: () => 1,
    controller: _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_3__.HUMAN_DETERMINISTIC,
    equipment: [
        () => new _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__.default(_items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__.EquipmentClasses.BRONZE_CHAIN_MAIL, null),
        () => new _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__.default(_items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__.EquipmentClasses.IRON_HELMET, null),
        () => new _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__.default(_items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__.EquipmentClasses.BRONZE_SWORD, null)
    ],
    aiParams: {
        speed: 0.95,
        visionRange: 8,
        fleeThreshold: 0.1
    }
};
const ENEMY_SOLDIER = {
    name: 'ENEMY_SOLDIER',
    type: _types_types__WEBPACK_IMPORTED_MODULE_2__.UnitType.HUMAN,
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.SOLDIER,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.GREEN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.CYAN]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.ORANGE // Hands
    },
    startingLife: 60,
    startingMana: null,
    startingDamage: 4,
    minLevel: 3,
    maxLevel: 6,
    lifePerLevel: () => 20,
    manaPerLevel: () => null,
    damagePerLevel: () => 1,
    controller: _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_3__.HUMAN_DETERMINISTIC,
    equipment: [
        () => new _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__.default(_items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__.EquipmentClasses.IRON_CHAIN_MAIL, null),
        () => new _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__.default(_items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__.EquipmentClasses.IRON_HELMET, null),
        () => new _items_equipment_Equipment__WEBPACK_IMPORTED_MODULE_6__.default(_items_equipment_EquipmentClasses__WEBPACK_IMPORTED_MODULE_5__.EquipmentClasses.STEEL_SWORD, null)
    ],
    aiParams: {
        speed: 0.95,
        visionRange: 10,
        fleeThreshold: 0.1
    }
};
const ENEMY_GOLEM = {
    name: 'ENEMY_GOLEM',
    type: _types_types__WEBPACK_IMPORTED_MODULE_2__.UnitType.GOLEM,
    sprite: _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.GOLEM,
    paletteSwaps: {
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARK_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARKER_GRAY,
        [_types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.LIGHT_GRAY]: _types_Colors__WEBPACK_IMPORTED_MODULE_1__.default.DARKER_GRAY,
    },
    startingLife: 60,
    startingMana: null,
    startingDamage: 10,
    minLevel: 5,
    maxLevel: 9,
    lifePerLevel: () => 20,
    manaPerLevel: () => null,
    damagePerLevel: () => 1,
    controller: _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_3__.HUMAN_DETERMINISTIC,
    aiParams: {
        speed: 0.92,
        visionRange: 12,
        fleeThreshold: 0
    }
};
function getEnemyClasses() {
    return [ENEMY_SNAKE, ENEMY_GRUNT, ENEMY_SOLDIER, ENEMY_GOLEM];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    PLAYER,
    ENEMY_GRUNT,
    ENEMY_GOLEM,
    getEnemyClasses
});


/***/ }),

/***/ "./src/main/units/UnitFactory.ts":
/*!***************************************!*\
  !*** ./src/main/units/UnitFactory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _UnitClasses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UnitClasses */ "./src/main/units/UnitClasses.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Unit */ "./src/main/units/Unit.ts");



function createRandomEnemy({ x, y }, level) {
    const candidates = _UnitClasses__WEBPACK_IMPORTED_MODULE_0__.default.getEnemyClasses()
        .filter(unitClass => level >= unitClass.minLevel)
        .filter(unitClass => level <= unitClass.maxLevel);
    const unitClass = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_1__.randChoice)(candidates);
    return new _Unit__WEBPACK_IMPORTED_MODULE_2__.default(unitClass, unitClass.name, level, { x, y });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    createRandomEnemy
});


/***/ }),

/***/ "./src/main/units/UnitUtils.ts":
/*!*************************************!*\
  !*** ./src/main/units/UnitUtils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attack": () => (/* binding */ attack),
/* harmony export */   "heavyAttack": () => (/* binding */ heavyAttack)
/* harmony export */ });
/* harmony import */ var _graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/animations/Animations */ "./src/main/graphics/animations/Animations.ts");

function attack(unit, target) {
    const damage = unit.getDamage();
    jwb.state.messages.push(`${unit.name} hit ${target.name} for ${damage} damage!`);
    return (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_0__.playAttackingAnimation)(unit, target)
        .then(() => target.takeDamage(damage, unit));
}
function heavyAttack(unit, target) {
    const damage = unit.getDamage() * 2;
    jwb.state.messages.push(`${unit.name} hit ${target.name} for ${damage} damage!`);
    return (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_0__.playAttackingAnimation)(unit, target)
        .then(() => target.takeDamage(damage, unit));
}



/***/ }),

/***/ "./src/main/units/controllers/AIUnitControllers.ts":
/*!*********************************************************!*\
  !*** ./src/main/units/controllers/AIUnitControllers.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HUMAN_CAUTIOUS": () => (/* binding */ HUMAN_CAUTIOUS),
/* harmony export */   "HUMAN_AGGRESSIVE": () => (/* binding */ HUMAN_AGGRESSIVE),
/* harmony export */   "HUMAN_DETERMINISTIC": () => (/* binding */ HUMAN_DETERMINISTIC)
/* harmony export */ });
/* harmony import */ var _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UnitBehaviors */ "./src/main/units/UnitBehaviors.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/RandomUtils */ "./src/main/utils/RandomUtils.ts");



const behaviorMap = {
    'ATTACK_PLAYER': _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER,
    'WANDER': _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.WANDER,
    'FLEE_FROM_PLAYER': _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.FLEE_FROM_PLAYER,
    'STAY': _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.STAY
};
const HUMAN_CAUTIOUS = {
    issueOrder(unit) {
        const { playerUnit } = jwb.state;
        let behavior;
        const distanceToPlayer = (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.manhattanDistance)(unit, playerUnit);
        if (distanceToPlayer === 1) {
            if ((unit.life / unit.maxLife) >= 0.4) {
                behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER;
            }
            else {
                behavior = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                    'ATTACK_PLAYER': 0.2,
                    'WANDER': 0.5,
                    'FLEE_FROM_PLAYER': 0.3
                }, behaviorMap);
            }
        }
        else if (distanceToPlayer >= 5) {
            behavior = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'WANDER': 0.3,
                'ATTACK_PLAYER': 0.1,
                'STAY': 0.6
            }, behaviorMap);
        }
        else {
            behavior = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'ATTACK_PLAYER': 0.6,
                'WANDER': 0.2,
                'STAY': 0.2
            }, behaviorMap);
        }
        return behavior(unit);
    }
};
const HUMAN_AGGRESSIVE = {
    issueOrder(unit) {
        const { playerUnit } = jwb.state;
        let behavior;
        const distanceToPlayer = (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.manhattanDistance)(unit, playerUnit);
        if (distanceToPlayer === 1) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER;
        }
        else if (distanceToPlayer >= 6) {
            behavior = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'WANDER': 0.4,
                'STAY': 0.4,
                'ATTACK_PLAYER': 0.2
            }, behaviorMap);
        }
        else {
            behavior = (0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'ATTACK_PLAYER': 0.9,
                'STAY': 0.1
            }, behaviorMap);
        }
        return behavior(unit);
    }
};
const HUMAN_DETERMINISTIC = {
    issueOrder(unit) {
        const { playerUnit, turn } = jwb.state;
        const { aiParams } = unit.unitClass;
        if (!aiParams) {
            throw 'HUMAN_DETERMINISTIC behavior requires aiParams!';
        }
        const { speed, visionRange, fleeThreshold } = aiParams;
        let behavior;
        const distanceToPlayer = (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.manhattanDistance)(unit, playerUnit);
        if (!_canMove(speed)) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.STAY;
        }
        else if ((unit.life / unit.maxLife) < fleeThreshold) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.FLEE_FROM_PLAYER;
        }
        else if (distanceToPlayer <= visionRange) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER;
        }
        else {
            if ((0,_utils_RandomUtils__WEBPACK_IMPORTED_MODULE_2__.randInt)(0, 1) === 1) {
                behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.STAY;
            }
            else {
                behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.WANDER;
            }
        }
        return behavior(unit);
    }
};
function _canMove(speed) {
    // deterministic version
    // const { turn } = jwb.state;
    // return Math.floor(speed * turn) > Math.floor(speed * (turn - 1));
    // random version
    return Math.random() < speed;
}



/***/ }),

/***/ "./src/main/units/controllers/PlayerUnitController.ts":
/*!************************************************************!*\
  !*** ./src/main/units/controllers/PlayerUnitController.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class PlayerUnitController {
    constructor() {
        this.queuedOrder = null;
    }
    issueOrder(unit) {
        if (!!this.queuedOrder) {
            const { queuedOrder } = this;
            this.queuedOrder = null;
            return queuedOrder();
        }
        return Promise.resolve();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlayerUnitController);


/***/ }),

/***/ "./src/main/utils/ArrayUtils.ts":
/*!**************************************!*\
  !*** ./src/main/utils/ArrayUtils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sortBy": () => (/* binding */ sortBy),
/* harmony export */   "sortByReversed": () => (/* binding */ sortByReversed),
/* harmony export */   "comparing": () => (/* binding */ comparing),
/* harmony export */   "comparingReversed": () => (/* binding */ comparingReversed),
/* harmony export */   "average": () => (/* binding */ average)
/* harmony export */ });
function sortBy(list, mapFunction) {
    return list.sort((a, b) => mapFunction(a) - mapFunction(b));
}
function sortByReversed(list, mapFunction) {
    return list.sort((a, b) => mapFunction(b) - mapFunction(a));
}
function comparing(mapFunction) {
    return (a, b) => mapFunction(a) - mapFunction(b);
}
function comparingReversed(mapFunction) {
    return (a, b) => mapFunction(b) - mapFunction(a);
}
function average(list) {
    const sum = list.reduce((a, b) => a + b);
    return sum / list.length;
}



/***/ }),

/***/ "./src/main/utils/Pathfinder.ts":
/*!**************************************!*\
  !*** ./src/main/utils/Pathfinder.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _RandomUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RandomUtils */ "./src/main/utils/RandomUtils.ts");


const CARDINAL_DIRECTIONS = [[0, -1], [1, 0], [0, 1], [-1, 0]];
/**
 * @return the exact cost of the path from `start` to `coordinates`
 */
function g(node, start) {
    return node.cost;
}
/**
 * @return the heuristic estimated cost from `coordinates` to `goal`
 */
function h(coordinates, goal) {
    // return civDistance(coordinates, goal);
    return (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.manhattanDistance)(coordinates, goal);
}
/**
 * @return an estimate of the best cost from `start` to `goal` combining both `g` and `h`
 */
function f(node, start, goal) {
    return g(node, start) + h(node, goal);
}
function traverseParents(node) {
    const path = [];
    for (let currentNode = node; !!currentNode; currentNode = currentNode.parent) {
        const coordinates = { x: currentNode.x, y: currentNode.y };
        path.splice(0, 0, coordinates); // add it at the beginning of the list
    }
    return path;
}
/**
 * http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
 */
class Pathfinder {
    /**
     * http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
     */
    constructor(tileCostCalculator) {
        this._tileCostCalculator = tileCostCalculator;
    }
    /**
     * http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#sketch
     *
     * @param tiles All allowable unblocked tiles
     */
    findPath(start, goal, tiles) {
        const open = [
            { x: start.x, y: start.y, cost: 0, parent: null }
        ];
        const closed = [];
        while (true) {
            if (open.length === 0) {
                return [];
            }
            const nodeCosts = open.map(node => ({ node, cost: f(node, start, goal) }))
                .sort((a, b) => a.cost - b.cost);
            const bestNode = nodeCosts[0].node;
            if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(bestNode, goal)) {
                // Done!
                return traverseParents(bestNode);
            }
            else {
                const bestNodes = nodeCosts.filter(({ node, cost }) => cost === nodeCosts[0].cost);
                const { node: chosenNode, cost: chosenNodeCost } = (0,_RandomUtils__WEBPACK_IMPORTED_MODULE_1__.randChoice)(bestNodes);
                open.splice(open.indexOf(chosenNode), 1);
                closed.push(chosenNode);
                this._findNeighbors(chosenNode, tiles).forEach(neighbor => {
                    if (closed.some(coordinates => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(coordinates, neighbor))) {
                        // already been seen, don't need to look at it*
                    }
                    else if (open.some(coordinates => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(coordinates, neighbor))) {
                        // don't need to look at it now, will look later?
                    }
                    else {
                        const movementCost = this._tileCostCalculator(chosenNode, neighbor);
                        open.push({
                            x: neighbor.x,
                            y: neighbor.y,
                            cost: chosenNodeCost + movementCost,
                            parent: chosenNode
                        });
                    }
                });
            }
        }
    }
    _findNeighbors(tile, tiles) {
        return CARDINAL_DIRECTIONS
            .map(([dx, dy]) => ({ x: tile.x + dx, y: tile.y + dy }))
            .filter(({ x, y }) => tiles.some(tile => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(tile, { x, y })));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pathfinder);


/***/ }),

/***/ "./src/main/utils/PromiseUtils.ts":
/*!****************************************!*\
  !*** ./src/main/utils/PromiseUtils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "chainPromises": () => (/* binding */ chainPromises),
/* harmony export */   "wait": () => (/* binding */ wait)
/* harmony export */ });
function chainPromises([first, ...rest], input) {
    if (!!first) {
        return first(input).then(output => chainPromises(rest, output));
    }
    return Promise.resolve(input);
}
function wait(milliseconds) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, milliseconds);
    });
}



/***/ }),

/***/ "./src/main/utils/RandomUtils.ts":
/*!***************************************!*\
  !*** ./src/main/utils/RandomUtils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "randInt": () => (/* binding */ randInt),
/* harmony export */   "randChoice": () => (/* binding */ randChoice),
/* harmony export */   "weightedRandom": () => (/* binding */ weightedRandom),
/* harmony export */   "shuffle": () => (/* binding */ shuffle)
/* harmony export */ });
/**
 * @param max inclusive
 */
function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
function randChoice(list) {
    return list[randInt(0, list.length - 1)];
}
/**
 * Fisher-Yates.  Stolen from https://bost.ocks.org/mike/shuffle/
 */
function shuffle(list) {
    let n = list.length;
    // While there remain elements to shuffle...
    while (n > 0) {
        // Pick a remaining element...
        const i = randInt(0, n - 1);
        n--;
        // And swap it with the current element.
        const tmp = list[n];
        list[n] = list[i];
        list[i] = tmp;
    }
}
function weightedRandom(probabilities, mappedObjects) {
    const total = Object.values(probabilities).reduce((a, b) => a + b);
    const rand = Math.random() * total;
    let counter = 0;
    const entries = Object.entries(probabilities);
    for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        counter += value;
        if (counter > rand) {
            return mappedObjects[key];
        }
    }
    throw 'Error in weightedRandom()!';
}



/***/ }),

/***/ "./src/main/utils/TemplateUtils.ts":
/*!*****************************************!*\
  !*** ./src/main/utils/TemplateUtils.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fillTemplate": () => (/* binding */ fillTemplate)
/* harmony export */ });
/**
 * Dynamically populate a template according to {@param template}. which specifies the template string,
 * and {@param variables}, which provides key-value substitutions for each variable in {@param template}.
 */
function fillTemplate(template, variables) {
    const keys = Object.keys(variables);
    const values = Object.values(variables);
    return new Function(...keys, `return \`${template}\`;`)(...values);
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***************************!*\
  !*** ./src/main/index.ts ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/actions */ "./src/main/core/actions.ts");
/* harmony import */ var _core_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/debug */ "./src/main/core/debug.ts");


(0,_core_actions__WEBPACK_IMPORTED_MODULE_0__.initialize)();
(0,_core_debug__WEBPACK_IMPORTED_MODULE_1__.initDebug)();

})();

/******/ })()
;
//# sourceMappingURL=bundle.js.map