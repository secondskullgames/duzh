/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./data/colors.json":
/*!**************************!*\
  !*** ./data/colors.json ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"BLACK":"#000000","WHITE":"#FFFFFF","DARK_GRAY":"#808080","LIGHT_GRAY":"#C0C0C0","DARK_RED":"#800000","RED":"#FF0000","DARK_YELLOW":"#808000","YELLOW":"#FFFF00","DARK_GREEN":"#008000","GREEN":"#00FF00","DARK_TEAL":"#004040","CYAN":"#00FFFF","DARK_BLUE":"#000080","BLUE":"#0000FF","DARK_PURPLE":"#800080","MAGENTA":"#FF00FF","DARK_BROWN":"#804000","LIGHT_BROWN":"#c08040","ORANGE":"#ff8040","LIGHT_PINK":"#ffc0c0","MEDIUM_RED":"#c00000","MEDIUM_BLUE":"#0000c0","DARKER_GRAY":"#404040","TEAL":"#008080"}');

/***/ }),

/***/ "./data/equipment/bronze_chain_mail.json":
/*!***********************************************!*\
  !*** ./data/equipment/bronze_chain_mail.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Bronze Chain Mail","sprite":"mail","mapIcon":"map_mail","char":"S","itemCategory":"ARMOR","slot":"CHEST","paletteSwaps":{"DARK_GRAY":"DARK_BROWN"},"minLevel":-1,"maxLevel":-1}');

/***/ }),

/***/ "./data/equipment/bronze_sword.json":
/*!******************************************!*\
  !*** ./data/equipment/bronze_sword.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Bronze Sword","sprite":"sword","mapIcon":"map_sword","char":"S","itemCategory":"WEAPON","slot":"MELEE_WEAPON","paletteSwaps":{"BLACK":"BLACK","DARK_GRAY":"LIGHT_BROWN","LIGHT_GRAY":"LIGHT_BROWN"},"damage":2,"minLevel":1,"maxLevel":2}');

/***/ }),

/***/ "./data/equipment/fire_sword.json":
/*!****************************************!*\
  !*** ./data/equipment/fire_sword.json ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Fire Sword","sprite":"sword","mapIcon":"map_sword","char":"S","itemCategory":"ItemCategory.WEAPON","slot":"EquipmentSlot.MELEE_WEAPON","paletteSwaps":{"DARK_GRAY":"Colors.YELLOW","LIGHT_GRAY":"Colors.RED","BLACK":"Colors.DARK_RED"},"damage":8,"minLevel":5,"maxLevel":6}');

/***/ }),

/***/ "./data/equipment/iron_chain_mail.json":
/*!*********************************************!*\
  !*** ./data/equipment/iron_chain_mail.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Iron Chain Mail","sprite":"mail","mapIcon":"map_mail","char":"S","itemCategory":"ARMOR","slot":"CHEST","paletteSwaps":{},"minLevel":-1,"maxLevel":-1}');

/***/ }),

/***/ "./data/equipment/iron_helmet.json":
/*!*****************************************!*\
  !*** ./data/equipment/iron_helmet.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Iron Helmet","sprite":"helmet","mapIcon":"map_helmet","char":"S","itemCategory":"ARMOR","slot":"HEAD","paletteSwaps":{},"minLevel":-1,"maxLevel":-1}');

/***/ }),

/***/ "./data/equipment/iron_sword.json":
/*!****************************************!*\
  !*** ./data/equipment/iron_sword.json ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Iron Sword","sprite":"sword","mapIcon":"map_sword","char":"S","itemCategory":"WEAPON","slot":"MELEE_WEAPON","paletteSwaps":{"DARK_GRAY":"BLACK","LIGHT_GRAY":"DARK_GRAY"},"damage":4,"minLevel":3,"maxLevel":4}');

/***/ }),

/***/ "./data/equipment/long_bow.json":
/*!**************************************!*\
  !*** ./data/equipment/long_bow.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Long Bow","sprite":"bow","mapIcon":"map_bow","char":"S","itemCategory":"WEAPON","slot":"RANGED_WEAPON","paletteSwaps":{},"damage":4,"minLevel":5,"maxLevel":6}');

/***/ }),

/***/ "./data/equipment/short_bow.json":
/*!***************************************!*\
  !*** ./data/equipment/short_bow.json ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Short Bow","sprite":"bow","mapIcon":"map_bow","char":"S","itemCategory":"WEAPON","slot":"RANGED_WEAPON","paletteSwaps":{},"damage":2,"minLevel":2,"maxLevel":4}');

/***/ }),

/***/ "./data/equipment/steel_sword.json":
/*!*****************************************!*\
  !*** ./data/equipment/steel_sword.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"Steel Sword","sprite":"sword","mapIcon":"map_sword","char":"S","itemCategory":"WEAPON","slot":"MELEE_WEAPON","paletteSwaps":{"DARK_GRAY":"DARK_GRAY","LIGHT_GRAY":"LIGHT_GRAY"},"damage":6,"minLevel":4,"maxLevel":6}');

/***/ }),

/***/ "./data/sounds/deflected_hit.json":
/*!****************************************!*\
  !*** ./data/sounds/deflected_hit.json ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[400,10],[0,10],[500,15],[0,5],[400,10],[0,5],[400,10],[0,10],[100,10],[0,15],[200,5]]');

/***/ }),

/***/ "./data/sounds/descend_stairs.json":
/*!*****************************************!*\
  !*** ./data/sounds/descend_stairs.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[30,10],[0,5],[80,10],[0,10],[30,10],[0,175],[25,10],[0,5],[75,10],[0,10],[25,10],[0,175],[20,10],[0,5],[70,10],[0,10],[20,10],[0,175],[15,10],[0,5],[65,10],[0,10],[15,10],[0,175],[10,10],[0,5],[60,10],[0,10],[10,10]]');

/***/ }),

/***/ "./data/sounds/enemy_dies.json":
/*!*************************************!*\
  !*** ./data/sounds/enemy_dies.json ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[20,20],[0,10],[30,20],[0,10],[25,20],[0,10],[25,20],[0,5],[40,20],[0,5],[35,20],[0,5],[45,20],[0,5],[25,20],[0,10],[35,20],[0,10],[25,20],[0,10],[30,20],[0,20],[40,10],[0,20],[35,10],[0,20],[45,10],[0,20],[25,5],[0,30],[35,5],[0,30],[20,5],[0,30],[30,5]]');

/***/ }),

/***/ "./data/sounds/enemy_hits_player.json":
/*!********************************************!*\
  !*** ./data/sounds/enemy_hits_player.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[175,5],[0,5],[150,5],[0,5],[300,5],[0,5],[125,5],[0,5],[350,5],[0,10],[100,5],[0,10],[350,5],[0,10],[125,5],[0,10],[300,5],[0,15],[150,5],[0,15],[175,5],[0,20],[150,5],[0,20],[125,5],[0,25],[100,5],[1,25],[100,5]]');

/***/ }),

/***/ "./data/sounds/footstep.json":
/*!***********************************!*\
  !*** ./data/sounds/footstep.json ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[10,10],[0,5],[50,10],[0,10],[10,10],[0,15],[50,10],[0,20],[10,10]]');

/***/ }),

/***/ "./data/sounds/level_up.json":
/*!***********************************!*\
  !*** ./data/sounds/level_up.json ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[1000,50],[800,50],[600,50],[400,50],[200,100],[100,100],[50,150],[150,150],[250,200],[500,500]]');

/***/ }),

/***/ "./data/sounds/open_door.json":
/*!************************************!*\
  !*** ./data/sounds/open_door.json ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[25,40],[50,40],[75,60],[100,60],[125,80],[100,80]]');

/***/ }),

/***/ "./data/sounds/pick_up_item.json":
/*!***************************************!*\
  !*** ./data/sounds/pick_up_item.json ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[50,50],[0,5],[100,50],[0,10],[200,50],[0,20],[400,50]]');

/***/ }),

/***/ "./data/sounds/player_dies.json":
/*!**************************************!*\
  !*** ./data/sounds/player_dies.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[30,20],[0,10],[40,20],[0,10],[25,20],[0,10],[35,20],[0,5],[80,20],[0,5],[45,20],[0,5],[115,20],[0,5],[35,20],[0,10],[75,20],[0,10],[25,20],[0,10],[60,20],[0,20],[50,10],[0,20],[65,10],[0,20],[55,10],[0,20],[35,5],[0,30],[45,5],[0,30],[30,5],[0,30],[40,5]]');

/***/ }),

/***/ "./data/sounds/player_hits_enemy.json":
/*!********************************************!*\
  !*** ./data/sounds/player_hits_enemy.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[175,5],[0,5],[150,5],[0,5],[300,5],[0,5],[125,5],[0,5],[350,5],[0,10],[100,5],[0,10],[350,5],[0,10],[125,5],[0,10],[300,5],[0,15],[150,5],[0,15],[175,5],[0,20],[150,5],[0,20],[125,5],[0,25],[100,5],[1,25],[100,5]]');

/***/ }),

/***/ "./data/sounds/special_attack.json":
/*!*****************************************!*\
  !*** ./data/sounds/special_attack.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[375,10],[0,5],[150,10],[0,5],[400,10],[0,5],[125,10],[0,5],[550,5],[0,10],[100,5],[0,10],[1000,5],[0,10],[125,5],[0,10],[750,5],[0,15],[150,5],[0,15],[375,5],[0,20],[150,10],[0,20],[125,10],[0,25],[100,10],[0,25],[100,10],[0,25],[50,10]]');

/***/ }),

/***/ "./data/sounds/use_potion.json":
/*!*************************************!*\
  !*** ./data/sounds/use_potion.json ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[150,50],[200,50],[250,50],[175,50],[225,50],[275,50],[200,50],[250,50],[300,50]]');

/***/ }),

/***/ "./data/sprites lazy recursive ^\\.\\/.*\\/.*\\.json$":
/*!****************************************************************!*\
  !*** ./data/sprites/ lazy ^\.\/.*\/.*\.json$ namespace object ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./equipment/bow.json": [
		"./data/sprites/equipment/bow.json",
		"data_sprites_equipment_bow_json"
	],
	"./equipment/helmet.json": [
		"./data/sprites/equipment/helmet.json",
		"data_sprites_equipment_helmet_json"
	],
	"./equipment/mail.json": [
		"./data/sprites/equipment/mail.json",
		"data_sprites_equipment_mail_json"
	],
	"./equipment/shield2.json": [
		"./data/sprites/equipment/shield2.json",
		"data_sprites_equipment_shield2_json"
	],
	"./equipment/sword.json": [
		"./data/sprites/equipment/sword.json",
		"data_sprites_equipment_sword_json"
	],
	"./static/map_bow.json": [
		"./data/sprites/static/map_bow.json",
		"data_sprites_static_map_bow_json"
	],
	"./static/map_helmet.json": [
		"./data/sprites/static/map_helmet.json",
		"data_sprites_static_map_helmet_json"
	],
	"./static/map_mail.json": [
		"./data/sprites/static/map_mail.json",
		"data_sprites_static_map_mail_json"
	],
	"./static/map_potion.json": [
		"./data/sprites/static/map_potion.json",
		"data_sprites_static_map_potion_json"
	],
	"./static/map_scroll.json": [
		"./data/sprites/static/map_scroll.json",
		"data_sprites_static_map_scroll_json"
	],
	"./static/map_sword.json": [
		"./data/sprites/static/map_sword.json",
		"data_sprites_static_map_sword_json"
	],
	"./units/player.json": [
		"./data/sprites/units/player.json",
		"data_sprites_units_player_json"
	],
	"./units/snake.json": [
		"./data/sprites/units/snake.json",
		"data_sprites_units_snake_json"
	],
	"./units/zombie.json": [
		"./data/sprites/units/zombie.json",
		"data_sprites_units_zombie_json"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__.t(id, 3);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./data/sprites lazy recursive ^\\.\\/.*\\/.*\\.json$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./data/tilesets lazy recursive ^\\.\\/.*\\.json$":
/*!*************************************************************!*\
  !*** ./data/tilesets/ lazy ^\.\/.*\.json$ namespace object ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./cave.json": [
		"./data/tilesets/cave.json",
		"data_tilesets_cave_json"
	],
	"./dungeon.json": [
		"./data/tilesets/dungeon.json",
		"data_tilesets_dungeon_json"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__.t(id, 3);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./data/tilesets lazy recursive ^\\.\\/.*\\.json$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./data/units/golem.json":
/*!*******************************!*\
  !*** ./data/units/golem.json ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"golem","type":"GOLEM","sprite":"zombie","paletteSwaps":{"DARK_GRAY":"DARKER_GRAY","LIGHT_GRAY":"DARKER_GRAY"},"startingLife":60,"startingMana":null,"startingDamage":10,"minLevel":5,"maxLevel":9,"lifePerLevel":20,"manaPerLevel":null,"damagePerLevel":1,"aiParameters":{"speed":0.92,"visionRange":12,"fleeThreshold":0}}');

/***/ }),

/***/ "./data/units/grunt.json":
/*!*******************************!*\
  !*** ./data/units/grunt.json ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"grunt","type":"HUMAN","sprite":"player","paletteSwaps":{"DARK_GREEN":"DARK_BROWN","GREEN":"DARK_BROWN","CYAN":"ORANGE"},"startingLife":50,"startingMana":null,"startingDamage":3,"minLevel":1,"maxLevel":4,"lifePerLevel":20,"manaPerLevel":null,"damagePerLevel":1,"equipment":["bronze_chain_mail","iron_helmet","bronze_sword"],"aiParameters":{"speed":0.95,"visionRange":8,"fleeThreshold":0.1}}');

/***/ }),

/***/ "./data/units/player.json":
/*!********************************!*\
  !*** ./data/units/player.json ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"player","type":"HUMAN","sprite":"player","paletteSwaps":{"DARK_PURPLE":"DARK_BROWN","MAGENTA":"DARK_GREEN","DARK_BLUE":"DARK_GREEN","CYAN":"LIGHT_PINK","BLACK":"BLACK","DARK_GRAY":"DARK_BROWN","LIGHT_GRAY":"LIGHT_BROWN","DARK_GREEN":"DARK_BROWN","GREEN":"DARK_BROWN","ORANGE":"LIGHT_PINK"},"startingLife":100,"startingMana":100,"startingDamage":10,"minLevel":1,"maxLevel":20,"lifePerLevel":10,"manaPerLevel":0,"damagePerLevel":1,"experienceToNextLevel":[4,6,8,10,12,14,16,18,20]}');

/***/ }),

/***/ "./data/units/snake.json":
/*!*******************************!*\
  !*** ./data/units/snake.json ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"snake","type":"ANIMAL","sprite":"snake","paletteSwaps":{},"startingLife":40,"startingMana":null,"startingDamage":4,"minLevel":1,"maxLevel":2,"lifePerLevel":15,"manaPerLevel":null,"damagePerLevel":1,"aiParameters":{"speed":0.98,"visionRange":10,"fleeThreshold":0.2}}');

/***/ }),

/***/ "./data/units/soldier.json":
/*!*********************************!*\
  !*** ./data/units/soldier.json ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"ENEMY_SOLDIER","type":"HUMAN","sprite":"player","paletteSwaps":{"DARK_GREEN":"DARK_BLUE","GREEN":"DARK_BLUE","CYAN":"ORANGE"},"startingLife":60,"startingMana":null,"startingDamage":4,"minLevel":3,"maxLevel":6,"lifePerLevel":20,"manaPerLevel":null,"damagePerLevel":1,"equipment":["iron_chain_mail","iron_helmet","steel_sword"],"aiParameters":{"speed":0.95,"visionRange":10,"fleeThreshold":0.1}}');

/***/ }),

/***/ "./src/main/core/GameState.ts":
/*!************************************!*\
  !*** ./src/main/core/GameState.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");

/**
 * Global mutable state
 */
class GameState {
    constructor(playerUnit, maps) {
        this.screen = _types_types__WEBPACK_IMPORTED_MODULE_0__.GameScreen.TITLE;
        this.playerUnit = playerUnit;
        this.maps = maps;
        this.mapIndex = 0;
        this._map = null;
        this.messages = [];
        this.turn = 1;
        this.queuedAbility = null;
    }
    getMap() {
        if (!this._map) {
            throw 'Tried to retrieve map before map was loaded';
        }
        return this._map;
    }
    setMap(map) {
        this._map = map;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GameState);


/***/ }),

/***/ "./src/main/core/InputHandler.ts":
/*!***************************************!*\
  !*** ./src/main/core/InputHandler.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attachEvents": () => (/* binding */ attachEvents)
/* harmony export */ });
/* harmony import */ var _TurnHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TurnHandler */ "./src/main/core/TurnHandler.ts");
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _items_ItemUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../items/ItemUtils */ "./src/main/items/ItemUtils.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions */ "./src/main/core/actions.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _units_UnitAbility__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../units/UnitAbility */ "./src/main/units/UnitAbility.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







var KeyCommand;
(function (KeyCommand) {
    KeyCommand["UP"] = "UP";
    KeyCommand["LEFT"] = "LEFT";
    KeyCommand["DOWN"] = "DOWN";
    KeyCommand["RIGHT"] = "RIGHT";
    KeyCommand["SHIFT_UP"] = "SHIFT_UP";
    KeyCommand["SHIFT_LEFT"] = "SHIFT_LEFT";
    KeyCommand["SHIFT_DOWN"] = "SHIFT_DOWN";
    KeyCommand["SHIFT_RIGHT"] = "SHIFT_RIGHT";
    KeyCommand["TAB"] = "TAB";
    KeyCommand["ENTER"] = "ENTER";
    KeyCommand["SPACEBAR"] = "SPACEBAR";
    KeyCommand["M"] = "M";
    KeyCommand["KEY_1"] = "1";
    KeyCommand["KEY_2"] = "2";
    KeyCommand["KEY_3"] = "3";
    KeyCommand["KEY_4"] = "4";
    KeyCommand["KEY_5"] = "5";
    KeyCommand["KEY_6"] = "6";
    KeyCommand["KEY_7"] = "7";
    KeyCommand["KEY_8"] = "8";
    KeyCommand["KEY_9"] = "9";
    KeyCommand["KEY_0"] = "0";
})(KeyCommand || (KeyCommand = {}));
const _mapToCommand = (e) => {
    switch (e.key) {
        case 'w':
        case 'W':
        case 'ArrowUp':
            return (e.shiftKey ? KeyCommand.SHIFT_UP : KeyCommand.UP);
        case 's':
        case 'S':
        case 'ArrowDown':
            return (e.shiftKey ? KeyCommand.SHIFT_DOWN : KeyCommand.DOWN);
        case 'a':
        case 'A':
        case 'ArrowLeft':
            return (e.shiftKey ? KeyCommand.SHIFT_LEFT : KeyCommand.LEFT);
        case 'd':
        case 'D':
        case 'ArrowRight':
            return (e.shiftKey ? KeyCommand.SHIFT_RIGHT : KeyCommand.RIGHT);
        case 'Tab':
            return KeyCommand.TAB;
        case 'Enter':
            return KeyCommand.ENTER;
        case ' ':
            return KeyCommand.SPACEBAR;
        case 'm':
        case 'M':
            return KeyCommand.M;
        case '1':
            return KeyCommand.KEY_1;
        case '2':
            return KeyCommand.KEY_2;
        case '3':
            return KeyCommand.KEY_3;
        case '4':
            return KeyCommand.KEY_4;
        case '5':
            return KeyCommand.KEY_5;
        case '6':
            return KeyCommand.KEY_6;
        case '7':
            return KeyCommand.KEY_7;
        case '8':
            return KeyCommand.KEY_8;
        case '9':
            return KeyCommand.KEY_9;
        case '0':
            return KeyCommand.KEY_0;
    }
    return null;
};
// global state
let BUSY = false;
const keyHandlerWrapper = (e) => __awaiter(void 0, void 0, void 0, function* () {
    if (!BUSY) {
        BUSY = true;
        yield keyHandler(e);
        BUSY = false;
    }
});
const keyHandler = (e) => __awaiter(void 0, void 0, void 0, function* () {
    const command = _mapToCommand(e);
    switch (command) {
        case KeyCommand.UP:
        case KeyCommand.LEFT:
        case KeyCommand.DOWN:
        case KeyCommand.RIGHT:
        case KeyCommand.SHIFT_UP:
        case KeyCommand.SHIFT_DOWN:
        case KeyCommand.SHIFT_LEFT:
        case KeyCommand.SHIFT_RIGHT:
            return _handleArrowKey(command);
        case KeyCommand.SPACEBAR:
            return _TurnHandler__WEBPACK_IMPORTED_MODULE_0__.default.playTurn(null);
        case KeyCommand.ENTER:
            return _handleEnter();
        case KeyCommand.TAB:
            e.preventDefault();
            return _handleTab();
        case KeyCommand.M:
            return _handleMap();
        case KeyCommand.KEY_1:
        case KeyCommand.KEY_2:
        case KeyCommand.KEY_3:
        case KeyCommand.KEY_4:
        case KeyCommand.KEY_5:
        case KeyCommand.KEY_6:
        case KeyCommand.KEY_7:
        case KeyCommand.KEY_8:
        case KeyCommand.KEY_9:
        case KeyCommand.KEY_0:
            return _handleAbility(command);
        default:
            return Promise.resolve();
    }
});
const _handleArrowKey = (command) => __awaiter(void 0, void 0, void 0, function* () {
    const { state } = jwb;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME:
            let dx;
            let dy;
            switch (command) {
                case KeyCommand.UP:
                case KeyCommand.SHIFT_UP:
                    [dx, dy] = [0, -1];
                    break;
                case KeyCommand.DOWN:
                case KeyCommand.SHIFT_DOWN:
                    [dx, dy] = [0, 1];
                    break;
                case KeyCommand.LEFT:
                case KeyCommand.SHIFT_LEFT:
                    [dx, dy] = [-1, 0];
                    break;
                case KeyCommand.RIGHT:
                case KeyCommand.SHIFT_RIGHT:
                    [dx, dy] = [1, 0];
                    break;
                default:
                    throw `Invalid direction command ${command}`;
            }
            const queuedOrder = (() => {
                switch (command) {
                    case KeyCommand.SHIFT_UP:
                    case KeyCommand.SHIFT_DOWN:
                    case KeyCommand.SHIFT_LEFT:
                    case KeyCommand.SHIFT_RIGHT:
                        return (u) => _units_UnitAbility__WEBPACK_IMPORTED_MODULE_6__.default.SHOOT_ARROW.use(u, { dx, dy });
                    default:
                        if (!!jwb.state.queuedAbility) {
                            const ability = jwb.state.queuedAbility;
                            jwb.state.queuedAbility = null;
                            return (u) => ability.use(u, { dx, dy });
                        }
                        return (u) => _units_UnitAbility__WEBPACK_IMPORTED_MODULE_6__.default.ATTACK.use(u, { dx, dy });
                }
            })();
            return _TurnHandler__WEBPACK_IMPORTED_MODULE_0__.default.playTurn(queuedOrder);
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
            const { inventory } = state.playerUnit;
            switch (command) {
                case KeyCommand.UP:
                case KeyCommand.SHIFT_UP:
                    inventory.previousItem();
                    break;
                case KeyCommand.DOWN:
                case KeyCommand.SHIFT_DOWN:
                    inventory.nextItem();
                    break;
                case KeyCommand.LEFT:
                case KeyCommand.SHIFT_LEFT:
                    inventory.previousCategory();
                    break;
                case KeyCommand.RIGHT:
                case KeyCommand.SHIFT_RIGHT:
                    inventory.nextCategory();
                    break;
            }
            return jwb.renderer.render();
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.TITLE:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.VICTORY:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME_OVER:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP:
            return Promise.resolve();
        default:
            throw `Invalid game screen ${state.screen}`;
    }
});
const _handleEnter = () => __awaiter(void 0, void 0, void 0, function* () {
    const { state } = jwb;
    const { playerUnit } = state;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME: {
            const { mapIndex } = state;
            const map = state.getMap();
            const { x, y } = playerUnit;
            if (!map || (mapIndex === null)) {
                throw 'Map is not loaded!';
            }
            const item = map.getItem({ x, y });
            if (!!item) {
                (0,_items_ItemUtils__WEBPACK_IMPORTED_MODULE_2__.pickupItem)(playerUnit, item);
                map.removeItem({ x, y });
            }
            else if (map.getTile({ x, y }).type === 'STAIRS_DOWN') {
                (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_3__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_1__.default.DESCEND_STAIRS);
                yield (0,_actions__WEBPACK_IMPORTED_MODULE_4__.loadMap)(mapIndex + 1);
            }
            return _TurnHandler__WEBPACK_IMPORTED_MODULE_0__.default.playTurn(null);
        }
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY: {
            const { playerUnit } = state;
            const { selectedItem } = playerUnit.inventory;
            if (!!selectedItem) {
                state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
                yield (0,_items_ItemUtils__WEBPACK_IMPORTED_MODULE_2__.useItem)(playerUnit, selectedItem);
                return jwb.renderer.render();
            }
            return Promise.resolve();
        }
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.TITLE:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
            return (0,_actions__WEBPACK_IMPORTED_MODULE_4__.startGame)();
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.VICTORY:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME_OVER:
            return (0,_actions__WEBPACK_IMPORTED_MODULE_4__.returnToTitle)();
        default:
            throw `Unknown game screen: ${state.screen}`;
    }
});
const _handleTab = () => __awaiter(void 0, void 0, void 0, function* () {
    const { state, renderer } = jwb;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
            break;
        default:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY;
            break;
    }
    return renderer.render();
});
const _handleMap = () => __awaiter(void 0, void 0, void 0, function* () {
    const { state, renderer } = jwb;
    switch (state.screen) {
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME;
            break;
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.GAME:
        case _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.INVENTORY:
            state.screen = _types_types__WEBPACK_IMPORTED_MODULE_5__.GameScreen.MINIMAP;
            break;
        default:
            break;
    }
    return renderer.render();
});
const _handleAbility = (command) => __awaiter(void 0, void 0, void 0, function* () {
    const { renderer } = jwb;
    const { playerUnit } = jwb.state;
    // sketchy - recall KEY_1 = '1', etc.
    // player abilities are indexed as (0 => attack, others => specials)
    const index = parseInt(command.toString());
    const ability = playerUnit.abilities[index];
    if (playerUnit.getCooldown(ability) <= 0) {
        jwb.state.queuedAbility = ability;
        yield renderer.render();
    }
    else {
        console.log(`${ability.name} is on cooldown: ${playerUnit.getCooldown(_units_UnitAbility__WEBPACK_IMPORTED_MODULE_6__.default.HEAVY_ATTACK)}`);
    }
});
function attachEvents() {
    window.onkeydown = keyHandlerWrapper;
}



/***/ }),

/***/ "./src/main/core/TurnHandler.ts":
/*!**************************************!*\
  !*** ./src/main/core/TurnHandler.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const playTurn = (playerUnitOrder) => __awaiter(void 0, void 0, void 0, function* () {
    const { playerUnit } = jwb.state;
    const playerController = (playerUnit.controller);
    playerController.queuedOrder = !!playerUnitOrder ? (() => playerUnitOrder(playerUnit)) : null;
    return _update();
});
const _update = () => __awaiter(void 0, void 0, void 0, function* () {
    const { state, renderer } = jwb;
    const { playerUnit } = state;
    const map = state.getMap();
    // make sure the player unit's update happens first
    yield playerUnit.update();
    // other units are processed in unspecified order
    for (const unit of map.units) {
        if (unit !== playerUnit) {
            yield unit.update();
        }
    }
    yield renderer.render();
    state.turn++;
    state.messages = [];
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    playTurn
});


/***/ }),

/***/ "./src/main/core/actions.ts":
/*!**********************************!*\
  !*** ./src/main/core/actions.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initialize": () => (/* binding */ initialize),
/* harmony export */   "loadMap": () => (/* binding */ loadMap),
/* harmony export */   "returnToTitle": () => (/* binding */ returnToTitle),
/* harmony export */   "revealTiles": () => (/* binding */ revealTiles),
/* harmony export */   "startGame": () => (/* binding */ startGame)
/* harmony export */ });
/* harmony import */ var _types_TileFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/TileFactory */ "./src/main/types/TileFactory.ts");
/* harmony import */ var _units_UnitFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../units/UnitFactory */ "./src/main/units/UnitFactory.ts");
/* harmony import */ var _GameState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameState */ "./src/main/core/GameState.ts");
/* harmony import */ var _graphics_SpriteRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/SpriteRenderer */ "./src/main/graphics/SpriteRenderer.ts");
/* harmony import */ var _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../maps/MapFactory */ "./src/main/maps/MapFactory.ts");
/* harmony import */ var _units_UnitClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../units/UnitClass */ "./src/main/units/UnitClass.ts");
/* harmony import */ var _sounds_Music__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../sounds/Music */ "./src/main/sounds/Music.ts");
/* harmony import */ var _InputHandler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./InputHandler */ "./src/main/core/InputHandler.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _units_controllers_PlayerUnitController__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../units/controllers/PlayerUnitController */ "./src/main/units/controllers/PlayerUnitController.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











/*
 * This file defines functions that will be exported to the "global namespace" (window.jwb.*).
 */
const loadMap = (index) => __awaiter(void 0, void 0, void 0, function* () {
    const { state } = jwb;
    if (index >= state.maps.length) {
        _sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.stop();
        jwb.state.screen = _types_types__WEBPACK_IMPORTED_MODULE_8__.GameScreen.VICTORY;
    }
    else {
        state.mapIndex = index;
        // TODO - this isn't memoized
        const mapBuilder = state.maps[index]();
        state.setMap(yield mapBuilder.build());
    }
});
const initialize = () => __awaiter(void 0, void 0, void 0, function* () {
    // @ts-ignore
    window.jwb = window.jwb || {};
    jwb.renderer = new _graphics_SpriteRenderer__WEBPACK_IMPORTED_MODULE_3__.default();
    (0,_InputHandler__WEBPACK_IMPORTED_MODULE_7__.attachEvents)();
    yield _initState();
    _sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.TITLE_THEME);
    return jwb.renderer.render();
});
const _initState = () => __awaiter(void 0, void 0, void 0, function* () {
    const playerUnitController = new _units_controllers_PlayerUnitController__WEBPACK_IMPORTED_MODULE_10__.default();
    const playerUnit = yield _units_UnitFactory__WEBPACK_IMPORTED_MODULE_1__.default.createUnit({
        name: 'player',
        unitClass: _units_UnitClass__WEBPACK_IMPORTED_MODULE_5__.default.PLAYER,
        controller: playerUnitController,
        level: 1,
        coordinates: { x: 0, y: 0 }
    });
    const dungeonTileSet = yield _types_TileFactory__WEBPACK_IMPORTED_MODULE_0__.default.createTileSet('dungeon');
    const caveTileSet = yield _types_TileFactory__WEBPACK_IMPORTED_MODULE_0__.default.createTileSet('cave');
    jwb.state = new _GameState__WEBPACK_IMPORTED_MODULE_2__.default(playerUnit, [
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.ROOMS_AND_CORRIDORS, dungeonTileSet, 1, 32, 24, 10, 5),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.ROOMS_AND_CORRIDORS, dungeonTileSet, 2, 32, 24, 11, 4),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.ROOMS_AND_CORRIDORS, dungeonTileSet, 3, 32, 24, 12, 3),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.BLOB, caveTileSet, 4, 34, 25, 12, 3),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.BLOB, caveTileSet, 5, 36, 26, 13, 3),
        () => _maps_MapFactory__WEBPACK_IMPORTED_MODULE_4__.default.createRandomMap(_types_types__WEBPACK_IMPORTED_MODULE_8__.MapLayout.BLOB, caveTileSet, 6, 38, 27, 14, 3)
    ]);
});
const startGame = () => __awaiter(void 0, void 0, void 0, function* () {
    yield loadMap(0);
    _sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.stop();
    _sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.TITLE_THEME);
    // Music.playSuite(randChoice([SUITE_1, SUITE_2, SUITE_3]));
    return jwb.renderer.render();
});
const returnToTitle = () => __awaiter(void 0, void 0, void 0, function* () {
    yield _initState(); // will set state.screen = TITLE
    _sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.stop();
    _sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_6__.default.TITLE_THEME);
    return jwb.renderer.render();
});
/**
 * Add any tiles the player can currently see to the map's revealed tiles list.
 */
const revealTiles = () => {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    map.rooms.forEach(room => {
        if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__.contains)(room, playerUnit)) {
            for (let y = room.top; y < room.top + room.height; y++) {
                for (let x = room.left; x < room.left + room.width; x++) {
                    if (!(0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__.isTileRevealed)({ x, y })) {
                        map.revealedTiles.push({ x, y });
                    }
                }
            }
        }
    });
    const radius = 2;
    for (let y = playerUnit.y - radius; y <= playerUnit.y + radius; y++) {
        for (let x = playerUnit.x - radius; x <= playerUnit.x + radius; x++) {
            if (!(0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_9__.isTileRevealed)({ x, y })) {
                map.revealedTiles.push({ x, y });
            }
        }
    }
};



/***/ }),

/***/ "./src/main/core/debug.ts":
/*!********************************!*\
  !*** ./src/main/core/debug.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initDebug": () => (/* binding */ initDebug),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/*
 * This file defines additional functions that will be exported to the "global namespace" (window.jwb.*)
 * that are only intended for debugging purposes.
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const revealMap = () => __awaiter(void 0, void 0, void 0, function* () {
    jwb.DEBUG = true;
    return jwb.renderer.render();
});
const killEnemies = () => __awaiter(void 0, void 0, void 0, function* () {
    const map = jwb.state.getMap();
    map.units = map.units.filter(u => u === jwb.state.playerUnit);
    return jwb.renderer.render();
});
const killPlayer = () => __awaiter(void 0, void 0, void 0, function* () {
    const map = jwb.state.getMap();
    const playerUnit = map.units.filter(u => u === jwb.state.playerUnit)[0];
    yield playerUnit.takeDamage(playerUnit.life);
    return jwb.renderer.render();
});
const renderMinimap = () => {
    jwb.state.screen = _types_types__WEBPACK_IMPORTED_MODULE_0__.GameScreen.MINIMAP;
};
function initDebug() {
    // @ts-ignore
    window.jwb = window.jwb || {};
    jwb.debug = jwb.debug || {
        revealMap,
        killEnemies,
        killPlayer
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ initDebug });


/***/ }),

/***/ "./src/main/graphics/FontRenderer.ts":
/*!*******************************************!*\
  !*** ./src/main/graphics/FontRenderer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Fonts": () => (/* binding */ Fonts)
/* harmony export */ });
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _types_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/Color */ "./src/main/types/Color.ts");
/* harmony import */ var _ImageLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageLoader */ "./src/main/graphics/ImageLoader.ts");



// Fonts are partial ASCII table consisting of the "printable characters", 32 to 126
const MIN_CHARACTER_CODE = 32; // ' '
const MAX_CHARACTER_CODE = 126; // '~'
const NUM_CHARACTERS = MAX_CHARACTER_CODE - MIN_CHARACTER_CODE + 1;
const DEFAULT_CHAR = ' ';
const CHARACTERS = (() => {
    const characters = [];
    for (let c = MIN_CHARACTER_CODE; c <= MAX_CHARACTER_CODE; c++) {
        characters.push(String.fromCodePoint(c));
    }
    return characters;
})();
const Fonts = {
    PERFECT_DOS_VGA: {
        name: 'PERFECT_DOS_VGA',
        src: 'dos_perfect_vga_9x15_2',
        width: 9,
        height: 15
    }
};
class FontRenderer {
    constructor() {
        this._loadedFonts = {};
        this._imageMemos = {};
    }
    render(text, font, color) {
        const key = this._getMemoKey(text, font, color);
        if (!!this._imageMemos[key]) {
            return Promise.resolve(this._imageMemos[key]);
        }
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = text.length * font.width;
        canvas.height = font.height;
        return this._loadFont(font)
            .then(fontInstance => {
            for (let i = 0; i < text.length; i++) {
                const c = text.charAt(i);
                const x = i * font.width;
                const imageBitmap = fontInstance.imageMap[c] || fontInstance.imageMap[DEFAULT_CHAR]; // TODO hacky placeholder
                context.drawImage(imageBitmap, x, 0, font.width, font.height);
            }
            return Promise.resolve();
        })
            .then(() => Promise.resolve(context.getImageData(0, 0, canvas.width, canvas.height)))
            .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.replaceColors)(imageData, { [_types_Color__WEBPACK_IMPORTED_MODULE_1__.default.BLACK]: color }))
            .then(imageData => createImageBitmap(imageData))
            .then(imageBitmap => { this._imageMemos[key] = imageBitmap; return imageBitmap; });
    }
    _loadFont(definition) {
        if (this._loadedFonts[definition.name]) {
            return Promise.resolve(this._loadedFonts[definition.name]);
        }
        const width = NUM_CHARACTERS * definition.width;
        return _ImageLoader__WEBPACK_IMPORTED_MODULE_2__.default.loadImage(`fonts/${definition.src}`)
            .then(imageData => createImageBitmap(imageData))
            .then(imageBitmap => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = definition.height;
            const context = canvas.getContext('2d');
            context.drawImage(imageBitmap, 0, 0);
            const imageMap = {};
            const promises = [];
            CHARACTERS.forEach(c => {
                promises.push(this._getCharacterData(definition, context, c.charCodeAt(0))
                    .then(imageData => createImageBitmap(imageData))
                    .then(imageBitmap => {
                    imageMap[c] = imageBitmap;
                }));
            });
            return Promise.all(promises)
                .then(() => {
                const fontInstance = Object.assign(Object.assign({}, definition), { imageMap });
                this._loadedFonts[definition.name] = fontInstance;
                return fontInstance;
            });
        });
    }
    _getCharacterData(definition, context, char) {
        const offset = this._getCharOffset(char);
        const imageData = context.getImageData(offset * definition.width, 0, definition.width, definition.height);
        return (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.applyTransparentColor)(imageData, _types_Color__WEBPACK_IMPORTED_MODULE_1__.default.WHITE);
    }
    _getCharOffset(char) {
        if (char >= MIN_CHARACTER_CODE && char <= MAX_CHARACTER_CODE) {
            return char - MIN_CHARACTER_CODE;
        }
        throw `invalid character code ${char}`;
    }
    _getMemoKey(text, font, color) {
        return `${font.name}_${color}_${text}`;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FontRenderer);



/***/ }),

/***/ "./src/main/graphics/ImageBuilder.ts":
/*!*******************************************!*\
  !*** ./src/main/graphics/ImageBuilder.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _ImageLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageLoader */ "./src/main/graphics/ImageLoader.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const _loadOptional = (filename) => __awaiter(void 0, void 0, void 0, function* () {
    return _ImageLoader__WEBPACK_IMPORTED_MODULE_1__.default.loadImage(filename)
        .catch(e => null);
});
const _loadFirst = (filenames) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = filenames.map(filename => _loadOptional(filename));
    const results = yield Promise.all(promises);
    const imageData = results.filter(p => !!p)[0];
    if (!imageData) {
        throw new Error(`Failed to load images: ${filenames}`);
    }
    return imageData;
});
class ImageBuilder {
    /**
     * @param effects A list of custom transformations to be applied to the image, in order
     */
    constructor(props) {
        this.build = () => __awaiter(this, void 0, void 0, function* () {
            const { filename, transparentColor, paletteSwaps, effects } = this._props;
            let filenames;
            if (this._props.filenames) {
                filenames = this._props.filenames;
            }
            else if (filename) {
                filenames = [filename];
            }
            else {
                throw new Error('No filenames were specified!');
            }
            let imageData = yield _loadFirst(filenames)
                .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.applyTransparentColor)(imageData, transparentColor))
                .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_0__.replaceColors)(imageData, (paletteSwaps || {})));
            for (const effect of (effects || [])) {
                imageData = yield effect(imageData);
            }
            return createImageBitmap(imageData);
        });
        this._props = props;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageBuilder);


/***/ }),

/***/ "./src/main/graphics/ImageLoader.ts":
/*!******************************************!*\
  !*** ./src/main/graphics/ImageLoader.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const CACHE = {};
function _loadImage(filename) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.style.display = 'none';
        const img = document.createElement('img');
        img.addEventListener('load', () => {
            canvas.width = img.width;
            canvas.height = img.height;
            const context = canvas.getContext('2d');
            if (!context) {
                throw 'Couldn\'t get rendering context!';
            }
            context.drawImage(img, 0, 0);
            const imageData = context.getImageData(0, 0, img.width, img.height);
            if (img.parentElement) {
                img.parentElement.removeChild(img);
            }
            if (canvas.parentElement) {
                canvas.parentElement.removeChild(canvas);
            }
            resolve(imageData);
        });
        img.style.display = 'none';
        img.onerror = () => {
            reject(`Failed to load image ${img.src}`);
        };
        img.src = `dist/png/${filename}.png`;
    });
}
function loadImage(filename) {
    if (CACHE[filename] != null) {
        return CACHE[filename];
    }
    const image = _loadImage(filename);
    CACHE[filename] = image;
    return image;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    loadImage
});


/***/ }),

/***/ "./src/main/graphics/ImageUtils.ts":
/*!*****************************************!*\
  !*** ./src/main/graphics/ImageUtils.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyTransparentColor": () => (/* binding */ applyTransparentColor),
/* harmony export */   "replaceColors": () => (/* binding */ replaceColors),
/* harmony export */   "replaceAll": () => (/* binding */ replaceAll),
/* harmony export */   "hex2rgb": () => (/* binding */ hex2rgb)
/* harmony export */ });
function applyTransparentColor(imageData, transparentColor) {
    return new Promise(resolve => {
        const [tr, tg, tb] = hex2rgb(transparentColor);
        const array = new Uint8ClampedArray(imageData.data.length);
        for (let i = 0; i < imageData.data.length; i += 4) {
            // @ts-ignore
            const [r, g, b, a] = imageData.data.slice(i, i + 4);
            array[i] = r;
            array[i + 1] = g;
            array[i + 2] = b;
            if (r === tr && g === tg && b === tb) {
                array[i + 3] = 0;
            }
            else {
                array[i + 3] = a;
            }
        }
        resolve(new ImageData(array, imageData.width, imageData.height));
    });
}
function replaceColors(imageData, colorMap) {
    return new Promise(resolve => {
        if (!colorMap) {
            resolve(imageData);
        }
        const array = new Uint8ClampedArray(imageData.data.length);
        const entries = Object.entries(colorMap);
        const srcRGB = {};
        const destRGB = {};
        entries.forEach(([srcColor, destColor]) => {
            srcRGB[srcColor] = hex2rgb(srcColor);
            destRGB[destColor] = hex2rgb(destColor);
        });
        for (let i = 0; i < imageData.data.length; i += 4) {
            // @ts-ignore
            const [r, g, b, a] = imageData.data.slice(i, i + 4);
            array[i] = r;
            array[i + 1] = g;
            array[i + 2] = b;
            array[i + 3] = a;
            for (let j = 0; j < entries.length; j++) {
                const [srcColor, destColor] = entries[j];
                const [sr, sg, sb] = srcRGB[srcColor];
                const [dr, dg, db] = destRGB[destColor];
                if (r === sr && g === sg && b === sb) {
                    array[i] = dr;
                    array[i + 1] = dg;
                    array[i + 2] = db;
                    break;
                }
            }
        }
        resolve(new ImageData(array, imageData.width, imageData.height));
    });
}
/**
 * Replace all non-transparent colors with the specified `color`.
 */
function replaceAll(imageData, color) {
    return new Promise(resolve => {
        const [dr, dg, db] = hex2rgb(color);
        const array = new Uint8ClampedArray(imageData.data.length);
        for (let i = 0; i < imageData.data.length; i += 4) {
            // @ts-ignore
            const [r, g, b, a] = imageData.data.slice(i, i + 4);
            array[i] = r;
            array[i + 1] = g;
            array[i + 2] = b;
            array[i + 3] = a;
            if (a > 0) {
                array[i] = dr;
                array[i + 1] = dg;
                array[i + 2] = db;
            }
        }
        resolve(new ImageData(array, imageData.width, imageData.height));
    });
}
/**
 * Convert a hex string, e.g. '#00c0ff', to its equivalent RGB values, e.g. (0, 192, 255).
 * This implementation relies on the browser automatically doing this conversion when
 * an element's `backgroundColor` value is set.
 */
function hex2rgb(hex) {
    const div = document.createElement('div');
    div.style.backgroundColor = hex;
    // @ts-ignore
    return div.style.backgroundColor
        .split(/[(),]/)
        .map(c => parseInt(c))
        .filter(c => c != null && !isNaN(c));
}



/***/ }),

/***/ "./src/main/graphics/MinimapRenderer.ts":
/*!**********************************************!*\
  !*** ./src/main/graphics/MinimapRenderer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SpriteRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpriteRenderer */ "./src/main/graphics/SpriteRenderer.ts");
/* harmony import */ var _types_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/Color */ "./src/main/types/Color.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const LIGHT_GRAY = '#c0c0c0';
const DARK_GRAY = '#808080';
const BLACK = '#000000';
class MinimapRenderer {
    constructor() {
        this.render = () => __awaiter(this, void 0, void 0, function* () {
            this.context.fillStyle = _types_Color__WEBPACK_IMPORTED_MODULE_1__.default.BLACK;
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            const map = jwb.state.getMap();
            const m = Math.floor(Math.min(this.canvas.width / map.width, this.canvas.height / map.height));
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    this.context.fillStyle = this._getColor({ x, y });
                    this.context.fillRect(x * m, y * m, m, m);
                }
            }
            const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            return createImageBitmap(imageData);
        });
        this._getColor = ({ x, y }) => {
            if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)(jwb.state.playerUnit, { x, y })) {
                return _types_Color__WEBPACK_IMPORTED_MODULE_1__.default.RED;
            }
            const map = jwb.state.getMap();
            if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_2__.isTileRevealed)({ x, y })) {
                const tileType = map.getTile({ x, y }).type;
                switch (tileType) {
                    case 'FLOOR':
                    case 'FLOOR_HALL':
                    case 'STAIRS_DOWN':
                        return LIGHT_GRAY;
                    case 'WALL':
                    case 'WALL_HALL':
                        return DARK_GRAY;
                    case 'NONE':
                    case 'WALL_TOP':
                    default:
                        return BLACK;
                }
            }
            else {
                return BLACK;
            }
        };
        this.canvas = document.createElement('canvas');
        this.canvas.width = _SpriteRenderer__WEBPACK_IMPORTED_MODULE_0__.default.SCREEN_WIDTH;
        this.canvas.height = _SpriteRenderer__WEBPACK_IMPORTED_MODULE_0__.default.SCREEN_HEIGHT;
        this.context = this.canvas.getContext('2d');
        this.context.imageSmoothingEnabled = false;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MinimapRenderer);


/***/ }),

/***/ "./src/main/graphics/SpriteRenderer.ts":
/*!*********************************************!*\
  !*** ./src/main/graphics/SpriteRenderer.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/Color */ "./src/main/types/Color.ts");
/* harmony import */ var _MinimapRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MinimapRenderer */ "./src/main/graphics/MinimapRenderer.ts");
/* harmony import */ var _FontRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FontRenderer */ "./src/main/graphics/FontRenderer.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _core_actions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/actions */ "./src/main/core/actions.ts");
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _ImageLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ImageLoader */ "./src/main/graphics/ImageLoader.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








const TILE_WIDTH = 32;
const TILE_HEIGHT = 24;
const WIDTH = 20; // in tiles
const HEIGHT = 15; // in tiles
const SCREEN_WIDTH = 640;
const SCREEN_HEIGHT = 360;
const HUD_HEIGHT = 3 * TILE_HEIGHT;
const HUD_LEFT_WIDTH = 5 * TILE_WIDTH;
const HUD_RIGHT_WIDTH = 5 * TILE_WIDTH;
const HUD_MARGIN = 5;
const HUD_BORDER_MARGIN = 3;
const INVENTORY_LEFT = 2 * TILE_WIDTH;
const INVENTORY_TOP = 2 * TILE_HEIGHT;
const INVENTORY_WIDTH = 16 * TILE_WIDTH;
const INVENTORY_HEIGHT = 11 * TILE_HEIGHT;
const INVENTORY_MARGIN = 12;
const ABILITIES_PANEL_HEIGHT = 48;
const ABILITIES_OUTER_MARGIN = 13;
const ABILITIES_INNER_MARGIN = 10;
const ABILITY_ICON_WIDTH = 20;
const ABILITIES_Y_MARGIN = 4;
const LINE_HEIGHT = 16;
const GAME_OVER_FILENAME = 'gameover';
const TITLE_FILENAME = 'title';
const VICTORY_FILENAME = 'victory';
const HUD_FILENAME = 'HUD2';
const INVENTORY_BACKGROUND_FILENAME = 'inventory_background';
const SHADOW_FILENAME = 'shadow';
class SpriteRenderer {
    constructor() {
        this._renderBuffer = () => __awaiter(this, void 0, void 0, function* () {
            const imageBitmap = yield createImageBitmap(this.bufferContext.getImageData(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT));
            yield this.context.drawImage(imageBitmap, 0, 0);
        });
        this._renderGameScreen = () => __awaiter(this, void 0, void 0, function* () {
            (0,_core_actions__WEBPACK_IMPORTED_MODULE_5__.revealTiles)();
            this.bufferContext.fillStyle = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
            this.bufferContext.fillRect(0, 0, this.bufferCanvas.width, this.bufferCanvas.height);
            console.log('started rendering');
            // can't pass direct references to the functions because `this` won't be defined
            yield this._renderTiles();
            yield this._renderItems();
            yield this._renderProjectiles();
            console.log('rendering units');
            yield this._renderUnits();
            console.log('rendered units');
            yield this._renderMessages();
            yield this._renderHUD();
            console.log('done rendering');
        });
        this._renderTiles = () => __awaiter(this, void 0, void 0, function* () {
            const map = jwb.state.getMap();
            const promises = [];
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.isTileRevealed)({ x, y })) {
                        const tile = map.getTile({ x, y });
                        if (!!tile) {
                            promises.push(this._renderElement(tile, { x, y }));
                        }
                    }
                }
            }
            return Promise.all(promises);
        });
        this._renderItems = () => __awaiter(this, void 0, void 0, function* () {
            const map = jwb.state.getMap();
            const promises = [];
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.isTileRevealed)({ x, y })) {
                        const item = map.getItem({ x, y });
                        if (!!item) {
                            promises.push(this._drawEllipse({ x, y }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY)
                                .then(() => this._renderElement(item, { x, y })));
                        }
                    }
                }
            }
            return Promise.all(promises);
        });
        this._renderProjectiles = () => __awaiter(this, void 0, void 0, function* () {
            const map = jwb.state.getMap();
            const promises = [];
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.isTileRevealed)({ x, y })) {
                        const projectile = map.projectiles
                            .filter(p => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.coordinatesEquals)(p, { x, y }))[0];
                        if (!!projectile) {
                            promises.push(this._renderElement(projectile, { x, y }));
                        }
                    }
                }
            }
            return Promise.all(promises);
        });
        this._renderUnits = () => __awaiter(this, void 0, void 0, function* () {
            const { playerUnit } = jwb.state;
            const map = jwb.state.getMap();
            const promises = [];
            for (let y = 0; y < map.height; y++) {
                for (let x = 0; x < map.width; x++) {
                    if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_3__.isTileRevealed)({ x, y })) {
                        const unit = map.getUnit({ x, y });
                        if (!!unit) {
                            let shadowColor;
                            if (unit === playerUnit) {
                                shadowColor = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.GREEN;
                            }
                            else {
                                shadowColor = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY;
                            }
                            promises.push(new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                                yield this._drawEllipse({ x, y }, shadowColor);
                                yield this._renderElement(unit, { x, y });
                                for (const item of unit.equipment.getValues()) {
                                    yield this._renderElement(item, { x, y });
                                }
                                resolve();
                            })));
                        }
                    }
                }
            }
            return Promise.all(promises);
        });
        /**
         * @param color (in hex form)
         */
        this._drawEllipse = ({ x, y }, color) => __awaiter(this, void 0, void 0, function* () {
            const { x: left, y: top } = this._gridToPixel({ x, y });
            const imageData = yield _ImageLoader__WEBPACK_IMPORTED_MODULE_7__.default.loadImage(SHADOW_FILENAME)
                .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_6__.applyTransparentColor)(imageData, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE))
                .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_6__.replaceColors)(imageData, { [_types_Color__WEBPACK_IMPORTED_MODULE_0__.default.BLACK]: color }));
            const imageBitmap = yield createImageBitmap(imageData);
            return this.bufferContext.drawImage(imageBitmap, left, top);
        });
        this._renderInventory = () => __awaiter(this, void 0, void 0, function* () {
            const { playerUnit } = jwb.state;
            const { inventory } = playerUnit;
            const { bufferCanvas, bufferContext } = this;
            const imageData = yield _ImageLoader__WEBPACK_IMPORTED_MODULE_7__.default.loadImage(INVENTORY_BACKGROUND_FILENAME);
            const imageBitmap = yield createImageBitmap(imageData);
            yield this.bufferContext.drawImage(imageBitmap, INVENTORY_LEFT, INVENTORY_TOP, INVENTORY_WIDTH, INVENTORY_HEIGHT);
            // draw equipment
            const equipmentLeft = INVENTORY_LEFT + INVENTORY_MARGIN;
            const itemsLeft = (bufferCanvas.width + INVENTORY_MARGIN) / 2;
            const promises = [];
            promises.push(this._drawText('EQUIPMENT', _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: bufferCanvas.width / 4, y: INVENTORY_TOP + INVENTORY_MARGIN }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
            promises.push(this._drawText('INVENTORY', _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: bufferCanvas.width * 3 / 4, y: INVENTORY_TOP + INVENTORY_MARGIN }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
            // draw equipment items
            // for now, just display them all in one list
            let y = INVENTORY_TOP + 64;
            for (const [slot, equipment] of playerUnit.equipment.getEntries()) {
                promises.push(this._drawText(`${slot} - ${equipment.name}`, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: equipmentLeft, y }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left'));
                y += LINE_HEIGHT;
            }
            // draw inventory categories
            const inventoryCategories = Object.values(_types_types__WEBPACK_IMPORTED_MODULE_4__.ItemCategory);
            const categoryWidth = 60;
            const xOffset = 4;
            for (let i = 0; i < inventoryCategories.length; i++) {
                const x = itemsLeft + i * categoryWidth + (categoryWidth / 2) + xOffset;
                const top = INVENTORY_TOP + 40;
                promises.push(this._drawText(inventoryCategories[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x, y: top }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center'));
                if (inventoryCategories[i] === inventory.selectedCategory) {
                    bufferContext.fillStyle = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
                    bufferContext.fillRect(x - (categoryWidth / 2) + 4, INVENTORY_TOP + 54, categoryWidth - 8, 1);
                }
            }
            // draw inventory items
            if (inventory.selectedCategory) {
                const items = inventory.get(inventory.selectedCategory);
                const x = itemsLeft + 8;
                for (let i = 0; i < items.length; i++) {
                    const y = INVENTORY_TOP + 64 + LINE_HEIGHT * i;
                    let color;
                    if (items[i] === inventory.selectedItem) {
                        color = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.YELLOW;
                    }
                    else {
                        color = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
                    }
                    promises.push(this._drawText(items[i].name, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x, y }, color, 'left'));
                }
            }
            return Promise.all(promises);
        });
        this._isPixelOnScreen = ({ x, y }) => {
            return ((x >= -TILE_WIDTH) &&
                (x <= SCREEN_WIDTH + TILE_WIDTH) &&
                (y >= -TILE_HEIGHT) &&
                (y <= SCREEN_HEIGHT + TILE_HEIGHT));
        };
        this._renderElement = (element, { x, y }) => __awaiter(this, void 0, void 0, function* () {
            const pixel = this._gridToPixel({ x, y });
            if (this._isPixelOnScreen(pixel)) {
                const { sprite } = element;
                if (!!sprite) {
                    yield this._drawSprite(sprite, pixel);
                }
            }
        });
        this._drawSprite = (sprite, { x, y }) => __awaiter(this, void 0, void 0, function* () {
            const image = sprite.getImage();
            if (image) {
                yield this.bufferContext.drawImage(image, x + sprite.dx, y + sprite.dy);
            }
        });
        this._renderMessages = () => __awaiter(this, void 0, void 0, function* () {
            const { bufferContext } = this;
            const { messages } = jwb.state;
            bufferContext.fillStyle = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
            bufferContext.strokeStyle = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
            const left = 0;
            const top = 0;
            for (let i = 0; i < messages.length; i++) {
                const y = top + (LINE_HEIGHT * i);
                bufferContext.fillStyle = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.BLACK;
                bufferContext.fillRect(left, y, SCREEN_WIDTH, LINE_HEIGHT);
                yield this._drawText(messages[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left, y }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left');
            }
        });
        this._renderHUD = () => __awaiter(this, void 0, void 0, function* () {
            yield this._renderHUDFrame();
            yield Promise.all([
                this._renderHUDLeftPanel(),
                this._renderHUDMiddlePanel(),
                this._renderHUDRightPanel(),
            ]);
        });
        this._renderHUDFrame = () => __awaiter(this, void 0, void 0, function* () {
            const imageData = yield _ImageLoader__WEBPACK_IMPORTED_MODULE_7__.default.loadImage(HUD_FILENAME)
                .then(imageData => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_6__.applyTransparentColor)(imageData, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE));
            const imageBitmap = yield createImageBitmap(imageData);
            yield this.bufferContext.drawImage(imageBitmap, 0, SCREEN_HEIGHT - HUD_HEIGHT);
        });
        this._renderHUDMiddlePanel = () => __awaiter(this, void 0, void 0, function* () {
            let left = HUD_LEFT_WIDTH + ABILITIES_OUTER_MARGIN;
            const top = SCREEN_HEIGHT - ABILITIES_PANEL_HEIGHT + HUD_BORDER_MARGIN + ABILITIES_Y_MARGIN;
            const { playerUnit } = jwb.state;
            let keyNumber = 1;
            for (let i = 0; i < playerUnit.abilities.length; i++) {
                const ability = playerUnit.abilities[i];
                if (!!ability.icon) {
                    yield this._renderAbility(ability, left, top);
                    yield this._drawText(`${keyNumber}`, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left + 10, y: top + 24 }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center');
                    left += ABILITIES_INNER_MARGIN + ABILITY_ICON_WIDTH;
                    keyNumber++;
                }
            }
        });
        this._renderHUDRightPanel = () => __awaiter(this, void 0, void 0, function* () {
            const { mapIndex, playerUnit, turn } = jwb.state;
            const left = SCREEN_WIDTH - HUD_RIGHT_WIDTH + HUD_MARGIN;
            const top = SCREEN_HEIGHT - HUD_HEIGHT + HUD_MARGIN;
            const lines = [
                `Turn: ${turn}`,
                `Floor: ${(mapIndex || 0) + 1}`,
            ];
            const experienceToNextLevel = playerUnit.experienceToNextLevel();
            if (experienceToNextLevel !== null) {
                lines.push(`Experience: ${playerUnit.experience}/${experienceToNextLevel}`);
            }
            for (let i = 0; i < lines.length; i++) {
                const y = top + (LINE_HEIGHT * i);
                yield this._drawText(lines[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left, y }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left');
            }
        });
        /**
         * @return the top left pixel
         */
        this._gridToPixel = ({ x, y }) => {
            const { playerUnit } = jwb.state;
            return {
                x: ((x - playerUnit.x) * TILE_WIDTH) + (SCREEN_WIDTH - TILE_WIDTH) / 2,
                y: ((y - playerUnit.y) * TILE_HEIGHT) + (SCREEN_HEIGHT - TILE_HEIGHT) / 2
            };
        };
        this._renderSplashScreen = (filename, text) => __awaiter(this, void 0, void 0, function* () {
            const imageData = yield _ImageLoader__WEBPACK_IMPORTED_MODULE_7__.default.loadImage(filename);
            const imageBitmap = yield createImageBitmap(imageData);
            yield this.bufferContext.drawImage(imageBitmap, 0, 0, this.bufferCanvas.width, this.bufferCanvas.height);
            yield this._drawText(text, _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: 320, y: 300 }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'center');
        });
        this._drawText = (text, font, { x, y }, color, textAlign) => __awaiter(this, void 0, void 0, function* () {
            const imageBitmap = yield this.fontRenderer.render(text, font, color);
            let left;
            switch (textAlign) {
                case 'left':
                    left = x;
                    break;
                case 'center':
                    left = Math.floor(x - imageBitmap.width / 2);
                    break;
                case 'right':
                    left = x + imageBitmap.width;
                    break;
                default:
                    throw 'fux';
            }
            yield this.bufferContext.drawImage(imageBitmap, left, y);
        });
        this._renderMinimap = () => __awaiter(this, void 0, void 0, function* () {
            const minimapRenderer = new _MinimapRenderer__WEBPACK_IMPORTED_MODULE_1__.default();
            const bitmap = yield minimapRenderer.render();
            yield this.bufferContext.drawImage(bitmap, 0, 0);
        });
        this._renderAbility = (ability, left, top) => __awaiter(this, void 0, void 0, function* () {
            let borderColor;
            const { queuedAbility, playerUnit } = jwb.state;
            if (queuedAbility === ability) {
                borderColor = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.GREEN;
            }
            else if (playerUnit.getCooldown(ability) === 0) {
                borderColor = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
            }
            else {
                borderColor = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY;
            }
            const imageData = yield _ImageLoader__WEBPACK_IMPORTED_MODULE_7__.default.loadImage(`abilities/${ability.icon}`)
                .then(image => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_6__.replaceColors)(image, { [_types_Color__WEBPACK_IMPORTED_MODULE_0__.default.DARK_GRAY]: borderColor }));
            const imageBitmap = yield createImageBitmap(imageData);
            yield this.bufferContext.drawImage(imageBitmap, left, top);
        });
        this.container = document.getElementById('container');
        this.container.innerHTML = '';
        this.bufferCanvas = document.createElement('canvas');
        this.bufferCanvas.width = WIDTH * TILE_WIDTH;
        this.bufferCanvas.height = HEIGHT * TILE_HEIGHT;
        this.bufferContext = this.bufferCanvas.getContext('2d');
        this.bufferContext.imageSmoothingEnabled = false;
        this.fontRenderer = new _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.default();
        this.canvas = document.createElement('canvas');
        this.canvas.width = WIDTH * TILE_WIDTH;
        this.canvas.height = HEIGHT * TILE_HEIGHT;
        this.context = this.canvas.getContext('2d');
        this.bufferContext.imageSmoothingEnabled = false;
        this.container.appendChild(this.canvas);
    }
    render() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._renderScreen();
            yield this._renderBuffer();
        });
    }
    _renderScreen() {
        return __awaiter(this, void 0, void 0, function* () {
            const { screen } = jwb.state;
            switch (screen) {
                case _types_types__WEBPACK_IMPORTED_MODULE_4__.GameScreen.TITLE:
                    return this._renderSplashScreen(TITLE_FILENAME, 'PRESS ENTER TO BEGIN');
                case _types_types__WEBPACK_IMPORTED_MODULE_4__.GameScreen.GAME:
                    return this._renderGameScreen();
                case _types_types__WEBPACK_IMPORTED_MODULE_4__.GameScreen.INVENTORY:
                    return this._renderGameScreen()
                        .then(() => this._renderInventory());
                case _types_types__WEBPACK_IMPORTED_MODULE_4__.GameScreen.VICTORY:
                    return this._renderSplashScreen(VICTORY_FILENAME, 'PRESS ENTER TO PLAY AGAIN');
                case _types_types__WEBPACK_IMPORTED_MODULE_4__.GameScreen.GAME_OVER:
                    return this._renderSplashScreen(GAME_OVER_FILENAME, 'PRESS ENTER TO PLAY AGAIN');
                case _types_types__WEBPACK_IMPORTED_MODULE_4__.GameScreen.MINIMAP:
                    return this._renderMinimap();
                default:
                    throw `Invalid screen ${screen}`;
            }
        });
    }
    /**
     * Renders the bottom-left area of the screen, showing information about the player
     */
    _renderHUDLeftPanel() {
        return __awaiter(this, void 0, void 0, function* () {
            const { playerUnit } = jwb.state;
            const lines = [
                playerUnit.name,
                `Level ${playerUnit.level}`,
                `Life: ${playerUnit.life}/${playerUnit.maxLife}`,
                `Damage: ${playerUnit.getDamage()}`,
            ];
            const left = HUD_MARGIN;
            const top = SCREEN_HEIGHT - HUD_HEIGHT + HUD_MARGIN;
            for (let i = 0; i < lines.length; i++) {
                const y = top + (LINE_HEIGHT * i);
                yield this._drawText(lines[i], _FontRenderer__WEBPACK_IMPORTED_MODULE_2__.Fonts.PERFECT_DOS_VGA, { x: left, y }, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE, 'left');
            }
        });
    }
}
SpriteRenderer.SCREEN_WIDTH = SCREEN_WIDTH;
SpriteRenderer.SCREEN_HEIGHT = SCREEN_HEIGHT;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpriteRenderer);


/***/ }),

/***/ "./src/main/graphics/animations/Animations.ts":
/*!****************************************************!*\
  !*** ./src/main/graphics/animations/Animations.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "playAttackingAnimation": () => (/* binding */ playAttackingAnimation),
/* harmony export */   "playArrowAnimation": () => (/* binding */ playArrowAnimation),
/* harmony export */   "playFloorFireAnimation": () => (/* binding */ playFloorFireAnimation)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/PromiseUtils */ "./src/main/utils/PromiseUtils.ts");
/* harmony import */ var _items_ProjectileFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../items/ProjectileFactory */ "./src/main/items/ProjectileFactory.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const FRAME_LENGTH = 150; // milliseconds
const PROJECTILE_FRAME_LENGTH = 50; // milliseconds
function playAttackingAnimation(source, target) {
    return _playAnimation({
        frames: [
            {
                units: [
                    { unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.ATTACKING },
                    { unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.DAMAGED }
                ],
            },
            {
                units: [
                    { unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING },
                    { unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING }
                ]
            }
        ],
        delay: FRAME_LENGTH
    });
}
const playArrowAnimation = (source, direction, coordinatesList, target) => __awaiter(void 0, void 0, void 0, function* () {
    const frames = [];
    // first frame
    {
        const frame = {
            units: [{ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.SHOOTING }]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        }
        frames.push(frame);
    }
    // arrow movement frames
    for (const { x, y } of coordinatesList) {
        const projectile = yield (0,_items_ProjectileFactory__WEBPACK_IMPORTED_MODULE_2__.createArrow)({ x, y }, direction);
        const frame = {
            units: [{ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.SHOOTING }],
            projectiles: [projectile]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        }
        frames.push(frame);
    }
    // last frames
    {
        const frame = {
            units: [
                { unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING }
            ]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.DAMAGED });
        }
        frames.push(frame);
    }
    {
        const frame = {
            units: [{ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING }]
        };
        if (target) {
            frame.units.push({ unit: target, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        }
        frames.push(frame);
    }
    return _playAnimation({
        frames,
        delay: PROJECTILE_FRAME_LENGTH
    });
});
const playFloorFireAnimation = (source, targets) => __awaiter(void 0, void 0, void 0, function* () {
    const frames = [];
    for (let i = 0; i < targets.length; i++) {
        const frame = [];
        frame.push({ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
        for (let j = 0; j < targets.length; j++) {
            const activity = (j === i) ? _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.DAMAGED : _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING;
            frame.push({ unit: targets[j], activity });
        }
        frames.push({ units: frame });
    }
    // last frame (all standing)
    const frame = [];
    frame.push({ unit: source, activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
    for (let i = 0; i < targets.length; i++) {
        frame.push({ unit: targets[i], activity: _types_types__WEBPACK_IMPORTED_MODULE_0__.Activity.STANDING });
    }
    frames.push({ units: frame });
    return _playAnimation({
        frames,
        delay: FRAME_LENGTH
    });
});
const _playAnimation = (animation) => __awaiter(void 0, void 0, void 0, function* () {
    const { delay, frames } = animation;
    for (let i = 0; i < frames.length; i++) {
        const frame = frames[i];
        const map = jwb.state.getMap();
        if (!!frame.projectiles) {
            map.projectiles.push(...frame.projectiles);
        }
        for (let j = 0; j < frame.units.length; j++) {
            const { unit, activity } = frame.units[j];
            unit.activity = activity;
            yield unit.sprite.getImage();
        }
        yield jwb.renderer.render();
        if (i < (frames.length - 1)) {
            yield (0,_utils_PromiseUtils__WEBPACK_IMPORTED_MODULE_1__.wait)(delay);
        }
        for (const projectile of (frame.projectiles || [])) {
            map.removeProjectile(projectile);
        }
    }
});



/***/ }),

/***/ "./src/main/graphics/sprites/DynamicSprite.ts":
/*!****************************************************!*\
  !*** ./src/main/graphics/sprites/DynamicSprite.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./src/main/graphics/sprites/Sprite.ts");

class DynamicSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor({ offsets, paletteSwaps, imageMap, keyFunction }) {
        super(offsets);
        /**
         * @override {@link Sprite#getImage}
         */
        this.getImage = () => {
            const frameKey = this.keyFunction(this.target);
            return this.imageMap[frameKey];
        };
        this.target = null;
        this.paletteSwaps = paletteSwaps;
        this.imageMap = imageMap;
        this.keyFunction = keyFunction;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DynamicSprite);


/***/ }),

/***/ "./src/main/graphics/sprites/Sprite.ts":
/*!*********************************************!*\
  !*** ./src/main/graphics/sprites/Sprite.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class Sprite {
    constructor({ dx, dy }) {
        this.dx = dx;
        this.dy = dy;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sprite);


/***/ }),

/***/ "./src/main/graphics/sprites/SpriteFactory.ts":
/*!****************************************************!*\
  !*** ./src/main/graphics/sprites/SpriteFactory.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/Color */ "./src/main/types/Color.ts");
/* harmony import */ var _types_Direction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/Direction */ "./src/main/types/Direction.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/TemplateUtils */ "./src/main/utils/TemplateUtils.ts");
/* harmony import */ var _ImageBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageBuilder */ "./src/main/graphics/ImageBuilder.ts");
/* harmony import */ var _ImageUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ImageUtils */ "./src/main/graphics/ImageUtils.ts");
/* harmony import */ var _DynamicSprite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DynamicSprite */ "./src/main/graphics/sprites/DynamicSprite.ts");
/* harmony import */ var _StaticSprite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./StaticSprite */ "./src/main/graphics/sprites/StaticSprite.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * Tiles don't use JSON models and are assumed to use baseline parameters (white = transparent, offsets = (0, 0))
 */
const createTileSprite = (filename, paletteSwaps = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const offsets = { dx: 0, dy: 0 };
    const transparentColor = _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE;
    const image = yield new _ImageBuilder__WEBPACK_IMPORTED_MODULE_4__.default({
        filename: `tiles/${filename}`,
        paletteSwaps,
        transparentColor
    }).build();
    return new _StaticSprite__WEBPACK_IMPORTED_MODULE_7__.default(image, offsets);
});
const createStaticSprite = (spriteName, paletteSwaps = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const model = yield loadSpriteModel(spriteName, 'static');
    const { offsets, transparentColor } = model;
    const image = yield new _ImageBuilder__WEBPACK_IMPORTED_MODULE_4__.default({
        filename: model.filename,
        paletteSwaps,
        transparentColor
    }).build();
    return new _StaticSprite__WEBPACK_IMPORTED_MODULE_7__.default(image, offsets);
});
const createUnitSprite = (spriteName, paletteSwaps = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const spriteModel = yield loadSpriteModel(spriteName, 'units');
    const imageMap = yield _loadAnimations('units', spriteModel, paletteSwaps);
    const keyFunction = (unit) => `${unit.activity.toLowerCase()}_${_types_Direction__WEBPACK_IMPORTED_MODULE_1__.default.toString(unit.direction)}`;
    return new _DynamicSprite__WEBPACK_IMPORTED_MODULE_6__.default({
        paletteSwaps,
        imageMap,
        offsets: spriteModel.offsets,
        keyFunction
    });
});
const createEquipmentSprite = (spriteName, paletteSwaps = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const spriteModel = yield loadSpriteModel(spriteName, 'equipment');
    const imageMap = yield _loadAnimations('equipment', spriteModel, paletteSwaps);
    const keyFunction = (equipment) => `${equipment.unit.activity.toLowerCase()}_${_types_Direction__WEBPACK_IMPORTED_MODULE_1__.default.toString(equipment.unit.direction)}`;
    return new _DynamicSprite__WEBPACK_IMPORTED_MODULE_6__.default({
        paletteSwaps,
        imageMap,
        offsets: spriteModel.offsets,
        keyFunction
    });
});
/**
 * TODO - these aren't in JSON but hardcoded here
 */
const createProjectileSprite = (spriteName, direction, paletteSwaps = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const filename = `${spriteName}/${spriteName}_${direction}_1`;
    const offsets = { dx: 0, dy: -8 };
    const image = yield new _ImageBuilder__WEBPACK_IMPORTED_MODULE_4__.default({
        filename,
        paletteSwaps,
        transparentColor: _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE
    }).build();
    return new _StaticSprite__WEBPACK_IMPORTED_MODULE_7__.default(image, offsets);
});
const _loadAnimations = (spriteCategory, spriteModel, paletteSwaps) => __awaiter(void 0, void 0, void 0, function* () {
    const imageMap = {};
    for (const [animationName, animation] of Object.entries(spriteModel.animations)) {
        for (const frame of animation.frames) {
            for (const direction of _types_Direction__WEBPACK_IMPORTED_MODULE_1__.default.values()) {
                const variables = {
                    sprite: spriteModel.name,
                    activity: frame.activity,
                    direction: _types_Direction__WEBPACK_IMPORTED_MODULE_1__.default.toLegacyDirection(direction),
                    number: frame.number
                };
                const patterns = animation.pattern ? [animation.pattern]
                    : spriteModel.patterns ? spriteModel.patterns
                        : spriteModel.pattern ? [spriteModel.pattern]
                            : [];
                const filenames = patterns.map(pattern => `${spriteCategory}/${spriteModel.name}/${pattern}`)
                    .map(pattern => (0,_utils_TemplateUtils__WEBPACK_IMPORTED_MODULE_3__.fillTemplate)(pattern, variables));
                const effects = (animationName === _types_types__WEBPACK_IMPORTED_MODULE_2__.Activity.DAMAGED.toString())
                    ? [(img) => (0,_ImageUtils__WEBPACK_IMPORTED_MODULE_5__.replaceAll)(img, _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE)]
                    : [];
                const image = yield new _ImageBuilder__WEBPACK_IMPORTED_MODULE_4__.default({
                    filenames,
                    transparentColor: _types_Color__WEBPACK_IMPORTED_MODULE_0__.default.WHITE,
                    paletteSwaps,
                    effects
                }).build();
                const frameKey = `${animationName}_${_types_Direction__WEBPACK_IMPORTED_MODULE_1__.default.toString(direction)}`;
                imageMap[frameKey] = image;
            }
        }
    }
    return imageMap;
});
const loadSpriteModel = (name, category) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield __webpack_require__("./data/sprites lazy recursive ^\\.\\/.*\\/.*\\.json$")(`./${category}/${name}.json`)).default;
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    createTileSprite,
    createStaticSprite,
    createUnitSprite,
    createEquipmentSprite,
    createProjectileSprite
});


/***/ }),

/***/ "./src/main/graphics/sprites/StaticSprite.ts":
/*!***************************************************!*\
  !*** ./src/main/graphics/sprites/StaticSprite.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./src/main/graphics/sprites/Sprite.ts");

class StaticSprite extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(image, offsets) {
        super(offsets);
        /**
         * @override {@link Sprite#getImage}
         */
        this.getImage = () => this.image;
        this.image = image;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StaticSprite);


/***/ }),

/***/ "./src/main/items/InventoryItem.ts":
/*!*****************************************!*\
  !*** ./src/main/items/InventoryItem.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class InventoryItem {
    constructor(name, category, onUse) {
        this.name = name;
        this.category = category;
        this.onUse = (unit) => onUse(this, unit);
    }
    use(unit) {
        return this.onUse(unit);
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InventoryItem);


/***/ }),

/***/ "./src/main/items/InventoryMap.ts":
/*!****************************************!*\
  !*** ./src/main/items/InventoryMap.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");

const categories = Object.values(_types_types__WEBPACK_IMPORTED_MODULE_0__.ItemCategory);
/**
 * Contains information about all items held by a particular unit, grouped by category,
 * as well as data about the selected item/category in the inventory menu
 * (although this is only applicable to the player unit)
 */
class InventoryMap {
    constructor() {
        // @ts-ignore
        this._map = {};
        for (const category of categories) {
            this._map[category] = [];
        }
        this.selectedCategory = categories[0];
        this.selectedItem = null;
    }
    add(item) {
        this._map[item.category].push(item);
        if (this.selectedCategory === item.category && this.selectedItem === null) {
            this.selectedItem = item;
        }
    }
    remove(item) {
        const items = this._map[item.category];
        const index = items.indexOf(item);
        items.splice(index, 1);
        if (this.selectedItem === item) {
            this.selectedItem = items[index % items.length] || null;
        }
    }
    nextCategory() {
        const index = categories.indexOf(this.selectedCategory);
        this.selectedCategory = categories[(index + 1) % categories.length];
        this.selectedItem = this._map[this.selectedCategory][0] || null;
    }
    previousCategory() {
        const index = categories.indexOf(this.selectedCategory);
        this.selectedCategory = categories[(index - 1 + categories.length) % categories.length];
        this.selectedItem = this._map[this.selectedCategory][0] || null;
    }
    get(category) {
        return [...this._map[category]];
    }
    nextItem() {
        const items = this._map[this.selectedCategory];
        if (items.length > 0 && this.selectedItem !== null) {
            const index = items.indexOf(this.selectedItem);
            this.selectedItem = items[(index + 1) % items.length];
        }
    }
    previousItem() {
        const items = this._map[this.selectedCategory];
        if (items.length > 0 && this.selectedItem !== null) {
            const index = items.indexOf(this.selectedItem);
            this.selectedItem = items[(index - 1 + items.length) % items.length];
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InventoryMap);


/***/ }),

/***/ "./src/main/items/ItemFactory.ts":
/*!***************************************!*\
  !*** ./src/main/items/ItemFactory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _equipment_Equipment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equipment/Equipment */ "./src/main/items/equipment/Equipment.ts");
/* harmony import */ var _InventoryItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InventoryItem */ "./src/main/items/InventoryItem.ts");
/* harmony import */ var _MapItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MapItem */ "./src/main/items/MapItem.ts");
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/random */ "./src/main/utils/random.ts");
/* harmony import */ var _equipment_EquipmentClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./equipment/EquipmentClass */ "./src/main/items/equipment/EquipmentClass.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../graphics/animations/Animations */ "./src/main/graphics/animations/Animations.ts");
/* harmony import */ var _ItemUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ItemUtils */ "./src/main/items/ItemUtils.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











const createPotion = (lifeRestored) => {
    const onUse = (item, unit) => __awaiter(void 0, void 0, void 0, function* () {
        (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_8__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.USE_POTION);
        const prevLife = unit.life;
        unit.life = Math.min(unit.life + lifeRestored, unit.maxLife);
        jwb.state.messages.push(`${unit.name} used ${item.name} and gained ${(unit.life - prevLife)} life.`);
    });
    return new _InventoryItem__WEBPACK_IMPORTED_MODULE_2__.default('Potion', _types_types__WEBPACK_IMPORTED_MODULE_7__.ItemCategory.POTION, onUse);
};
const createScrollOfFloorFire = (damage) => __awaiter(void 0, void 0, void 0, function* () {
    const onUse = (item, unit) => __awaiter(void 0, void 0, void 0, function* () {
        const map = jwb.state.getMap();
        const adjacentUnits = map.units.filter(u => {
            const dx = unit.x - u.x;
            const dy = unit.y - u.y;
            return ([-1, 0, 1].indexOf(dx) > -1)
                && ([-1, 0, 1].indexOf(dy) > -1)
                && !(dx === 0 && dy === 0);
        });
        yield (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_9__.playFloorFireAnimation)(unit, adjacentUnits);
        for (const adjacentUnit of adjacentUnits) {
            yield adjacentUnit.takeDamage(damage, unit);
        }
    });
    return new _InventoryItem__WEBPACK_IMPORTED_MODULE_2__.default('Scroll of Floor Fire', _types_types__WEBPACK_IMPORTED_MODULE_7__.ItemCategory.SCROLL, onUse);
});
const _createMapEquipment = (equipmentClass, { x, y }) => __awaiter(void 0, void 0, void 0, function* () {
    const sprite = yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_4__.default.createStaticSprite(equipmentClass.mapIcon, equipmentClass.paletteSwaps);
    const inventoryItem = yield _createInventoryWeapon(equipmentClass);
    return new _MapItem__WEBPACK_IMPORTED_MODULE_3__.default({ x, y }, equipmentClass.char, sprite, inventoryItem);
});
const _createInventoryWeapon = (equipmentClass) => __awaiter(void 0, void 0, void 0, function* () {
    const onUse = (item, unit) => {
        return (0,_ItemUtils__WEBPACK_IMPORTED_MODULE_10__.equipItem)(item, equipmentClass, unit);
    };
    return new _InventoryItem__WEBPACK_IMPORTED_MODULE_2__.default(equipmentClass.name, equipmentClass.itemCategory, onUse);
});
const createEquipment = (name) => __awaiter(void 0, void 0, void 0, function* () {
    const equipmentClass = _equipment_EquipmentClass__WEBPACK_IMPORTED_MODULE_6__.default.forName(name);
    const sprite = yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_4__.default.createEquipmentSprite(equipmentClass.sprite, equipmentClass.paletteSwaps);
    const equipment = yield new _equipment_Equipment__WEBPACK_IMPORTED_MODULE_1__.default(_equipment_EquipmentClass__WEBPACK_IMPORTED_MODULE_6__.default.forName(name), sprite, null);
    sprite.target = equipment;
    return equipment;
});
const _getItemSuppliers = (level) => {
    const createMapPotion = ({ x, y }) => __awaiter(void 0, void 0, void 0, function* () {
        const sprite = yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_4__.default.createStaticSprite('map_potion');
        const inventoryItem = createPotion(40);
        return new _MapItem__WEBPACK_IMPORTED_MODULE_3__.default({ x, y }, 'K', sprite, inventoryItem);
    });
    const createFloorFireScroll = ({ x, y }) => __awaiter(void 0, void 0, void 0, function* () {
        const sprite = yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_4__.default.createStaticSprite('map_scroll');
        const inventoryItem = yield createScrollOfFloorFire(80);
        return new _MapItem__WEBPACK_IMPORTED_MODULE_3__.default({ x, y }, 'K', sprite, inventoryItem);
    });
    return [createMapPotion, createFloorFireScroll];
};
const _getEquipmentSuppliers = (level) => {
    return _equipment_EquipmentClass__WEBPACK_IMPORTED_MODULE_6__.default.values()
        .filter(equipmentClass => level >= equipmentClass.minLevel)
        .filter(equipmentClass => level <= equipmentClass.maxLevel)
        .map(equipmentClass => ({ x, y }) => _createMapEquipment(equipmentClass, { x, y }));
};
const createRandomItem = ({ x, y }, level) => __awaiter(void 0, void 0, void 0, function* () {
    let supplier;
    if ((0,_utils_random__WEBPACK_IMPORTED_MODULE_5__.randInt)(0, 2) === 0) {
        supplier = (0,_utils_random__WEBPACK_IMPORTED_MODULE_5__.randChoice)(_getItemSuppliers(level));
    }
    else {
        supplier = (0,_utils_random__WEBPACK_IMPORTED_MODULE_5__.randChoice)(_getEquipmentSuppliers(level));
    }
    return supplier({ x, y });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    createEquipment,
    createRandomItem
});


/***/ }),

/***/ "./src/main/items/ItemUtils.ts":
/*!*************************************!*\
  !*** ./src/main/items/ItemUtils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pickupItem": () => (/* binding */ pickupItem),
/* harmony export */   "useItem": () => (/* binding */ useItem),
/* harmony export */   "equipItem": () => (/* binding */ equipItem)
/* harmony export */ });
/* harmony import */ var _ItemFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ItemFactory */ "./src/main/items/ItemFactory.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const pickupItem = (unit, mapItem) => {
    const { state } = jwb;
    const { inventoryItem } = mapItem;
    unit.inventory.add(inventoryItem);
    state.messages.push(`Picked up a ${inventoryItem.name}.`);
    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_1__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_2__.default.PICK_UP_ITEM);
};
const useItem = (unit, item) => __awaiter(void 0, void 0, void 0, function* () {
    yield item.use(unit);
    unit.inventory.remove(item);
});
const equipItem = (item, equipmentClass, unit) => __awaiter(void 0, void 0, void 0, function* () {
    const equipment = yield _ItemFactory__WEBPACK_IMPORTED_MODULE_0__.default.createEquipment(equipmentClass.name);
    unit.equipment.add(equipment);
    equipment.attach(unit);
});



/***/ }),

/***/ "./src/main/items/MapItem.ts":
/*!***********************************!*\
  !*** ./src/main/items/MapItem.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class MapItem {
    constructor({ x, y }, char, sprite, inventoryItem) {
        this.x = x;
        this.y = y;
        this.char = char;
        this.sprite = sprite;
        this.inventoryItem = inventoryItem;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapItem);


/***/ }),

/***/ "./src/main/items/ProjectileFactory.ts":
/*!*********************************************!*\
  !*** ./src/main/items/ProjectileFactory.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createArrow": () => (/* binding */ createArrow)
/* harmony export */ });
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

const createArrow = ({ x, y }, direction) => __awaiter(void 0, void 0, void 0, function* () {
    return ({
        x,
        y,
        direction,
        sprite: yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.createProjectileSprite('arrow', direction, {}),
        char: 'x'
    });
});



/***/ }),

/***/ "./src/main/items/equipment/Equipment.ts":
/*!***********************************************!*\
  !*** ./src/main/items/equipment/Equipment.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class Equipment {
    constructor(equipmentClass, sprite, inventoryItem) {
        this.name = equipmentClass.name;
        this.slot = equipmentClass.slot;
        this.inventoryItem = inventoryItem;
        this.damage = equipmentClass.damage;
        this.sprite = sprite;
    }
    attach(unit) {
        this.unit = unit;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Equipment);


/***/ }),

/***/ "./src/main/items/equipment/EquipmentClass.ts":
/*!****************************************************!*\
  !*** ./src/main/items/equipment/EquipmentClass.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_equipment_bronze_sword_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/equipment/bronze_sword.json */ "./data/equipment/bronze_sword.json");
/* harmony import */ var _data_equipment_iron_sword_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../data/equipment/iron_sword.json */ "./data/equipment/iron_sword.json");
/* harmony import */ var _data_equipment_steel_sword_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../data/equipment/steel_sword.json */ "./data/equipment/steel_sword.json");
/* harmony import */ var _data_equipment_fire_sword_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/equipment/fire_sword.json */ "./data/equipment/fire_sword.json");
/* harmony import */ var _data_equipment_short_bow_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../data/equipment/short_bow.json */ "./data/equipment/short_bow.json");
/* harmony import */ var _data_equipment_long_bow_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../data/equipment/long_bow.json */ "./data/equipment/long_bow.json");
/* harmony import */ var _data_equipment_bronze_chain_mail_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../data/equipment/bronze_chain_mail.json */ "./data/equipment/bronze_chain_mail.json");
/* harmony import */ var _data_equipment_iron_chain_mail_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../data/equipment/iron_chain_mail.json */ "./data/equipment/iron_chain_mail.json");
/* harmony import */ var _data_equipment_iron_helmet_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../data/equipment/iron_helmet.json */ "./data/equipment/iron_helmet.json");
/* harmony import */ var _types_PaletteSwaps__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../types/PaletteSwaps */ "./src/main/types/PaletteSwaps.ts");










function _load(json) {
    // ugh
    return Object.assign(Object.assign({}, json), { 
        // We're using "friendly" color names, convert them to hex now
        paletteSwaps: _types_PaletteSwaps__WEBPACK_IMPORTED_MODULE_9__.default.create(json.paletteSwaps) });
}
const _map = {
    bronze_sword: _load(_data_equipment_bronze_sword_json__WEBPACK_IMPORTED_MODULE_0__),
    iron_sword: _load(_data_equipment_iron_sword_json__WEBPACK_IMPORTED_MODULE_1__),
    steel_sword: _load(_data_equipment_steel_sword_json__WEBPACK_IMPORTED_MODULE_2__),
    fire_sword: _load(_data_equipment_fire_sword_json__WEBPACK_IMPORTED_MODULE_3__),
    short_bow: _load(_data_equipment_short_bow_json__WEBPACK_IMPORTED_MODULE_4__),
    long_bow: _load(_data_equipment_long_bow_json__WEBPACK_IMPORTED_MODULE_5__),
    bronze_chain_mail: _load(_data_equipment_bronze_chain_mail_json__WEBPACK_IMPORTED_MODULE_6__),
    iron_chain_mail: _load(_data_equipment_iron_chain_mail_json__WEBPACK_IMPORTED_MODULE_7__),
    iron_helmet: _load(_data_equipment_iron_helmet_json__WEBPACK_IMPORTED_MODULE_8__)
};
var EquipmentClass;
(function (EquipmentClass) {
    EquipmentClass.forName = (name) => {
        if (_map.hasOwnProperty(name)) {
            return _load(_map[name]);
        }
        throw `Unknown equipment "${name}"!`;
    };
    EquipmentClass.values = () => Object.values(_map);
})(EquipmentClass || (EquipmentClass = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EquipmentClass);


/***/ }),

/***/ "./src/main/items/equipment/EquipmentMap.ts":
/*!**************************************************!*\
  !*** ./src/main/items/equipment/EquipmentMap.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Represent's a unit's equipment, mapped by slot.
 */
class EquipmentMap {
    constructor() {
        this._map = {};
    }
    add(item) {
        this._map[item.slot] = item;
    }
    remove(item) {
        this._map[item.slot] = undefined;
    }
    get(category) {
        return this._map[category] || null;
    }
    getEntries() {
        return [...Object.entries(this._map)];
    }
    getValues() {
        return [...Object.values(this._map)];
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EquipmentMap);


/***/ }),

/***/ "./src/main/maps/MapBuilder.ts":
/*!*************************************!*\
  !*** ./src/main/maps/MapBuilder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapInstance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapInstance */ "./src/main/maps/MapInstance.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class MapBuilder {
    constructor(level, width, height, tiles, rooms, playerUnitLocation, enemyUnitLocations, enemyUnitSupplier, itemLocations, itemSupplier) {
        this.build = () => __awaiter(this, void 0, void 0, function* () {
            const { playerUnit } = jwb.state;
            [playerUnit.x, playerUnit.y] = [this.playerUnitLocation.x, this.playerUnitLocation.y];
            const units = [playerUnit];
            for (const { x, y } of this.enemyUnitLocations) {
                const enemyUnit = yield this.enemyUnitSupplier({ x, y }, this.level);
                units.push(enemyUnit);
            }
            const items = [];
            for (const { x, y } of this.itemLocations) {
                const item = yield this.itemSupplier({ x, y }, this.level);
                items.push(item);
            }
            return new _MapInstance__WEBPACK_IMPORTED_MODULE_0__.default(this.width, this.height, this.tiles, this.rooms, units, items);
        });
        this.level = level;
        this.width = width;
        this.height = height;
        this.tiles = tiles;
        this.rooms = rooms;
        this.playerUnitLocation = playerUnitLocation;
        this.enemyUnitLocations = enemyUnitLocations;
        this.itemLocations = itemLocations;
        this.enemyUnitSupplier = enemyUnitSupplier;
        this.itemSupplier = itemSupplier;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapBuilder);


/***/ }),

/***/ "./src/main/maps/MapFactory.ts":
/*!*************************************!*\
  !*** ./src/main/maps/MapFactory.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _items_ItemFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../items/ItemFactory */ "./src/main/items/ItemFactory.ts");
/* harmony import */ var _units_UnitFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../units/UnitFactory */ "./src/main/units/UnitFactory.ts");
/* harmony import */ var _generation_BlobDungeonGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generation/BlobDungeonGenerator */ "./src/main/maps/generation/BlobDungeonGenerator.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _generation_RoomCorridorDungeonGenerator2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generation/RoomCorridorDungeonGenerator2 */ "./src/main/maps/generation/RoomCorridorDungeonGenerator2.ts");





const createRandomMap = (mapLayout, tileSet, level, width, height, numEnemies, numItems) => {
    const dungeonGenerator = _getDungeonGenerator(mapLayout, tileSet);
    return dungeonGenerator.generateDungeon(level, width, height, numEnemies, _units_UnitFactory__WEBPACK_IMPORTED_MODULE_1__.default.createRandomEnemy, numItems, _items_ItemFactory__WEBPACK_IMPORTED_MODULE_0__.default.createRandomItem);
};
const _getDungeonGenerator = (mapLayout, tileSet) => {
    switch (mapLayout) {
        case _types_types__WEBPACK_IMPORTED_MODULE_3__.MapLayout.ROOMS_AND_CORRIDORS: {
            const minRoomDimension = 3;
            const maxRoomDimension = 7;
            // return new RoomCorridorDungeonGenerator(
            return new _generation_RoomCorridorDungeonGenerator2__WEBPACK_IMPORTED_MODULE_4__.default(tileSet, minRoomDimension, maxRoomDimension);
        }
        case _types_types__WEBPACK_IMPORTED_MODULE_3__.MapLayout.BLOB:
            return new _generation_BlobDungeonGenerator__WEBPACK_IMPORTED_MODULE_2__.default(tileSet);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ createRandomMap });


/***/ }),

/***/ "./src/main/maps/MapInstance.ts":
/*!**************************************!*\
  !*** ./src/main/maps/MapInstance.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class MapInstance {
    constructor(width, height, tiles, rooms, units, items) {
        this.width = width;
        this.height = height;
        this._tiles = tiles;
        this.rooms = rooms;
        this.units = units;
        this.items = items;
        this.projectiles = [];
        this.revealedTiles = [];
    }
    getTile({ x, y }) {
        if (x < this.width && y < this.height) {
            return (this._tiles[y] || [])[x] || 'NONE';
        }
        throw `Illegal coordinates ${x}, ${y}`;
    }
    getUnit({ x, y }) {
        return this.units.filter(u => u.x === x && u.y === y)[0] || null;
    }
    getItem({ x, y }) {
        return this.items.filter(i => i.x === x && i.y === y)[0] || null;
    }
    getProjectile({ x, y }) {
        return this.projectiles.filter(p => p.x === x && p.y === y)[0] || null;
    }
    contains({ x, y }) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height;
    }
    isBlocked({ x, y }) {
        if (!this.contains({ x, y })) {
            throw `(${x}, ${y}) is not on the map`;
        }
        return !!this.getUnit({ x, y }) || this.getTile({ x, y }).isBlocking;
    }
    removeUnit({ x, y }) {
        const index = this.units.findIndex(u => (u.x === x && u.y === y));
        if (index >= 0) {
            this.units.splice(index, 1);
        }
    }
    removeItem({ x, y }) {
        const index = this.items.findIndex(i => (i.x === x && i.y === y));
        if (index >= 0) {
            this.items.splice(index, 1);
        }
    }
    removeProjectile({ x, y }) {
        const index = this.projectiles.findIndex(i => (i.x === x && i.y === y));
        if (index >= 0) {
            this.projectiles.splice(index, 1);
        }
    }
    getRect() {
        return {
            left: 0,
            top: 0,
            width: this.width,
            height: this.height
        };
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapInstance);


/***/ }),

/***/ "./src/main/maps/MapUtils.ts":
/*!***********************************!*\
  !*** ./src/main/maps/MapUtils.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areAdjacent": () => (/* binding */ areAdjacent),
/* harmony export */   "civDistance": () => (/* binding */ civDistance),
/* harmony export */   "contains": () => (/* binding */ contains),
/* harmony export */   "coordinatesEquals": () => (/* binding */ coordinatesEquals),
/* harmony export */   "hypotenuse": () => (/* binding */ hypotenuse),
/* harmony export */   "isAdjacent": () => (/* binding */ isAdjacent),
/* harmony export */   "isBlocking": () => (/* binding */ isBlocking),
/* harmony export */   "isTileRevealed": () => (/* binding */ isTileRevealed),
/* harmony export */   "manhattanDistance": () => (/* binding */ manhattanDistance),
/* harmony export */   "pickUnoccupiedLocations": () => (/* binding */ pickUnoccupiedLocations)
/* harmony export */ });
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");

/**
 * @return `numToChoose` random points from `tiles`, whose tile is in `allowedTileTypes`,
 *         which do not collide with `occupiedLocations`
 */
const pickUnoccupiedLocations = (tiles, allowedTileTypes, occupiedLocations, numToChoose) => {
    const unoccupiedLocations = [];
    for (let y = 0; y < tiles.length; y++) {
        for (let x = 0; x < tiles[y].length; x++) {
            if (allowedTileTypes.indexOf(tiles[y][x]) !== -1) {
                if (occupiedLocations.filter(loc => coordinatesEquals(loc, { x, y })).length === 0) {
                    unoccupiedLocations.push({ x, y });
                }
            }
        }
    }
    const chosenLocations = [];
    for (let i = 0; i < numToChoose; i++) {
        if (unoccupiedLocations.length > 0) {
            (0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_0__.sortBy)(unoccupiedLocations, ({ x, y }) => -1 * Math.min(...chosenLocations.map(loc => hypotenuse(loc, { x, y }))));
            const index = 0;
            const { x, y } = unoccupiedLocations[index];
            chosenLocations.push({ x, y });
            occupiedLocations.push({ x, y });
            unoccupiedLocations.splice(index, 1);
        }
    }
    return chosenLocations;
};
const coordinatesEquals = (first, second) => (first.x === second.x && first.y === second.y);
const contains = (rect, coordinates) => coordinates.x >= rect.left
    && coordinates.x < (rect.left + rect.width)
    && coordinates.y >= rect.top
    && coordinates.y < (rect.top + rect.height);
function manhattanDistance(first, second) {
    return Math.abs(first.x - second.x) + Math.abs(first.y - second.y);
}
const hypotenuse = (first, second) => {
    const dx = second.x - first.x;
    const dy = second.y - first.y;
    return Math.pow(((dx * dx) + (dy * dy)), 0.5);
};
const civDistance = (first, second) => {
    const dx = Math.abs(first.x - second.x);
    const dy = Math.abs(first.y - second.y);
    return Math.max(dx, dy) + Math.min(dx, dy) / 2;
};
const isAdjacent = (first, second) => {
    const dx = Math.abs(first.x - second.x);
    const dy = Math.abs(first.y - second.y);
    return (dx === 0 && (dy === -1 || dy === 1)) || (dy === 0 && (dx === -1 || dx === 1));
};
const isTileRevealed = ({ x, y }) => {
    if (jwb.DEBUG) {
        return true;
    }
    return jwb.state.getMap().revealedTiles.some(tile => coordinatesEquals({ x, y }, tile));
};
const isBlocking = (tileType) => {
    switch (tileType) {
        case 'FLOOR':
        case 'FLOOR_HALL':
        case 'STAIRS_DOWN':
            return false;
        default:
            return true;
    }
};
const areAdjacent = (first, second, minBorderLength) => {
    // right-left
    if (first.left + first.width === second.left) {
        const top = Math.max(first.top, second.top);
        const bottom = Math.min(first.top + first.height, second.top + second.height); // exclusive
        return (bottom - top) >= minBorderLength;
    }
    // bottom-top
    if (first.top + first.height === second.top) {
        const left = Math.max(first.left, second.left);
        const right = Math.min(first.left + first.width, second.left + second.width); // exclusive
        return (right - left) >= minBorderLength;
    }
    // left-right
    if (first.left === second.left + second.width) {
        const top = Math.max(first.top, second.top);
        const bottom = Math.min(first.top + first.height, second.top + second.height); // exclusive
        return (bottom - top) >= minBorderLength;
    }
    // top-bottom
    if (first.top === second.top + second.height) {
        const left = Math.max(first.left, second.left);
        const right = Math.min(first.left + first.width, second.left + second.width); // exclusive
        return (right - left) >= minBorderLength;
    }
    return false;
};



/***/ }),

/***/ "./src/main/maps/generation/BlobDungeonGenerator.ts":
/*!**********************************************************!*\
  !*** ./src/main/maps/generation/BlobDungeonGenerator.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DungeonGenerator */ "./src/main/maps/generation/DungeonGenerator.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/random */ "./src/main/utils/random.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");




class BlobDungeonGenerator extends _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(tileSet) {
        super(tileSet);
        this._placeInitialTile = (width, height, tiles) => {
            const x = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(width * 3 / 8, width * 5 / 8);
            const y = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(height * 3 / 8, height * 5 / 8);
            tiles[y][x] = 'FLOOR';
        };
        this._getTargetNumFloorTiles = (max) => {
            const minRatio = 0.4;
            const maxRatio = 0.7;
            return (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(Math.round(max * minRatio), Math.round(max * maxRatio));
        };
        this._getFloorTiles = (tiles) => {
            const floorTiles = [];
            for (let y = 0; y < tiles.length; y++) {
                for (let x = 0; x < tiles[y].length; x++) {
                    if (tiles[y][x] === 'FLOOR') {
                        floorTiles.push({ x, y });
                    }
                }
            }
            return floorTiles;
        };
        this._getEmptyTiles = (tiles) => {
            const floorTiles = [];
            for (let y = 0; y < tiles.length; y++) {
                for (let x = 0; x < tiles[y].length; x++) {
                    if (tiles[y][x] === 'NONE') {
                        floorTiles.push({ x, y });
                    }
                }
            }
            return floorTiles;
        };
        /**
         * @return whether a tile was successfully added
         */
        this._addFloorTile = (tiles) => {
            const floorTiles = this._getFloorTiles(tiles);
            const candidates = this._getCandidates(tiles, floorTiles)
                .sort((0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_3__.comparing)(tile => this._getSnakeScore(tile, tiles)));
            if (candidates.length === 0) {
                return false;
            }
            // change these ratios to adjust the "snakiness"
            const minIndex = Math.floor((candidates.length - 1) * 0.6);
            const maxIndex = Math.floor((candidates.length - 1) * 0.8);
            const index = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(minIndex, maxIndex);
            const { x, y } = candidates[index];
            tiles[y][x] = 'FLOOR';
            return true;
        };
        this._getCandidates = (tiles, floorTiles) => {
            return this._getEmptyTiles(tiles)
                .filter(({ x, y }) => y > 0)
                .filter(({ x, y }) => this._isLegalWallCoordinates({ x, y }, tiles))
                .filter(({ x, y }) => floorTiles.some(floorTile => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.isAdjacent)({ x, y }, floorTile)));
        };
        this._hasKittyCornerFloorTile = ({ x, y }, tiles) => {
            const height = tiles.length;
            const width = tiles[0].length;
            // one tile apart vertically
            for (const [dx, dy] of [[-1, -1], [1, -1], [-1, 1], [1, 1]]) {
                const [x2, y2] = [x + dx, y + dy];
                if (x2 < 0 || x2 >= width || y2 < 0 || y2 >= height) {
                    // out of bounds
                }
                else if (tiles[y2][x2] === 'FLOOR') {
                    if (tiles[y2][x] === 'NONE' && tiles[y][x2] === 'NONE') {
                        return true;
                    }
                }
            }
            // two tiles apart vertically
            // @X        ab
            // XX        cd
            //  F        ef
            for (const [dx, dy] of [[-1, -2], [1, -2], [-1, 2], [1, 2]]) {
                const a = { x, y };
                const b = { x: x + dx, y };
                const c = { x, y: y + (dy / 2) };
                const d = { x: x + dx, y: y + (dy / 2) };
                const e = { x, y: y + dy };
                const f = { x: x + dx, y: y + dy };
                if (f.x < 0 || f.x >= width || f.y < 0 || f.y >= height) {
                    // out of bounds
                }
                else {
                    if (tiles[b.y][b.x] === 'NONE'
                        && tiles[c.y][c.x] === 'NONE'
                        && tiles[d.y][d.x] === 'NONE'
                        && tiles[f.y][f.x] === 'FLOOR') {
                        return true;
                    }
                }
            }
            return false;
        };
        this._addWalls = (tiles) => {
            const height = tiles.length;
            const width = tiles[0].length;
            for (let y = 0; y < (height - 1); y++) {
                for (let x = 0; x < width; x++) {
                    if (tiles[y][x] === 'NONE' && tiles[y + 1][x] === 'FLOOR') {
                        tiles[y][x] = 'WALL_TOP';
                    }
                }
            }
        };
        /**
         * @param end inclusive
         */
        this._range = (start, end) => {
            const range = [];
            for (let i = start; i <= end; i++) {
                range.push(i);
            }
            return range;
        };
        /**
         * @return the number of nearby tiles
         */
        this._getSnakeScore = (tile, tiles) => {
            let score = 0;
            const offset = 1;
            const height = tiles.length;
            const width = tiles[0].length;
            const minY = Math.max(0, tile.y - offset);
            const maxY = Math.min(tile.y + offset, height - 1);
            const minX = Math.max(0, tile.x - offset);
            const maxX = Math.min(tile.x + offset, width - 1);
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if ((0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)(tile, { x, y })) {
                        continue;
                    }
                    if (tiles[y][x] === 'FLOOR') {
                        score++;
                    }
                }
            }
            return score;
        };
    }
    /**
     * Strategy:
     * Add a floor tile near the middle of the map.
     * Until the map is half-full, continue adding new tiles adjacent to existing tiles.
     * New tile placement should be random - but aim for a certain level of "snakiness",
     * where snakiness is defined as the number of tiles within N units
     * (more adjacent tiles - less snaky).
     */
    generateTiles(width, height) {
        const tiles = this._initTiles(width, height);
        this._placeInitialTile(width, height, tiles);
        const targetNumFloorTiles = this._getTargetNumFloorTiles(width * height);
        while (this._getFloorTiles(tiles).length < targetNumFloorTiles) {
            if (!this._addFloorTile(tiles)) {
                break;
            }
        }
        this._addWalls(tiles);
        return {
            tiles,
            width,
            height,
            rooms: []
        };
    }
    _initTiles(width, height) {
        const tiles = [];
        for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
                row.push('NONE');
            }
            tiles.push(row);
        }
        return tiles;
    }
    _isLegalWallCoordinates({ x, y }, tiles) {
        // To facilitate wall generation, disallow some specific cases:
        // 1. can't add a floor tile if there's a wall right above it, AND a floor tile right above that
        const height = tiles.length;
        const m = 3; // number of consecutive wall tiles required
        for (let n = 2; n <= m; n++) {
            if (y >= n) {
                if (this._range(y - (n - 1), y - 1).every(y2 => tiles[y2][x] === 'NONE')
                    && (tiles[y - n][x] === 'FLOOR')) {
                    return false;
                }
            }
            // 2. can't add a floor tile if there's a wall right below it, AND a floor tile right below that
            if (y <= (height - 1 - n)) {
                if (this._range(y + 1, y + (n - 1)).every(y2 => tiles[y2][x] === 'NONE')
                    && (tiles[y + n][x] === 'FLOOR')) {
                    return false;
                }
            }
            // 3. check for kitty corner floor tiles
            if (this._hasKittyCornerFloorTile({ x, y }, tiles)) {
                return false;
            }
        }
        return true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlobDungeonGenerator);


/***/ }),

/***/ "./src/main/maps/generation/DungeonGenerator.ts":
/*!******************************************************!*\
  !*** ./src/main/maps/generation/DungeonGenerator.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_TileFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/TileFactory */ "./src/main/types/TileFactory.ts");
/* harmony import */ var _MapBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBuilder */ "./src/main/maps/MapBuilder.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");
/* harmony import */ var _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/Pathfinder */ "./src/main/utils/Pathfinder.ts");
/* harmony import */ var _TileEligibilityChecker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TileEligibilityChecker */ "./src/main/maps/generation/TileEligibilityChecker.ts");






class DungeonGenerator {
    constructor(tileSet) {
        this.generateDungeon = (level, width, height, numEnemies, enemyUnitSupplier, numItems, itemSupplier) => {
            let section;
            let isValid = false;
            let iterations = 0;
            do {
                const t1 = new Date().getTime();
                section = this.generateTiles(width, height);
                isValid = this._validateSection(section);
                const t2 = new Date().getTime();
                console.log(`Generated dungeon tiles for level ${level} in ${t2 - t1} ms`);
                if (!isValid) {
                    console.error(`Generated invalid tiles for level ${level}, regenerating`);
                }
                iterations++;
            } while (!isValid && (iterations < 100));
            const tileTypes = section.tiles;
            const [stairsLocation] = (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.pickUnoccupiedLocations)(tileTypes, ['FLOOR'], [], 1);
            tileTypes[stairsLocation.y][stairsLocation.x] = 'STAIRS_DOWN';
            const enemyUnitLocations = (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.pickUnoccupiedLocations)(tileTypes, ['FLOOR'], [stairsLocation], numEnemies);
            const [playerUnitLocation] = this._pickPlayerLocation(tileTypes, [stairsLocation, ...enemyUnitLocations]);
            const itemLocations = (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.pickUnoccupiedLocations)(tileTypes, ['FLOOR'], [stairsLocation, playerUnitLocation, ...enemyUnitLocations], numItems);
            const tiles = tileTypes.map((row) => row.map(tileType => _types_TileFactory__WEBPACK_IMPORTED_MODULE_0__.default.createTile(tileType, this.tileSet)));
            return new _MapBuilder__WEBPACK_IMPORTED_MODULE_1__.default(level, width, height, tiles, section.rooms, playerUnitLocation, enemyUnitLocations, enemyUnitSupplier, itemLocations, itemSupplier);
        };
        /**
         * Spawn the player at the tile that maximizes average distance from enemies and the level exit.
         */
        this._pickPlayerLocation = (tiles, blockedTiles) => {
            const candidates = [];
            for (let y = 0; y < tiles.length; y++) {
                for (let x = 0; x < tiles[y].length; x++) {
                    if (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.isBlocking)(tiles[y][x]) && !blockedTiles.some(tile => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)(tile, { x, y }))) {
                        const tileDistances = blockedTiles.map(blockedTile => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)({ x, y }, blockedTile));
                        candidates.push([{ x, y }, (0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_3__.average)(tileDistances)]);
                    }
                }
            }
            console.assert(candidates.length > 0);
            return candidates.sort((a, b) => (b[1] - a[1]))[0];
        };
        /**
         * Verify that:
         * - all rooms can be connected
         * - wall placement is correct
         *   (all floor tiles have either another floor tile, or a wall + wall top directly above them)
         *
         * Frankly, this is a hack and it would be far better to have an algorithm which is mathematically provable
         * to generate the characteristics we want on a consistent basis.  But this is easier and should prevent regressions
         *
         * @return true if the provided `section` is valid
         */
        this._validateSection = (section) => this._validateRoomConnectivity(section) && this._validateWallPlacement(section);
        this._validateRoomConnectivity = (section) => {
            const { rooms } = section;
            const roomCenters = rooms.map(room => ({
                x: Math.round(room.left + room.width) / 2,
                y: Math.round(room.top + room.height) / 2
            }));
            const tileChecker = new _TileEligibilityChecker__WEBPACK_IMPORTED_MODULE_5__.default();
            const unblockedTiles = [];
            for (let y = 0; y < section.height; y++) {
                for (let x = 0; x < section.width; x++) {
                    if (!tileChecker.isBlocked({ x, y }, section, [])) {
                        unblockedTiles.push({ x, y });
                    }
                }
            }
            const pathfinder = new _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_4__.default(() => 1);
            for (let i = 0; i < rooms.length; i++) {
                for (let j = i + 1; j < rooms.length; j++) {
                    const path = pathfinder.findPath(roomCenters[i], roomCenters[j], unblockedTiles);
                    if (path.length === 0) {
                        return false;
                    }
                }
            }
            return true;
        };
        this._validateWallPlacement = (section) => {
            const floorTypes = ['FLOOR', 'FLOOR_HALL'];
            const wallTypes = ['WALL', 'WALL_HALL'];
            for (let y = 0; y < section.height; y++) {
                for (let x = 0; x < section.width; x++) {
                    const tileType = section.tiles[y][x];
                    if (floorTypes.indexOf(tileType) > -1) {
                        if (y < 2) {
                            return false;
                        }
                        const oneUp = section.tiles[y - 1][x];
                        const twoUp = section.tiles[y - 2][x];
                        if (floorTypes.indexOf(oneUp) > -1) {
                            // continue
                        }
                        else if (wallTypes.indexOf(oneUp) > -1) {
                            if (twoUp !== 'WALL_TOP') {
                                return false;
                            }
                        }
                    }
                }
            }
            return true;
        };
        this.tileSet = tileSet;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DungeonGenerator);


/***/ }),

/***/ "./src/main/maps/generation/RoomCorridorDungeonGenerator2.ts":
/*!*******************************************************************!*\
  !*** ./src/main/maps/generation/RoomCorridorDungeonGenerator2.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DungeonGenerator */ "./src/main/maps/generation/DungeonGenerator.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/random */ "./src/main/utils/random.ts");
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");



const ROOM_PADDING = [2, 3, 1, 1]; // left, top, right, bottom
const MIN_ROOM_FRACTION = 0.4;
const MAX_ROOM_FRACTION = 0.8;
class RoomCorridorDungeonGenerator2 extends _DungeonGenerator__WEBPACK_IMPORTED_MODULE_0__.default {
    /**
     * @param minRoomDimension inner width, not including wall
     * @param maxRoomDimension inner width, not including wall
     */
    constructor(tileSet, minRoomDimension, maxRoomDimension) {
        super(tileSet);
        this._generateTiles = (width, height, sections, connections, internalConnections) => {
            const tiles = [];
            for (let y = 0; y < height; y++) {
                const row = [];
                for (let x = 0; x < width; x++) {
                    row.push('NONE');
                }
                tiles.push(row);
            }
            // add floor tiles for rooms
            for (const section of sections) {
                if (!!section.roomRect) {
                    for (let y = section.roomRect.top; y < section.roomRect.top + section.roomRect.height; y++) {
                        for (let x = section.roomRect.left; x < section.roomRect.left + section.roomRect.width; x++) {
                            tiles[y][x] = 'FLOOR';
                        }
                    }
                }
            }
            // add floor tiles for connections
            for (const connection of connections) {
                const dx = Math.sign(connection.endCoordinates.x - connection.startCoordinates.x);
                const dy = Math.sign(connection.endCoordinates.y - connection.startCoordinates.y);
                let { x, y } = connection.startCoordinates;
                while (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)({ x, y }, connection.endCoordinates)) {
                    tiles[y][x] = 'FLOOR_HALL';
                    x += dx;
                    y += dy;
                }
                tiles[y][x] = 'FLOOR_HALL';
            }
            this._addTilesForInternalConnections(tiles, internalConnections, connections);
            return tiles;
        };
        this._addWalls = (tiles) => {
            const height = tiles.length;
            const width = tiles[0].length;
            for (let y = 0; y < height - 2; y++) {
                for (let x = 0; x < width; x++) {
                    if (tiles[y][x] === 'NONE'
                        && tiles[y + 1][x] === 'NONE'
                        && (tiles[y + 2][x] === 'FLOOR' || tiles[y + 2][x] === 'FLOOR_HALL')) {
                        tiles[y][x] = 'WALL_TOP';
                        tiles[y + 1][x] = (tiles[y + 2][x] === 'FLOOR') ? 'WALL' : 'WALL_HALL';
                    }
                }
            }
        };
        this._canConnect = (first, second) => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.areAdjacent)(first.rect, second.rect, 5);
        this._connectionMatches = (connection, first, second) => {
            // ref. equality should be fine
            if (connection.start === first && connection.end === second) {
                return true;
            }
            else if (connection.start === second && connection.end === first) {
                return true;
            }
            else {
                return false;
            }
        };
        this._buildConnection = (first, second) => {
            let connectionPoint; // on the starting edge of `second`
            let firstCoordinates;
            let secondCoordinates;
            // right-left
            if (first.rect.left + first.rect.width === second.rect.left) {
                const top = Math.max(first.rect.top, second.rect.top);
                const bottom = Math.min(first.rect.top + first.rect.height, second.rect.top + second.rect.height); // exclusive
                connectionPoint = {
                    x: second.rect.left,
                    y: (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(top + 2, bottom - 2) // should be in range since we checked _canConnect already
                };
                firstCoordinates = { x: connectionPoint.x - 1, y: connectionPoint.y };
                secondCoordinates = { x: connectionPoint.x + 1, y: connectionPoint.y };
            }
            // bottom-top
            else if (first.rect.top + first.rect.height === second.rect.top) {
                const left = Math.max(first.rect.left, second.rect.left);
                const right = Math.min(first.rect.left + first.rect.width, second.rect.left + second.rect.width); // exclusive
                connectionPoint = {
                    x: (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(left + 2, right - 2),
                    y: second.rect.top
                };
                firstCoordinates = { x: connectionPoint.x, y: connectionPoint.y - 1 };
                secondCoordinates = { x: connectionPoint.x, y: connectionPoint.y + 1 };
            }
            // left-right
            else if (first.rect.left === second.rect.left + second.rect.width) {
                const top = Math.max(first.rect.top, second.rect.top);
                const bottom = Math.min(first.rect.top + first.rect.height, second.rect.top + second.rect.height); // exclusive
                connectionPoint = {
                    x: first.rect.left,
                    y: (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(top + 2, bottom - 2) // should be in range since we checked _canConnect already
                };
                firstCoordinates = { x: connectionPoint.x + 1, y: connectionPoint.y };
                secondCoordinates = { x: connectionPoint.x - 1, y: connectionPoint.y };
            }
            // top-bottom
            else if (first.rect.top === second.rect.top + second.rect.height) {
                const left = Math.max(first.rect.left, second.rect.left);
                const right = Math.min(first.rect.left + first.rect.width, second.rect.left + second.rect.width); // exclusive
                connectionPoint = {
                    x: (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(left + 2, right - 2),
                    y: first.rect.top
                };
                firstCoordinates = { x: connectionPoint.x, y: connectionPoint.y + 1 };
                secondCoordinates = { x: connectionPoint.x, y: connectionPoint.y - 1 };
            }
            else {
                throw 'Failed to build connection';
            }
            const direction = (firstCoordinates.x === secondCoordinates.x) ? 'VERTICAL' : 'HORIZONTAL';
            const middleCoordinates = {
                x: (firstCoordinates.x + secondCoordinates.x) / 2,
                y: (firstCoordinates.y + secondCoordinates.y) / 2
            };
            return {
                start: first,
                end: second,
                startCoordinates: firstCoordinates,
                endCoordinates: secondCoordinates,
                middleCoordinates,
                direction
            };
        };
        this._connectionToString = (connection) => `[(${connection.startCoordinates.x}, ${connection.startCoordinates.y})-(${connection.endCoordinates.x}, ${connection.endCoordinates.y})]`;
        this._addTilesForInternalConnections = (tiles, internalConnections, connections) => {
            for (const internalConnection of internalConnections) {
                const neighbors = [...internalConnection.neighbors];
                (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.shuffle)(neighbors);
                for (let i = 0; i < neighbors.length - 1; i++) {
                    const firstNeighbor = internalConnection.neighbors[i];
                    const secondNeighbor = internalConnection.neighbors[i + 1];
                    const firstConnection = connections.filter(c => this._connectionMatches(c, internalConnection.section, firstNeighbor))[0];
                    const secondConnection = connections.filter(c => this._connectionMatches(c, internalConnection.section, secondNeighbor))[0];
                    if (!firstConnection || !secondConnection) {
                        console.error('fux3');
                        console.log(connections.map(this._connectionToString).join(', '));
                        console.log(neighbors.join(' '));
                        console.log(firstNeighbor.rect);
                        console.log(secondNeighbor.rect);
                        return;
                    }
                    if (firstConnection.direction !== secondConnection.direction) {
                        // join perpendicularly
                        this._joinPerpendicularly(tiles, firstConnection, secondConnection);
                    }
                    else {
                        // join parallel connections
                        // TODO: This will also try to join U-shaped connections, and doesn't do it correctly!
                        // For now, we're just going to run a validation step and regenerate if it fails.
                        this._joinParallelConnections(tiles, internalConnection, firstConnection, secondConnection);
                    }
                }
            }
        };
        this._joinPerpendicularly = (tiles, firstConnection, secondConnection) => {
            const start = firstConnection.middleCoordinates;
            const end = secondConnection.middleCoordinates;
            const middle = {
                x: ((firstConnection.direction === 'VERTICAL') ? start : end).x,
                y: ((firstConnection.direction === 'HORIZONTAL') ? start : end).y
            };
            let dx = Math.sign(middle.x - start.x);
            let dy = Math.sign(middle.y - start.y);
            let { x, y } = start;
            while (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)({ x, y }, middle)) {
                tiles[y][x] = 'FLOOR_HALL';
                x += dx;
                y += dy;
            }
            dx = Math.sign(end.x - middle.x);
            dy = Math.sign(end.y - middle.y);
            while (!(0,_MapUtils__WEBPACK_IMPORTED_MODULE_2__.coordinatesEquals)({ x, y }, end)) {
                tiles[y][x] = 'FLOOR_HALL';
                x += dx;
                y += dy;
            }
        };
        this._joinParallelConnections = (tiles, internalConnection, firstConnection, secondConnection) => {
            const start = firstConnection.middleCoordinates;
            const end = secondConnection.middleCoordinates;
            const middle = {
                x: Math.round((start.x + end.x) / 2),
                y: Math.round((start.y + end.y) / 2)
            };
            const xDistance = end.x - start.x;
            const yDistance = end.y - start.y;
            const dx = Math.sign(xDistance);
            const dy = Math.sign(yDistance);
            const majorDirection = (Math.abs(xDistance) >= Math.abs(yDistance)) ? 'HORIZONTAL' : 'VERTICAL';
            let { x, y } = start;
            switch (majorDirection) {
                case 'HORIZONTAL':
                    while (x !== middle.x) {
                        tiles[y][x] = 'FLOOR_HALL';
                        x += dx;
                    }
                    while (y !== end.y) {
                        tiles[y][x] = 'FLOOR_HALL';
                        y += dy;
                    }
                    while (x !== end.x) {
                        tiles[y][x] = 'FLOOR_HALL';
                        x += dx;
                    }
                    break;
                case 'VERTICAL':
                    while (y !== middle.y) {
                        tiles[y][x] = 'FLOOR_HALL';
                        y += dy;
                    }
                    while (x !== end.x) {
                        tiles[y][x] = 'FLOOR_HALL';
                        x += dx;
                    }
                    while (y !== end.y) {
                        tiles[y][x] = 'FLOOR_HALL';
                        y += dy;
                    }
                    break;
            }
        };
        /**
         * A connection is orphaned if, for either of its endpoints, there is neither a room nor a connected
         * internal connection that connects to that endpoint.
         *
         * @return a copy of `externalConnections` with the desired elements removed
         */
        this._stripOrphanedConnections = (externalConnections, internalConnections) => {
            let removedAnyConnections = false;
            do {
                const orphanedConnections = externalConnections.filter(connection => {
                    return this._isOrphanedConnection(connection, internalConnections);
                });
                this._subtract(externalConnections, orphanedConnections);
                for (const internalConnection of internalConnections) {
                    this._pruneInternalConnection(internalConnection, orphanedConnections);
                }
                const orphanedInternalConnections = internalConnections.filter(internalConnection => {
                    return this._isOrphanedInternalConnection(internalConnection, internalConnections);
                });
                this._subtract(internalConnections, orphanedInternalConnections);
                removedAnyConnections = (orphanedConnections.length > 0 || orphanedInternalConnections.length > 0);
                console.log(`stripping: ${orphanedConnections.length}, ${orphanedInternalConnections.length}`);
            } while (removedAnyConnections);
        };
        this._isOrphanedConnection = (connection, internalConnections) => {
            const { start, end } = connection;
            let startHasInternalConnection = false;
            let endHasInternalConnection = false;
            for (const internalConnection of internalConnections) {
                if (internalConnection.section === start && internalConnection.neighbors.indexOf(end) > -1) {
                    startHasInternalConnection = true;
                }
                if (internalConnection.section === end && internalConnection.neighbors.indexOf(start) > -1) {
                    endHasInternalConnection = true;
                }
            }
            return !((!!start.roomRect || startHasInternalConnection)
                && (!!end.roomRect || endHasInternalConnection));
        };
        this._pruneInternalConnection = (internalConnection, orphanedConnections) => {
            for (const connection of orphanedConnections) {
                const { section, neighbors } = internalConnection;
                const { start, end } = connection;
                const updatedNeighbors = neighbors.filter(neighbor => {
                    if (section === start && neighbor === end) {
                        return false;
                    }
                    if (section === end && neighbor === start) {
                        return false;
                    }
                    return true;
                });
                this._replace(neighbors, updatedNeighbors);
            }
        };
        /**
         * An internal connection is orphaned if at most one of its neighbors has either a room or another
         * internal connection
         */
        this._isOrphanedInternalConnection = (internalConnection, internalConnections) => {
            let connectedNeighbors = 0;
            const { section, neighbors } = internalConnection;
            for (const neighbor of neighbors) {
                const neighborHasInternalConnection = internalConnections.find(other => other.section === neighbor && other.neighbors.indexOf(section) > -1);
                if (!!neighbor.roomRect || neighborHasInternalConnection) {
                    connectedNeighbors++;
                }
            }
            return connectedNeighbors <= 1;
        };
        this._replace = (array, contents) => {
            array.splice(0, array.length);
            array.push(...contents);
        };
        this._subtract = (array, toRemove) => {
            const updated = array.filter(element => toRemove.indexOf(element) === -1);
            this._replace(array, updated);
        };
        this.minRoomDimension = minRoomDimension;
        this.maxRoomDimension = maxRoomDimension;
    }
    generateTiles(width, height) {
        // 1. Recursively subdivide the map into sections.
        //    Each section must fall within the max dimensions.
        // 2. Add rooms within sections, with appropriate padding.
        //    (Don't add a room for every section; approximately half.  Rules TBD.)
        const sections = this._generateSections(0, 0, width, height);
        this._removeRooms(sections);
        // 3. Construct a minimal spanning tree between sections (including those without rooms).
        const minimalSpanningTree = this._generateMinimalSpanningTree(sections);
        // 4.  Add all optional connections between sections.
        const optionalConnections = this._generateOptionalConnections(sections, minimalSpanningTree);
        // 5. Add "red-red" connections in empty rooms.
        // 6. Add "red-green" connections in empty rooms only if:
        //    - both edges connect to a room
        //    - there is no red-red connection in the section
        const internalConnections = this._addInternalConnections(sections, minimalSpanningTree, optionalConnections);
        const externalConnections = [...minimalSpanningTree, ...optionalConnections];
        this._stripOrphanedConnections(externalConnections, internalConnections);
        // TODO
        const debugOutput = `
      Sections: ${sections.map(section => this._sectionToString(section)).join('; ')}
      MST: ${minimalSpanningTree.map(this._connectionToString).join('; ')}
      opt: ${optionalConnections.map(this._connectionToString).join('; ')}
      external: ${externalConnections.map(this._connectionToString).join('; ')}
      Internal: ${internalConnections.map(connection => `${this._sectionToString(connection.section)}, ${connection.neighbors.length}`).join('; ')}
    `;
        console.log(debugOutput);
        // END TODO
        // Compute the actual tiles based on section/connection specifications.
        const tiles = this._generateTiles(width, height, sections, externalConnections, internalConnections);
        // 7. Add walls.
        this._addWalls(tiles);
        return {
            tiles,
            rooms: [],
            width,
            height
        };
    }
    _sectionToString(section) {
        return `(${section.rect.left}, ${section.rect.top}, ${section.rect.width}, ${section.rect.height})`;
    }
    /**
     * Generate a rectangular area of tiles with the specified dimensions, consisting of any number of rooms connected
     * by corridors.  To do so, split the area into two sub-areas and call this method recursively.  If this area is
     * not large enough to form two sub-regions, just return a single section.
     */
    _generateSections(left, top, width, height) {
        const splitDirection = this._getSplitDirection(width, height);
        if (splitDirection === 'HORIZONTAL') {
            const splitX = this._getSplitPoint(left, width, splitDirection);
            const leftWidth = splitX - left;
            const leftSections = this._generateSections(left, top, leftWidth, height);
            const rightWidth = width - leftWidth;
            const rightSections = this._generateSections(splitX, top, rightWidth, height);
            return [...leftSections, ...rightSections];
        }
        else if (splitDirection === 'VERTICAL') {
            const splitY = this._getSplitPoint(top, height, splitDirection);
            const topHeight = splitY - top;
            const bottomHeight = height - topHeight;
            const topSections = this._generateSections(left, top, width, topHeight);
            const bottomSections = this._generateSections(left, splitY, width, bottomHeight);
            return [...topSections, ...bottomSections];
        }
        else {
            // base case: generate single section
            const rect = {
                left,
                top,
                width,
                height
            };
            const padding = 1;
            const leftPadding = 2;
            const topPadding = 2;
            const roomRect = {
                left: left + leftPadding,
                top: top + topPadding,
                width: width - padding - leftPadding,
                height: height - padding - topPadding
            };
            return [{ rect, roomRect }];
        }
    }
    _getSplitDirection(width, height) {
        // First, make sure the area is large enough to support two sections; if not, we're done
        const minWidth = this.minRoomDimension + ROOM_PADDING[0] + ROOM_PADDING[2];
        const minHeight = this.minRoomDimension + ROOM_PADDING[1] + ROOM_PADDING[3];
        const canSplitHorizontally = (width >= (2 * minWidth));
        const canSplitVertically = (height >= (2 * minHeight));
        if (canSplitHorizontally) {
            return 'HORIZONTAL';
        }
        else if (canSplitVertically) {
            return 'VERTICAL';
        }
        else {
            return null;
        }
    }
    /**
     * @param start left or top
     * @param dimension width or height
     * @returns the min X/Y coordinate of the *second* room
     */
    _getSplitPoint(start, dimension, direction) {
        const minWidth = this.minRoomDimension + ROOM_PADDING[0] + ROOM_PADDING[2];
        const minHeight = this.minRoomDimension + ROOM_PADDING[1] + ROOM_PADDING[3];
        const minSectionDimension = (direction === 'HORIZONTAL' ? minWidth : minHeight);
        const minSplitPoint = start + minSectionDimension;
        const maxSplitPoint = start + dimension - minSectionDimension;
        return (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(minSplitPoint, maxSplitPoint);
    }
    _removeRooms(sections) {
        const minRooms = Math.max(3, Math.round(sections.length * MIN_ROOM_FRACTION));
        const maxRooms = Math.max(minRooms, sections.length * MAX_ROOM_FRACTION);
        if (sections.length < minRooms) {
            throw 'Not enough sections';
        }
        const numRooms = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randInt)(minRooms, maxRooms);
        const shuffledSections = [...sections];
        (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.shuffle)(shuffledSections);
        for (let i = numRooms; i < shuffledSections.length; i++) {
            shuffledSections[i].roomRect = null;
        }
    }
    _generateMinimalSpanningTree(sections) {
        const connectedSection = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randChoice)(sections);
        const connectedSections = [connectedSection];
        const unconnectedSections = [...sections].filter(section => section !== connectedSection);
        (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.shuffle)(unconnectedSections);
        const connections = [];
        while (unconnectedSections.length > 0) {
            (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.shuffle)(connectedSections);
            let connectedAny = false;
            for (let i = 0; i < connectedSections.length; i++) {
                const connectedSection = connectedSections[i];
                for (let j = 0; j < unconnectedSections.length; j++) {
                    const unconnectedSection = unconnectedSections[j];
                    if (this._canConnect(connectedSection, unconnectedSection)) {
                        unconnectedSections.splice(j, 1);
                        connectedSections.push(unconnectedSection);
                        connections.push(this._buildConnection(connectedSection, unconnectedSection));
                        connectedAny = true;
                        break;
                    }
                }
            }
            if (!connectedAny) {
                console.log('connected:');
                connectedSections.forEach(x => console.log(x));
                console.log('unconnected:');
                unconnectedSections.forEach(x => console.log(x));
                throw 'Failed to generate minimal spanning tree';
            }
        }
        return connections;
    }
    _generateOptionalConnections(sections, spanningConnections) {
        const optionalConnections = [];
        for (let i = 0; i < sections.length; i++) {
            const first = sections[i];
            for (let j = i + 1; j < sections.length; j++) {
                const second = sections[j];
                if (this._canConnect(first, second)) {
                    if (!spanningConnections.some(connection => this._connectionMatches(connection, first, second))) {
                        optionalConnections.push(this._buildConnection(first, second));
                    }
                }
            }
        }
        return optionalConnections;
    }
    _addInternalConnections(sections, spanningConnections, optionalConnections) {
        const internalConnections = [];
        for (const section of sections) {
            if (!section.roomRect) {
                const connectedSections = [];
                const neighbors = sections.filter(s => s !== section).filter(s => this._canConnect(section, s));
                for (const neighbor of neighbors) {
                    if (spanningConnections.some(connection => this._connectionMatches(connection, section, neighbor))) {
                        connectedSections.push(neighbor);
                    }
                }
                if (connectedSections.length === 1) {
                    (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.shuffle)(neighbors);
                    for (const neighbor of neighbors) {
                        if (optionalConnections.some(connection => this._connectionMatches(connection, section, neighbor))) {
                            connectedSections.push(neighbor);
                            break;
                        }
                    }
                }
                if (connectedSections.length > 0) {
                    internalConnections.push({ section, neighbors: connectedSections });
                }
            }
        }
        return internalConnections;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RoomCorridorDungeonGenerator2);


/***/ }),

/***/ "./src/main/maps/generation/TileEligibilityChecker.ts":
/*!************************************************************!*\
  !*** ./src/main/maps/generation/TileEligibilityChecker.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapUtils */ "./src/main/maps/MapUtils.ts");

class TileEligibilityChecker {
    constructor() {
        this.isBlocked = ({ x, y }, section, exits) => {
            // can't draw a path through an existing room or a wall
            const blockedTileTypes = ['FLOOR', /*'FLOOR_HALL',*/ 'WALL', 'WALL_HALL', 'WALL_TOP'];
            if (exits.some(exit => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)({ x, y }, exit))) {
                return false;
            }
            else if (section.tiles[y][x] === 'NONE' || section.tiles[y][x] === 'FLOOR_HALL') {
                let dy;
                // skip the check if we're within 1 tile vertically of an exit
                const isNextToExit = [-2, -1, 1, 2].some(dy => (exits.some(exit => (0,_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(exit, { x, y: y + dy }))));
                if (isNextToExit) {
                    return false;
                }
                // can't draw tiles within 2 tiles vertically of a wall tile, or a room floor tile
                for (dy of [-2, -1, 1, 2]) {
                    if ((y + dy >= 0) && (y + dy < section.height)) {
                        const tile = section.tiles[y + dy][x];
                        if (blockedTileTypes.indexOf(tile) > -1) {
                            return true;
                        }
                    }
                }
                return false;
            }
            else if (blockedTileTypes.indexOf(section.tiles[y][x]) > -1) {
                return true;
            }
            console.error('how\'d we get here?');
            return true;
        };
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TileEligibilityChecker);


/***/ }),

/***/ "./src/main/sounds/AudioUtils.ts":
/*!***************************************!*\
  !*** ./src/main/sounds/AudioUtils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transpose8va": () => (/* binding */ transpose8va),
/* harmony export */   "transpose8vb": () => (/* binding */ transpose8vb)
/* harmony export */ });
function transpose8va([freq, ms]) {
    return [freq * 2, ms];
}
function transpose8vb([freq, ms]) {
    return [freq / 2, ms];
}



/***/ }),

/***/ "./src/main/sounds/CustomOscillator.ts":
/*!*********************************************!*\
  !*** ./src/main/sounds/CustomOscillator.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class CustomOscillator {
    constructor(context, gainNode, repeating) {
        this._delegate = context.createOscillator();
        this._delegate.type = 'square';
        this._delegate.connect(gainNode);
        this._isComplete = false;
        this._isRepeating = repeating;
    }
    play(samples, context) {
        if (samples.length) {
            const startTime = context.currentTime;
            let nextStartTime = startTime;
            for (let i = 0; i < samples.length; i++) {
                const [freq, ms] = samples[i];
                this._delegate.frequency.setValueAtTime(freq, nextStartTime);
                nextStartTime += ms / 1000;
            }
            const runtime = samples.map(([freq, ms]) => ms).reduce((a, b) => a + b);
            this._delegate.start();
            this._delegate.onended = () => {
                if (this._isRepeating && !this._isComplete) {
                    this.play(samples, context);
                }
                else {
                    this._isComplete = true;
                }
            };
            this._delegate.stop(startTime + runtime / 1000);
        }
    }
    isComplete() {
        return this._isComplete;
    }
    stop() {
        this._delegate.stop(0);
        this._isComplete = true;
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CustomOscillator);


/***/ }),

/***/ "./src/main/sounds/Music.ts":
/*!**********************************!*\
  !*** ./src/main/sounds/Music.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SoundPlayer */ "./src/main/sounds/SoundPlayer.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/random */ "./src/main/utils/random.ts");
/* harmony import */ var _AudioUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AudioUtils */ "./src/main/sounds/AudioUtils.ts");



// TODO very hacky memoizing
let PLAYER = null;
let ACTIVE_SUITE = null;
const TITLE_THEME = [[600, 500], [300, 250], [150, 250], [900, 500], [450, 250], [300, 250], [500, 500], [300, 250], [200, 250], [200, 500], [300, 125], [600, 125], [900, 125], [1200, 125], [1500, 250]];
const GAME_OVER = [[400, 150], [300, 150], [238, 150], [200, 150], [300, 160], [238, 160], [200, 160], [150, 160], [238, 200], [200, 200], [150, 240], [100, 280], [75, 1000]];
const _getMusicPlayer = () => new _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__.default(4, 0.12);
function playSuite(suite) {
    ACTIVE_SUITE = suite;
    const sections = Object.values(suite.sections);
    const numRepeats = 4;
    for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        const bass = (!!section.bass) ? (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randChoice)(section.bass) : null;
        let lead;
        if (!!section.lead) {
            do {
                lead = (0,_utils_random__WEBPACK_IMPORTED_MODULE_1__.randChoice)(section.lead);
            } while (lead === bass);
        }
        for (let j = 0; j < numRepeats; j++) {
            setTimeout(() => {
                if (suite === ACTIVE_SUITE) {
                    const figures = [
                        ...(!!bass ? [bass.map(_AudioUtils__WEBPACK_IMPORTED_MODULE_2__.transpose8vb)] : []),
                        ...(!!lead ? [lead] : [])
                    ];
                    figures.forEach(figure => playFigure(figure));
                }
            }, ((numRepeats * i) + j) * suite.length);
        }
    }
    setTimeout(() => {
        if (suite === ACTIVE_SUITE) {
            playSuite(suite);
        }
    }, sections.length * suite.length * numRepeats);
}
function playFigure(samples) {
    if (!PLAYER) {
        PLAYER = _getMusicPlayer();
    }
    PLAYER.playSound(samples, false);
}
function stopMusic() {
    if (PLAYER) {
        PLAYER.stop();
    }
}
function stop() {
    stopMusic();
    ACTIVE_SUITE = null;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    TITLE_THEME,
    GAME_OVER,
    playFigure,
    playSuite,
    stop
});


/***/ }),

/***/ "./src/main/sounds/SoundFX.ts":
/*!************************************!*\
  !*** ./src/main/sounds/SoundFX.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "playSound": () => (/* binding */ playSound)
/* harmony export */ });
/* harmony import */ var _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SoundPlayer */ "./src/main/sounds/SoundPlayer.ts");

let PLAYER = null;
const _getSoundPlayer = () => new _SoundPlayer__WEBPACK_IMPORTED_MODULE_0__.default(4, 0.20);
const playSound = (samples) => {
    if (!PLAYER) {
        PLAYER = _getSoundPlayer();
    }
    PLAYER.playSound(samples, false);
};



/***/ }),

/***/ "./src/main/sounds/SoundPlayer.ts":
/*!****************************************!*\
  !*** ./src/main/sounds/SoundPlayer.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CustomOscillator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CustomOscillator */ "./src/main/sounds/CustomOscillator.ts");

class SoundPlayer {
    constructor(maxPolyphony, gain) {
        this._context = new AudioContext();
        this._gainNode = this._context.createGain();
        this._gainNode.gain.value = gain * 0.2; // sounds can be VERY loud
        this._gainNode.connect(this._context.destination);
        this._oscillators = [];
    }
    stop() {
        try {
            this._oscillators.forEach(oscillator => oscillator.stop());
        }
        catch (e) {
            console.error(e);
        }
    }
    ;
    playSound(samples, repeating = false) {
        const oscillator = new _CustomOscillator__WEBPACK_IMPORTED_MODULE_0__.default(this._context, this._gainNode, repeating);
        oscillator.play(samples, this._context);
        this._oscillators.push(oscillator);
        this._cleanup();
    }
    ;
    _cleanup() {
        this._oscillators = this._oscillators.filter(o => !o.isComplete());
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SoundPlayer);


/***/ }),

/***/ "./src/main/sounds/Sounds.ts":
/*!***********************************!*\
  !*** ./src/main/sounds/Sounds.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_sounds_deflected_hit_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/sounds/deflected_hit.json */ "./data/sounds/deflected_hit.json");
/* harmony import */ var _data_sounds_descend_stairs_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../data/sounds/descend_stairs.json */ "./data/sounds/descend_stairs.json");
/* harmony import */ var _data_sounds_enemy_dies_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../data/sounds/enemy_dies.json */ "./data/sounds/enemy_dies.json");
/* harmony import */ var _data_sounds_enemy_hits_player_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../data/sounds/enemy_hits_player.json */ "./data/sounds/enemy_hits_player.json");
/* harmony import */ var _data_sounds_footstep_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../data/sounds/footstep.json */ "./data/sounds/footstep.json");
/* harmony import */ var _data_sounds_pick_up_item_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../data/sounds/pick_up_item.json */ "./data/sounds/pick_up_item.json");
/* harmony import */ var _data_sounds_player_dies_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../data/sounds/player_dies.json */ "./data/sounds/player_dies.json");
/* harmony import */ var _data_sounds_level_up_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../data/sounds/level_up.json */ "./data/sounds/level_up.json");
/* harmony import */ var _data_sounds_open_door_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../data/sounds/open_door.json */ "./data/sounds/open_door.json");
/* harmony import */ var _data_sounds_player_hits_enemy_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../data/sounds/player_hits_enemy.json */ "./data/sounds/player_hits_enemy.json");
/* harmony import */ var _data_sounds_special_attack_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../data/sounds/special_attack.json */ "./data/sounds/special_attack.json");
/* harmony import */ var _data_sounds_use_potion_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../data/sounds/use_potion.json */ "./data/sounds/use_potion.json");












const Sounds = {
    DEFLECTED_HIT: _data_sounds_deflected_hit_json__WEBPACK_IMPORTED_MODULE_0__,
    DESCEND_STAIRS: _data_sounds_descend_stairs_json__WEBPACK_IMPORTED_MODULE_1__,
    ENEMY_HITS_PLAYER: _data_sounds_enemy_hits_player_json__WEBPACK_IMPORTED_MODULE_3__,
    ENEMY_DIES: _data_sounds_enemy_dies_json__WEBPACK_IMPORTED_MODULE_2__,
    FOOTSTEP: _data_sounds_footstep_json__WEBPACK_IMPORTED_MODULE_4__,
    LEVEL_UP: _data_sounds_level_up_json__WEBPACK_IMPORTED_MODULE_7__,
    PICK_UP_ITEM: _data_sounds_pick_up_item_json__WEBPACK_IMPORTED_MODULE_5__,
    PLAYER_DIES: _data_sounds_player_dies_json__WEBPACK_IMPORTED_MODULE_6__,
    PLAYER_HITS_ENEMY: _data_sounds_player_hits_enemy_json__WEBPACK_IMPORTED_MODULE_9__,
    OPEN_DOOR: _data_sounds_open_door_json__WEBPACK_IMPORTED_MODULE_8__,
    SPECIAL_ATTACK: _data_sounds_special_attack_json__WEBPACK_IMPORTED_MODULE_10__,
    USE_POTION: _data_sounds_use_potion_json__WEBPACK_IMPORTED_MODULE_11__
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sounds);


/***/ }),

/***/ "./src/main/types/Color.ts":
/*!*********************************!*\
  !*** ./src/main/types/Color.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_colors_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/colors.json */ "./data/colors.json");

// I think this declaration merging works even though IntelliJ disagrees
const Color = _data_colors_json__WEBPACK_IMPORTED_MODULE_0__;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Color);


/***/ }),

/***/ "./src/main/types/Direction.ts":
/*!*************************************!*\
  !*** ./src/main/types/Direction.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Declaration merging wizardry below!
 */
var Direction;
(function (Direction) {
    Direction.N = { dx: 0, dy: -1 };
    Direction.E = { dx: 1, dy: 0 };
    Direction.S = { dx: 0, dy: 1 };
    Direction.W = { dx: -1, dy: 0 };
    const _map = new Map([
        ['N', Direction.N],
        ['E', Direction.E],
        ['S', Direction.S],
        ['W', Direction.W]
    ]);
    Direction.values = () => [Direction.N, Direction.E, Direction.S, Direction.W];
    Direction.equals = (first, second) => first.dx === second.dx && first.dy === second.dy;
    Direction.toString = (direction) => {
        if (Direction.equals(direction, Direction.N)) {
            return 'N';
        }
        else if (Direction.equals(direction, Direction.E)) {
            return 'E';
        }
        else if (Direction.equals(direction, Direction.S)) {
            return 'S';
        }
        else if (Direction.equals(direction, Direction.W)) {
            return 'W';
        }
        throw `Invalid direction ${direction}`;
    };
    Direction.toLegacyDirection = (direction) => {
        const lookup = new Map([
            ['N', 'NW'],
            ['E', 'NE'],
            ['S', 'SE'],
            ['W', 'SW']
        ]);
        return [...lookup.entries()]
            .filter(([from, to]) => Direction.equals(direction, _map.get(from)))
            .map(([from, to]) => to)[0];
    };
})(Direction || (Direction = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Direction);


/***/ }),

/***/ "./src/main/types/PaletteSwaps.ts":
/*!****************************************!*\
  !*** ./src/main/types/PaletteSwaps.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color */ "./src/main/types/Color.ts");

var PaletteSwaps;
(function (PaletteSwaps) {
    PaletteSwaps.create = (paletteSwaps) => {
        const map = {};
        Object.entries(paletteSwaps).forEach(([src, dest]) => {
            const srcHex = _Color__WEBPACK_IMPORTED_MODULE_0__.default[src];
            const destHex = _Color__WEBPACK_IMPORTED_MODULE_0__.default[dest];
            map[srcHex] = destHex;
        });
        return map;
    };
})(PaletteSwaps || (PaletteSwaps = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PaletteSwaps);


/***/ }),

/***/ "./src/main/types/TileFactory.ts":
/*!***************************************!*\
  !*** ./src/main/types/TileFactory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/random */ "./src/main/utils/random.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const createTileSet = (tileSetName) => __awaiter(void 0, void 0, void 0, function* () {
    const json = yield __webpack_require__("./data/tilesets lazy recursive ^\\.\\/.*\\.json$")(`./${tileSetName}.json`);
    const tileSet = {};
    for (const [tileType, filenames] of Object.entries(json.tiles)) {
        const tiles = [];
        for (const filename of filenames) {
            if (filename) {
                const sprite = yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.createTileSprite(`${tileSetName}/${filename}`);
                tiles.push(sprite);
            }
        }
        tileSet[tileType] = tiles;
    }
    return tileSet;
});
const createTile = (type, tileSet) => ({
    type,
    sprite: (0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.randChoice)(tileSet[type]),
    isBlocking: (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.isBlocking)(type)
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ createTileSet, createTile });


/***/ }),

/***/ "./src/main/types/types.ts":
/*!*********************************!*\
  !*** ./src/main/types/types.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Activity": () => (/* binding */ Activity),
/* harmony export */   "EquipmentSlot": () => (/* binding */ EquipmentSlot),
/* harmony export */   "GameScreen": () => (/* binding */ GameScreen),
/* harmony export */   "ItemCategory": () => (/* binding */ ItemCategory),
/* harmony export */   "MapLayout": () => (/* binding */ MapLayout)
/* harmony export */ });
var Activity;
(function (Activity) {
    Activity["STANDING"] = "STANDING";
    Activity["WALKING"] = "WALKING";
    Activity["ATTACKING"] = "ATTACKING";
    Activity["SHOOTING"] = "SHOOTING";
    Activity["DAMAGED"] = "DAMAGED";
})(Activity || (Activity = {}));
(function (Activity) {
    Activity.values = () => [
        Activity.STANDING,
        Activity.WALKING,
        Activity.ATTACKING,
        Activity.SHOOTING
    ];
})(Activity || (Activity = {}));
var EquipmentSlot;
(function (EquipmentSlot) {
    EquipmentSlot["MELEE_WEAPON"] = "MELEE_WEAPON";
    EquipmentSlot["RANGED_WEAPON"] = "RANGED_WEAPON";
    EquipmentSlot["CHEST"] = "CHEST";
    EquipmentSlot["HEAD"] = "HEAD";
})(EquipmentSlot || (EquipmentSlot = {}));
var GameScreen;
(function (GameScreen) {
    GameScreen["GAME"] = "GAME";
    GameScreen["INVENTORY"] = "INVENTORY";
    GameScreen["TITLE"] = "TITLE";
    GameScreen["VICTORY"] = "VICTORY";
    GameScreen["GAME_OVER"] = "GAME_OVER";
    GameScreen["MINIMAP"] = "MINIMAP";
})(GameScreen || (GameScreen = {}));
var ItemCategory;
(function (ItemCategory) {
    ItemCategory["POTION"] = "POTION";
    ItemCategory["SCROLL"] = "SCROLL";
    ItemCategory["WEAPON"] = "WEAPON";
    ItemCategory["ARMOR"] = "ARMOR";
})(ItemCategory || (ItemCategory = {}));
var MapLayout;
(function (MapLayout) {
    MapLayout["ROOMS_AND_CORRIDORS"] = "ROOMS_AND_CORRIDORS";
    MapLayout["BLOB"] = "BLOB";
})(MapLayout || (MapLayout = {}));



/***/ }),

/***/ "./src/main/units/Unit.ts":
/*!********************************!*\
  !*** ./src/main/units/Unit.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _items_InventoryMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../items/InventoryMap */ "./src/main/items/InventoryMap.ts");
/* harmony import */ var _items_equipment_EquipmentMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../items/equipment/EquipmentMap */ "./src/main/items/equipment/EquipmentMap.ts");
/* harmony import */ var _sounds_Music__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sounds/Music */ "./src/main/sounds/Music.ts");
/* harmony import */ var _UnitAbility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UnitAbility */ "./src/main/units/UnitAbility.ts");
/* harmony import */ var _types_Direction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/Direction */ "./src/main/types/Direction.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








// Regenerate 1% of life every 20 turns
const LIFE_PER_TURN_MULTIPLIER = 0.0005;
class Unit {
    constructor({ name, unitClass, sprite, level, coordinates: { x, y }, controller, equipment }) {
        this.char = '@';
        this._upkeep = () => {
            // life regeneration
            const lifePerTurn = this.maxLife * LIFE_PER_TURN_MULTIPLIER;
            this.lifeRemainder += lifePerTurn;
            const deltaLife = Math.floor(this.lifeRemainder);
            this.lifeRemainder -= deltaLife;
            this.life = Math.min(this.life + deltaLife, this.maxLife);
            // I hate javascript, wtf is this callback signature
            this.remainingCooldowns.forEach((cooldown, ability, map) => {
                map.set(ability, Math.max(cooldown - 1, 0));
            });
        };
        this._endOfTurn = () => {
            // decrement stun duration
            this.stunDuration = Math.max(this.stunDuration - 1, 0);
        };
        this.update = () => __awaiter(this, void 0, void 0, function* () {
            yield this._upkeep();
            if (this.stunDuration === 0) {
                yield this.controller.issueOrder(this);
            }
            yield this.sprite.getImage();
            yield this._endOfTurn();
        });
        this.getDamage = () => {
            let damage = this.damage;
            this.equipment.getEntries()
                .filter(([slot, item]) => (slot !== _types_types__WEBPACK_IMPORTED_MODULE_6__.EquipmentSlot.RANGED_WEAPON))
                .forEach(([slot, item]) => {
                damage += (item.damage || 0);
            });
            return damage;
        };
        this.getRangedDamage = () => {
            let damage = this.damage;
            this.equipment.getEntries()
                .filter(([slot, item]) => (slot !== _types_types__WEBPACK_IMPORTED_MODULE_6__.EquipmentSlot.MELEE_WEAPON))
                .forEach(([slot, item]) => {
                if (slot === _types_types__WEBPACK_IMPORTED_MODULE_6__.EquipmentSlot.RANGED_WEAPON) {
                    damage += (item.damage || 0);
                }
                else {
                    damage += (item.damage || 0) / 2;
                }
            });
            return Math.round(damage);
        };
        this._levelUp = (withSound) => {
            this.level++;
            const lifePerLevel = this.unitClass.lifePerLevel;
            this.maxLife += lifePerLevel;
            this.life += lifePerLevel;
            this.damage += this.unitClass.damagePerLevel;
            if (withSound) {
                (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_7__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.LEVEL_UP);
            }
        };
        this.gainExperience = (experience) => {
            this.experience += experience;
            const experienceToNextLevel = this.experienceToNextLevel();
            while (!!experienceToNextLevel && this.experience >= experienceToNextLevel) {
                this.experience -= experienceToNextLevel;
                this._levelUp(true);
            }
        };
        this.experienceToNextLevel = () => {
            const { unitClass } = this;
            if (unitClass.experienceToNextLevel && (this.level < unitClass.maxLevel)) {
                return unitClass.experienceToNextLevel[this.level];
            }
            return null;
        };
        this.takeDamage = (damage, sourceUnit) => {
            const { playerUnit } = jwb.state;
            const map = jwb.state.getMap();
            this.life = Math.max(this.life - damage, 0);
            if (this.life === 0) {
                map.removeUnit(this);
                if (this === playerUnit) {
                    jwb.state.screen = _types_types__WEBPACK_IMPORTED_MODULE_6__.GameScreen.GAME_OVER;
                    _sounds_Music__WEBPACK_IMPORTED_MODULE_3__.default.stop();
                    _sounds_Music__WEBPACK_IMPORTED_MODULE_3__.default.playFigure(_sounds_Music__WEBPACK_IMPORTED_MODULE_3__.default.GAME_OVER);
                }
                else {
                    (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_7__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.ENEMY_DIES);
                }
                if (sourceUnit) {
                    sourceUnit.gainExperience(1);
                }
            }
        };
        this.getCooldown = (ability) => (this.remainingCooldowns.get(ability) || 0);
        this.useAbility = (ability) => this.remainingCooldowns.set(ability, ability.cooldown);
        this.unitClass = unitClass;
        this.sprite = sprite;
        sprite.target = this;
        this.inventory = new _items_InventoryMap__WEBPACK_IMPORTED_MODULE_1__.default();
        this.x = x;
        this.y = y;
        this.name = name;
        this.level = 1;
        this.experience = 0;
        this.life = unitClass.startingLife;
        this.maxLife = unitClass.startingLife;
        this.mana = unitClass.startingMana;
        this.maxMana = unitClass.startingMana;
        this.lifeRemainder = 0;
        this.damage = unitClass.startingDamage;
        this.controller = controller;
        this.activity = _types_types__WEBPACK_IMPORTED_MODULE_6__.Activity.STANDING;
        this.direction = _types_Direction__WEBPACK_IMPORTED_MODULE_5__.default.S;
        this.remainingCooldowns = new Map();
        // TODO: this needs to be specific to the player unit
        this.abilities = [_UnitAbility__WEBPACK_IMPORTED_MODULE_4__.default.ATTACK, _UnitAbility__WEBPACK_IMPORTED_MODULE_4__.default.HEAVY_ATTACK, _UnitAbility__WEBPACK_IMPORTED_MODULE_4__.default.KNOCKBACK_ATTACK, _UnitAbility__WEBPACK_IMPORTED_MODULE_4__.default.STUN_ATTACK];
        this.stunDuration = 0;
        this.equipment = new _items_equipment_EquipmentMap__WEBPACK_IMPORTED_MODULE_2__.default();
        for (const eq of equipment) {
            this.equipment.add(eq);
            eq.attach(this);
        }
        while (this.level < level) {
            this._levelUp(false);
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Unit);


/***/ }),

/***/ "./src/main/units/UnitAbility.ts":
/*!***************************************!*\
  !*** ./src/main/units/UnitAbility.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sounds/Sounds */ "./src/main/sounds/Sounds.ts");
/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/types */ "./src/main/types/types.ts");
/* harmony import */ var _sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sounds/SoundFX */ "./src/main/sounds/SoundFX.ts");
/* harmony import */ var _graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graphics/animations/Animations */ "./src/main/graphics/animations/Animations.ts");
// TODO: There's a ton of repeated code among the various abilities, try to refactor more of this into the base class
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




/**
 * Helper function for most melee attacks
 */
const attack = (unit, target, damage) => __awaiter(void 0, void 0, void 0, function* () {
    jwb.state.messages.push(`${unit.name} hit ${target.name} for ${damage} damage!`);
    yield (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_3__.playAttackingAnimation)(unit, target);
    yield target.takeDamage(damage, unit);
});
class UnitAbility {
    constructor(name, cooldown, icon = null) {
        this.name = name;
        this.cooldown = cooldown;
        this.icon = icon;
    }
}
class NormalAttack extends UnitAbility {
    constructor() {
        super('ATTACK', 0);
        this.use = (unit, direction) => __awaiter(this, void 0, void 0, function* () {
            if (!direction) {
                throw 'NormalAttack requires a direction!';
            }
            const { dx, dy } = direction;
            const { x, y } = { x: unit.x + dx, y: unit.y + dy };
            const { playerUnit } = jwb.state;
            const map = jwb.state.getMap();
            unit.direction = { dx: x - unit.x, dy: y - unit.y };
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    const damage = unit.getDamage();
                    yield attack(unit, targetUnit, damage);
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.PLAYER_HITS_ENEMY);
                }
            }
        });
    }
}
class HeavyAttack extends UnitAbility {
    constructor() {
        super('HEAVY_ATTACK', 15, 'strong_icon');
        this.use = (unit, direction) => __awaiter(this, void 0, void 0, function* () {
            if (!direction) {
                throw 'HeavyAttack requires a direction!';
            }
            const { dx, dy } = direction;
            const { x, y } = { x: unit.x + dx, y: unit.y + dy };
            const { playerUnit } = jwb.state;
            const map = jwb.state.getMap();
            unit.direction = { dx: x - unit.x, dy: y - unit.y };
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    unit.useAbility(this);
                    const damage = unit.getDamage() * 2;
                    yield attack(unit, targetUnit, damage);
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.SPECIAL_ATTACK);
                }
            }
        });
    }
}
class KnockbackAttack extends UnitAbility {
    constructor() {
        super('KNOCKBACK_ATTACK', 15, 'knockback_icon');
        this.use = (unit, direction) => __awaiter(this, void 0, void 0, function* () {
            if (!direction) {
                throw 'KnockbackAttack requires a direction!';
            }
            const { dx, dy } = direction;
            const { x, y } = { x: unit.x + dx, y: unit.y + dy };
            const { playerUnit } = jwb.state;
            const map = jwb.state.getMap();
            unit.direction = { dx: x - unit.x, dy: y - unit.y };
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    unit.useAbility(this);
                    const damage = unit.getDamage();
                    yield attack(unit, targetUnit, damage);
                    let targetCoordinates = { x, y };
                    // knockback by one tile
                    const oneTileBack = { x: targetCoordinates.x + dx, y: targetCoordinates.y + dy };
                    if (map.contains(oneTileBack) && !map.isBlocked(oneTileBack)) {
                        targetCoordinates = oneTileBack;
                    }
                    [targetUnit.x, targetUnit.y] = [targetCoordinates.x, targetCoordinates.y];
                    // stun for 1 turn (if they're already stunned, just leave it)
                    targetUnit.stunDuration = Math.max(targetUnit.stunDuration, 1);
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.SPECIAL_ATTACK);
                }
            }
        });
    }
}
class StunAttack extends UnitAbility {
    constructor() {
        super('STUN_ATTACK', 15, 'knockback_icon');
        this.use = (unit, direction) => __awaiter(this, void 0, void 0, function* () {
            if (!direction) {
                throw 'StunAttack requires a direction!';
            }
            const { dx, dy } = direction;
            const { x, y } = { x: unit.x + dx, y: unit.y + dy };
            const { playerUnit } = jwb.state;
            const map = jwb.state.getMap();
            unit.direction = { dx: x - unit.x, dy: y - unit.y };
            if (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                [unit.x, unit.y] = [x, y];
                if (unit === playerUnit) {
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.FOOTSTEP);
                }
            }
            else {
                const targetUnit = map.getUnit({ x, y });
                if (!!targetUnit) {
                    unit.useAbility(this);
                    const damage = unit.getDamage();
                    yield attack(unit, targetUnit, damage);
                    // stun for 2 turns (if they're already stunned, just leave it)
                    targetUnit.stunDuration = Math.max(targetUnit.stunDuration, 2);
                    yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.SPECIAL_ATTACK);
                }
            }
        });
    }
}
class ShootArrow extends UnitAbility {
    constructor() {
        super('SHOOT_ARROW', 0);
        this.use = (unit, direction) => __awaiter(this, void 0, void 0, function* () {
            if (!direction) {
                throw 'ShootArrow requires a direction!';
            }
            const { dx, dy } = direction;
            unit.direction = { dx, dy };
            yield jwb.renderer.render();
            if (!unit.equipment.get(_types_types__WEBPACK_IMPORTED_MODULE_1__.EquipmentSlot.RANGED_WEAPON)) {
                // change direction and re-render, but don't do anything (don't spend a turn)
                return;
            }
            const map = jwb.state.getMap();
            const coordinatesList = [];
            let { x, y } = { x: unit.x + dx, y: unit.y + dy };
            while (map.contains({ x, y }) && !map.isBlocked({ x, y })) {
                coordinatesList.push({ x, y });
                x += dx;
                y += dy;
            }
            const targetUnit = map.getUnit({ x, y });
            if (!!targetUnit) {
                const { messages } = jwb.state;
                const damage = unit.getRangedDamage();
                messages.push(`${unit.name} hit ${targetUnit.name} for ${damage} damage!`);
                yield (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_3__.playArrowAnimation)(unit, { dx, dy }, coordinatesList, targetUnit);
                yield targetUnit.takeDamage(damage, unit);
                yield (0,_sounds_SoundFX__WEBPACK_IMPORTED_MODULE_2__.playSound)(_sounds_Sounds__WEBPACK_IMPORTED_MODULE_0__.default.PLAYER_HITS_ENEMY);
            }
            else {
                yield (0,_graphics_animations_Animations__WEBPACK_IMPORTED_MODULE_3__.playArrowAnimation)(unit, { dx, dy }, coordinatesList, null);
            }
        });
    }
}
(function (UnitAbility) {
    UnitAbility.ATTACK = new NormalAttack();
    UnitAbility.HEAVY_ATTACK = new HeavyAttack();
    UnitAbility.KNOCKBACK_ATTACK = new KnockbackAttack();
    UnitAbility.STUN_ATTACK = new StunAttack();
    UnitAbility.SHOOT_ARROW = new ShootArrow();
})(UnitAbility || (UnitAbility = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnitAbility);


/***/ }),

/***/ "./src/main/units/UnitBehaviors.ts":
/*!*****************************************!*\
  !*** ./src/main/units/UnitBehaviors.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_Direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/Direction */ "./src/main/types/Direction.ts");
/* harmony import */ var _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Pathfinder */ "./src/main/utils/Pathfinder.ts");
/* harmony import */ var _UnitAbility__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UnitAbility */ "./src/main/units/UnitAbility.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/random */ "./src/main/utils/random.ts");
/* harmony import */ var _utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ArrayUtils */ "./src/main/utils/ArrayUtils.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");






function _wanderAndAttack(unit) {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    const tiles = [];
    _types_Direction__WEBPACK_IMPORTED_MODULE_0__.default.values().forEach(({ dx, dy }) => {
        const [x, y] = [unit.x + dx, unit.y + dy];
        if (map.contains({ x, y })) {
            if (!map.isBlocked({ x, y })) {
                tiles.push({ x, y });
            }
            else if (map.getUnit({ x, y })) {
                if (map.getUnit({ x, y }) === playerUnit) {
                    tiles.push({ x, y });
                }
            }
        }
    });
    if (tiles.length > 0) {
        const { x, y } = (0,_utils_random__WEBPACK_IMPORTED_MODULE_3__.randChoice)(tiles);
        const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
        return _UnitAbility__WEBPACK_IMPORTED_MODULE_2__.default.ATTACK.use(unit, { dx, dy });
    }
    return Promise.resolve();
}
function _wander(unit) {
    const map = jwb.state.getMap();
    const tiles = [];
    _types_Direction__WEBPACK_IMPORTED_MODULE_0__.default.values().forEach(({ dx, dy }) => {
        const [x, y] = [unit.x + dx, unit.y + dy];
        if (map.contains({ x, y })) {
            if (!map.isBlocked({ x, y })) {
                tiles.push({ x, y });
            }
        }
    });
    if (tiles.length > 0) {
        const { x, y } = (0,_utils_random__WEBPACK_IMPORTED_MODULE_3__.randChoice)(tiles);
        const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
        return _UnitAbility__WEBPACK_IMPORTED_MODULE_2__.default.ATTACK.use(unit, { dx, dy });
    }
    return Promise.resolve();
}
function _attackPlayerUnit_withPath(unit) {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    const mapRect = map.getRect();
    const unblockedTiles = [];
    for (let y = 0; y < mapRect.height; y++) {
        for (let x = 0; x < mapRect.width; x++) {
            if (!map.getTile({ x, y }).isBlocking) {
                unblockedTiles.push({ x, y });
            }
            else if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_5__.coordinatesEquals)({ x, y }, playerUnit)) {
                unblockedTiles.push({ x, y });
            }
            else {
                // blocked
            }
        }
    }
    const path = new _utils_Pathfinder__WEBPACK_IMPORTED_MODULE_1__.default(() => 1).findPath(unit, playerUnit, unblockedTiles);
    if (path.length > 1) {
        const { x, y } = path[1]; // first tile is the unit's own tile
        const unitAtPoint = map.getUnit({ x, y });
        if (!unitAtPoint || unitAtPoint === playerUnit) {
            const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
            return _UnitAbility__WEBPACK_IMPORTED_MODULE_2__.default.ATTACK.use(unit, { dx, dy });
        }
    }
    return Promise.resolve();
}
function _fleeFromPlayerUnit(unit) {
    const { playerUnit } = jwb.state;
    const map = jwb.state.getMap();
    const tiles = [];
    _types_Direction__WEBPACK_IMPORTED_MODULE_0__.default.values().forEach(({ dx, dy }) => {
        const [x, y] = [unit.x + dx, unit.y + dy];
        if (map.contains({ x, y })) {
            if (!map.isBlocked({ x, y })) {
                tiles.push({ x, y });
            }
            else if (map.getUnit({ x, y })) {
                if (map.getUnit({ x, y }) === playerUnit) {
                    tiles.push({ x, y });
                }
            }
        }
    });
    if (tiles.length > 0) {
        const orderedTiles = tiles.sort((0,_utils_ArrayUtils__WEBPACK_IMPORTED_MODULE_4__.comparingReversed)(coordinates => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_5__.manhattanDistance)(coordinates, playerUnit)));
        const { x, y } = orderedTiles[0];
        const { dx, dy } = { dx: x - unit.x, dy: y - unit.y };
        return _UnitAbility__WEBPACK_IMPORTED_MODULE_2__.default.ATTACK.use(unit, { dx, dy });
    }
    return Promise.resolve();
}
var UnitBehavior;
(function (UnitBehavior) {
    UnitBehavior.WANDER = _wander;
    UnitBehavior.ATTACK_PLAYER = _attackPlayerUnit_withPath;
    UnitBehavior.FLEE_FROM_PLAYER = _fleeFromPlayerUnit;
    UnitBehavior.STAY = () => Promise.resolve();
})(UnitBehavior || (UnitBehavior = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnitBehavior);


/***/ }),

/***/ "./src/main/units/UnitClass.ts":
/*!*************************************!*\
  !*** ./src/main/units/UnitClass.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_units_grunt_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/units/grunt.json */ "./data/units/grunt.json");
/* harmony import */ var _data_units_player_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../data/units/player.json */ "./data/units/player.json");
/* harmony import */ var _data_units_snake_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../data/units/snake.json */ "./data/units/snake.json");
/* harmony import */ var _data_units_soldier_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../data/units/soldier.json */ "./data/units/soldier.json");
/* harmony import */ var _data_units_golem_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../data/units/golem.json */ "./data/units/golem.json");
/* harmony import */ var _types_PaletteSwaps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/PaletteSwaps */ "./src/main/types/PaletteSwaps.ts");






const _load = (json) => {
    return Object.assign(Object.assign({}, json), { 
        // We're using "friendly" color names, convert them to hex now
        paletteSwaps: _types_PaletteSwaps__WEBPACK_IMPORTED_MODULE_5__.default.create(json.paletteSwaps) });
};
const _enemyClasses = [_data_units_grunt_json__WEBPACK_IMPORTED_MODULE_0__, _data_units_golem_json__WEBPACK_IMPORTED_MODULE_4__, _data_units_soldier_json__WEBPACK_IMPORTED_MODULE_3__, _data_units_snake_json__WEBPACK_IMPORTED_MODULE_2__].map(json => _load(json));
var UnitClass;
(function (UnitClass) {
    UnitClass.PLAYER = _load(_data_units_player_json__WEBPACK_IMPORTED_MODULE_1__);
    UnitClass.getEnemyClasses = () => {
        return _enemyClasses;
    };
    UnitClass.load = _load;
})(UnitClass || (UnitClass = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnitClass);


/***/ }),

/***/ "./src/main/units/UnitFactory.ts":
/*!***************************************!*\
  !*** ./src/main/units/UnitFactory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graphics/sprites/SpriteFactory */ "./src/main/graphics/sprites/SpriteFactory.ts");
/* harmony import */ var _items_ItemFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../items/ItemFactory */ "./src/main/items/ItemFactory.ts");
/* harmony import */ var _UnitClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UnitClass */ "./src/main/units/UnitClass.ts");
/* harmony import */ var _Unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Unit */ "./src/main/units/Unit.ts");
/* harmony import */ var _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controllers/AIUnitControllers */ "./src/main/units/controllers/AIUnitControllers.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/random */ "./src/main/utils/random.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const createUnit = ({ name, unitClass, controller, level, coordinates }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const sprite = yield _graphics_sprites_SpriteFactory__WEBPACK_IMPORTED_MODULE_0__.default.createUnitSprite(unitClass.sprite, unitClass.paletteSwaps);
    const equipment = yield Promise.all((_a = (unitClass.equipment || [])) === null || _a === void 0 ? void 0 : _a.map(_items_ItemFactory__WEBPACK_IMPORTED_MODULE_1__.default.createEquipment));
    return new _Unit__WEBPACK_IMPORTED_MODULE_3__.default({
        name,
        unitClass,
        controller,
        level,
        coordinates,
        equipment,
        sprite
    });
});
const createRandomEnemy = ({ x, y }, level) => __awaiter(void 0, void 0, void 0, function* () {
    const candidates = _UnitClass__WEBPACK_IMPORTED_MODULE_2__.default.getEnemyClasses()
        .filter(unitClass => level >= unitClass.minLevel)
        .filter(unitClass => level <= unitClass.maxLevel);
    const unitClass = (0,_utils_random__WEBPACK_IMPORTED_MODULE_5__.randChoice)(candidates);
    return createUnit({
        name: unitClass.name,
        unitClass,
        controller: _controllers_AIUnitControllers__WEBPACK_IMPORTED_MODULE_4__.HUMAN_DETERMINISTIC,
        level,
        coordinates: { x, y }
    });
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    createUnit,
    createRandomEnemy
});


/***/ }),

/***/ "./src/main/units/controllers/AIUnitControllers.ts":
/*!*********************************************************!*\
  !*** ./src/main/units/controllers/AIUnitControllers.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HUMAN_CAUTIOUS": () => (/* binding */ HUMAN_CAUTIOUS),
/* harmony export */   "HUMAN_AGGRESSIVE": () => (/* binding */ HUMAN_AGGRESSIVE),
/* harmony export */   "HUMAN_DETERMINISTIC": () => (/* binding */ HUMAN_DETERMINISTIC)
/* harmony export */ });
/* harmony import */ var _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UnitBehaviors */ "./src/main/units/UnitBehaviors.ts");
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/random */ "./src/main/utils/random.ts");



const HUMAN_CAUTIOUS = {
    issueOrder(unit) {
        const { playerUnit } = jwb.state;
        let behavior;
        const distanceToPlayer = (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.manhattanDistance)(unit, playerUnit);
        if (distanceToPlayer === 1) {
            if ((unit.life / unit.maxLife) >= 0.4) {
                behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER;
            }
            else {
                behavior = (0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                    'ATTACK_PLAYER': 0.2,
                    'WANDER': 0.5,
                    'FLEE_FROM_PLAYER': 0.3
                }, _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default);
            }
        }
        else if (distanceToPlayer >= 5) {
            behavior = (0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'WANDER': 0.3,
                'ATTACK_PLAYER': 0.1,
                'STAY': 0.6
            }, _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default);
        }
        else {
            behavior = (0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'ATTACK_PLAYER': 0.6,
                'WANDER': 0.2,
                'STAY': 0.2
            }, _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default);
        }
        return behavior(unit);
    }
};
const HUMAN_AGGRESSIVE = {
    issueOrder(unit) {
        const { playerUnit } = jwb.state;
        let behavior;
        const distanceToPlayer = (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.manhattanDistance)(unit, playerUnit);
        if (distanceToPlayer === 1) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER;
        }
        else if (distanceToPlayer >= 6) {
            behavior = (0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'WANDER': 0.4,
                'STAY': 0.4,
                'ATTACK_PLAYER': 0.2
            }, _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default);
        }
        else {
            behavior = (0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.weightedRandom)({
                'ATTACK_PLAYER': 0.9,
                'STAY': 0.1
            }, _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default);
        }
        return behavior(unit);
    }
};
const HUMAN_DETERMINISTIC = {
    issueOrder(unit) {
        const { playerUnit, turn } = jwb.state;
        const { aiParameters } = unit.unitClass;
        if (!aiParameters) {
            throw 'HUMAN_DETERMINISTIC behavior requires aiParams!';
        }
        const { speed, visionRange, fleeThreshold } = aiParameters;
        let behavior;
        const distanceToPlayer = (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_1__.manhattanDistance)(unit, playerUnit);
        if (!_canMove(speed)) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.STAY;
        }
        else if ((unit.life / unit.maxLife) < fleeThreshold) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.FLEE_FROM_PLAYER;
        }
        else if (distanceToPlayer <= visionRange) {
            behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.ATTACK_PLAYER;
        }
        else {
            if ((0,_utils_random__WEBPACK_IMPORTED_MODULE_2__.randInt)(0, 1) === 1) {
                behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.STAY;
            }
            else {
                behavior = _UnitBehaviors__WEBPACK_IMPORTED_MODULE_0__.default.WANDER;
            }
        }
        return behavior(unit);
    }
};
function _canMove(speed) {
    // deterministic version
    // const { turn } = jwb.state;
    // return Math.floor(speed * turn) > Math.floor(speed * (turn - 1));
    // random version
    return Math.random() < speed;
}



/***/ }),

/***/ "./src/main/units/controllers/PlayerUnitController.ts":
/*!************************************************************!*\
  !*** ./src/main/units/controllers/PlayerUnitController.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class PlayerUnitController {
    constructor() {
        this.queuedOrder = null;
    }
    issueOrder(unit) {
        if (!!this.queuedOrder) {
            const { queuedOrder } = this;
            this.queuedOrder = null;
            return queuedOrder();
        }
        return Promise.resolve();
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PlayerUnitController);


/***/ }),

/***/ "./src/main/utils/ArrayUtils.ts":
/*!**************************************!*\
  !*** ./src/main/utils/ArrayUtils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sortBy": () => (/* binding */ sortBy),
/* harmony export */   "sortByReversed": () => (/* binding */ sortByReversed),
/* harmony export */   "comparing": () => (/* binding */ comparing),
/* harmony export */   "comparingReversed": () => (/* binding */ comparingReversed),
/* harmony export */   "average": () => (/* binding */ average)
/* harmony export */ });
function sortBy(list, mapFunction) {
    return list.sort((a, b) => mapFunction(a) - mapFunction(b));
}
function sortByReversed(list, mapFunction) {
    return list.sort((a, b) => mapFunction(b) - mapFunction(a));
}
function comparing(mapFunction) {
    return (a, b) => mapFunction(a) - mapFunction(b);
}
function comparingReversed(mapFunction) {
    return (a, b) => mapFunction(b) - mapFunction(a);
}
function average(list) {
    const sum = list.reduce((a, b) => a + b);
    return sum / list.length;
}



/***/ }),

/***/ "./src/main/utils/Pathfinder.ts":
/*!**************************************!*\
  !*** ./src/main/utils/Pathfinder.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maps/MapUtils */ "./src/main/maps/MapUtils.ts");
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./random */ "./src/main/utils/random.ts");


const CARDINAL_DIRECTIONS = [[0, -1], [1, 0], [0, 1], [-1, 0]];
/**
 * @return the exact cost of the path from `start` to `coordinates`
 */
function g(node, start) {
    return node.cost;
}
/**
 * @return the heuristic estimated cost from `coordinates` to `goal`
 */
function h(coordinates, goal) {
    // return civDistance(coordinates, goal);
    return (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.manhattanDistance)(coordinates, goal);
}
/**
 * @return an estimate of the best cost from `start` to `goal` combining both `g` and `h`
 */
function f(node, start, goal) {
    return g(node, start) + h(node, goal);
}
function traverseParents(node) {
    const path = [];
    for (let currentNode = node; !!currentNode; currentNode = currentNode.parent) {
        const coordinates = { x: currentNode.x, y: currentNode.y };
        path.splice(0, 0, coordinates); // add it at the beginning of the list
    }
    return path;
}
/**
 * http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
 */
class Pathfinder {
    /**
     * http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html
     */
    constructor(tileCostCalculator) {
        this._tileCostCalculator = tileCostCalculator;
    }
    /**
     * http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#sketch
     *
     * @param tiles All allowable unblocked tiles
     */
    findPath(start, goal, tiles) {
        const open = [
            { x: start.x, y: start.y, cost: 0, parent: null }
        ];
        const closed = [];
        while (true) {
            if (open.length === 0) {
                return [];
            }
            const nodeCosts = open.map(node => ({ node, cost: f(node, start, goal) }))
                .sort((a, b) => a.cost - b.cost);
            const bestNode = nodeCosts[0].node;
            if ((0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(bestNode, goal)) {
                // Done!
                return traverseParents(bestNode);
            }
            else {
                const bestNodes = nodeCosts.filter(({ node, cost }) => cost === nodeCosts[0].cost);
                const { node: chosenNode, cost: chosenNodeCost } = (0,_random__WEBPACK_IMPORTED_MODULE_1__.randChoice)(bestNodes);
                open.splice(open.indexOf(chosenNode), 1);
                closed.push(chosenNode);
                this._findNeighbors(chosenNode, tiles).forEach(neighbor => {
                    if (closed.some(coordinates => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(coordinates, neighbor))) {
                        // already been seen, don't need to look at it*
                    }
                    else if (open.some(coordinates => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(coordinates, neighbor))) {
                        // don't need to look at it now, will look later?
                    }
                    else {
                        const movementCost = this._tileCostCalculator(chosenNode, neighbor);
                        open.push({
                            x: neighbor.x,
                            y: neighbor.y,
                            cost: chosenNodeCost + movementCost,
                            parent: chosenNode
                        });
                    }
                });
            }
        }
    }
    _findNeighbors(tile, tiles) {
        return CARDINAL_DIRECTIONS
            .map(([dx, dy]) => ({ x: tile.x + dx, y: tile.y + dy }))
            .filter(({ x, y }) => tiles.some(tile => (0,_maps_MapUtils__WEBPACK_IMPORTED_MODULE_0__.coordinatesEquals)(tile, { x, y })));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pathfinder);


/***/ }),

/***/ "./src/main/utils/PromiseUtils.ts":
/*!****************************************!*\
  !*** ./src/main/utils/PromiseUtils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wait": () => (/* binding */ wait)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const wait = (milliseconds) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, milliseconds);
    });
});



/***/ }),

/***/ "./src/main/utils/TemplateUtils.ts":
/*!*****************************************!*\
  !*** ./src/main/utils/TemplateUtils.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fillTemplate": () => (/* binding */ fillTemplate)
/* harmony export */ });
/**
 * Dynamically populate a template according to {@param template}. which specifies the template string,
 * and {@param variables}, which provides key-value substitutions for each variable in {@param template}.
 */
function fillTemplate(template, variables) {
    const keys = Object.keys(variables);
    const values = Object.values(variables);
    return new Function(...keys, `return \`${template}\`;`)(...values);
}



/***/ }),

/***/ "./src/main/utils/random.ts":
/*!**********************************!*\
  !*** ./src/main/utils/random.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "randInt": () => (/* binding */ randInt),
/* harmony export */   "randChoice": () => (/* binding */ randChoice),
/* harmony export */   "weightedRandom": () => (/* binding */ weightedRandom),
/* harmony export */   "shuffle": () => (/* binding */ shuffle)
/* harmony export */ });
/**
 * @param max inclusive
 */
const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
const randChoice = (list) => list[randInt(0, list.length - 1)];
/**
 * Fisher-Yates.  Stolen from https://bost.ocks.org/mike/shuffle/
 */
const shuffle = (list) => {
    let n = list.length;
    // While there remain elements to shuffle...
    while (n > 0) {
        // Pick a remaining element...
        const i = randInt(0, n - 1);
        n--;
        // And swap it with the current element.
        const tmp = list[n];
        list[n] = list[i];
        list[i] = tmp;
    }
};
const weightedRandom = (probabilities, mappedObjects) => {
    const total = Object.values(probabilities).reduce((a, b) => a + b);
    const rand = Math.random() * total;
    let counter = 0;
    const entries = Object.entries(probabilities);
    for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        counter += value;
        if (counter > rand) {
            return mappedObjects[key];
        }
    }
    throw 'Error in weightedRandom()!';
};



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "roguelike-js:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) var result = runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkroguelike_js"] = self["webpackChunkroguelike_js"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***************************!*\
  !*** ./src/main/index.ts ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/actions */ "./src/main/core/actions.ts");
/* harmony import */ var _core_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/debug */ "./src/main/core/debug.ts");


(0,_core_actions__WEBPACK_IMPORTED_MODULE_0__.initialize)();
(0,_core_debug__WEBPACK_IMPORTED_MODULE_1__.initDebug)();

})();

/******/ })()
;
//# sourceMappingURL=bundle.js.map